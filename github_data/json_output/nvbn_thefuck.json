{
  "repo_name": "nvbn/thefuck",
  "repo_url": "https://github.com/nvbn/thefuck",
  "description": "Magnificent app which corrects your previous console command.",
  "stars": 90964,
  "language": "Python",
  "created_at": "2015-04-08T15:08:04Z",
  "updated_at": "2025-03-19T06:24:40Z",
  "files": {
    "tests/conftest.py": "import os\nimport pytest\nfrom thefuck import shells\nfrom thefuck import conf, const\nfrom thefuck.system import Path\n\nshells.shell = shells.Generic()\n\n\ndef pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"functional: mark test as functional\")\n\n\ndef pytest_addoption(parser):\n    \"\"\"Adds `--enable-functional` argument.\"\"\"\n    group = parser.getgroup(\"thefuck\")\n    group.addoption('--enable-functional', action=\"store_true\", default=False,\n                    help=\"Enable functional tests\")\n\n\n@pytest.fixture\ndef no_memoize(monkeypatch):\n    monkeypatch.setattr('thefuck.utils.memoize.disabled', True)\n\n\n@pytest.fixture(autouse=True)\ndef settings(request):\n    def _reset_settings():\n        conf.settings.clear()\n        conf.settings.update(const.DEFAULT_SETTINGS)\n\n    request.addfinalizer(_reset_settings)\n    conf.settings.user_dir = Path('~/.thefuck')\n    return conf.settings\n\n\n@pytest.fixture\ndef no_colors(settings):\n    settings.no_colors = True\n\n\n@pytest.fixture(autouse=True)\ndef no_cache(monkeypatch):\n    monkeypatch.setattr('thefuck.utils.cache.disabled', True)\n\n\n@pytest.fixture(autouse=True)\ndef functional(request):\n    if request.node.get_closest_marker('functional') \\\n            and not request.config.getoption('enable_functional'):\n        pytest.skip('functional tests are disabled')\n\n\n@pytest.fixture\ndef source_root():\n    return Path(__file__).parent.parent.resolve()\n\n\n@pytest.fixture\ndef set_shell(monkeypatch):\n    def _set(cls):\n        shell = cls()\n        monkeypatch.setattr('thefuck.shells.shell', shell)\n        return shell\n\n    return _set\n\n\n@pytest.fixture(autouse=True)\ndef os_environ(monkeypatch):\n    env = {'PATH': os.environ['PATH']}\n    monkeypatch.setattr('os.environ', env)\n    return env\n",
    "tests/entrypoints/test_alias.py": "from mock import Mock\nimport pytest\nfrom thefuck.entrypoints.alias import _get_alias, print_alias\n\n\n@pytest.mark.parametrize(\n    'py2, enable_experimental_instant_mode, which, is_instant', [\n        (False, True, True, True),\n        (False, False, True, False),\n        (False, True, False, False),\n        (True, True, True, False),\n        (True, True, False, False),\n        (True, False, True, False)])\ndef test_get_alias(monkeypatch, mocker, py2,\n                   enable_experimental_instant_mode,\n                   which, is_instant):\n    monkeypatch.setattr('six.PY2', py2)\n    args = Mock(\n        enable_experimental_instant_mode=enable_experimental_instant_mode,\n        alias='fuck', )\n    mocker.patch('thefuck.entrypoints.alias.which', return_value=which)\n    shell = Mock(app_alias=lambda _: 'app_alias',\n                 instant_mode_alias=lambda _: 'instant_mode_alias')\n    monkeypatch.setattr('thefuck.entrypoints.alias.shell', shell)\n\n    alias = _get_alias(args)\n    if is_instant:\n        assert alias == 'instant_mode_alias'\n    else:\n        assert alias == 'app_alias'\n\n\ndef test_print_alias(mocker):\n    settings_mock = mocker.patch('thefuck.entrypoints.alias.settings')\n    _get_alias_mock = mocker.patch('thefuck.entrypoints.alias._get_alias')\n    known_args = Mock()\n    print_alias(known_args)\n    settings_mock.init.assert_called_once_with(known_args)\n    _get_alias_mock.assert_called_once_with(known_args)\n",
    "tests/entrypoints/test_fix_command.py": "import pytest\nfrom mock import Mock\nfrom thefuck.entrypoints.fix_command import _get_raw_command\n\n\nclass TestGetRawCommand(object):\n    def test_from_force_command_argument(self):\n        known_args = Mock(force_command='git brunch')\n        assert _get_raw_command(known_args) == ['git brunch']\n\n    def test_from_command_argument(self, os_environ):\n        os_environ['TF_HISTORY'] = None\n        known_args = Mock(force_command=None,\n                          command=['sl'])\n        assert _get_raw_command(known_args) == ['sl']\n\n    @pytest.mark.parametrize('history, result', [\n        ('git br', 'git br'),\n        ('git br\\nfcuk', 'git br'),\n        ('git br\\nfcuk\\nls', 'ls'),\n        ('git br\\nfcuk\\nls\\nfuk', 'ls')])\n    def test_from_history(self, os_environ, history, result):\n        os_environ['TF_HISTORY'] = history\n        known_args = Mock(force_command=None,\n                          command=None)\n        assert _get_raw_command(known_args) == [result]\n",
    "tests/entrypoints/test_not_configured.py": "import pytest\nimport json\nfrom six import StringIO\nfrom mock import MagicMock\nfrom thefuck.shells.generic import ShellConfiguration\nfrom thefuck.entrypoints.not_configured import main\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker(mocker):\n    return mocker.patch(\n        'thefuck.entrypoints.not_configured._get_not_configured_usage_tracker_path',\n        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_io(usage_tracker):\n    io = StringIO()\n    usage_tracker.return_value \\\n                 .open.return_value \\\n                 .__enter__.return_value = io\n    return io\n\n\n@pytest.fixture(autouse=True)\ndef usage_tracker_exists(usage_tracker):\n    usage_tracker.return_value \\\n                 .exists.return_value = True\n    return usage_tracker.return_value.exists\n\n\ndef _assert_tracker_updated(usage_tracker_io, pid):\n    usage_tracker_io.seek(0)\n    info = json.load(usage_tracker_io)\n    assert info['pid'] == pid\n\n\ndef _change_tracker(usage_tracker_io, pid):\n    usage_tracker_io.truncate(0)\n    info = {'pid': pid, 'time': 0}\n    json.dump(info, usage_tracker_io)\n    usage_tracker_io.seek(0)\n\n\n@pytest.fixture(autouse=True)\ndef shell_pid(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured._get_shell_pid',\n                        new_callable=MagicMock)\n\n\n@pytest.fixture(autouse=True)\ndef shell(mocker):\n    shell = mocker.patch('thefuck.entrypoints.not_configured.shell',\n                         new_callable=MagicMock)\n    shell.get_history.return_value = []\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=True)\n    return shell\n\n\n@pytest.fixture(autouse=True)\ndef shell_config(mocker):\n    path_mock = mocker.patch('thefuck.entrypoints.not_configured.Path',\n                             new_callable=MagicMock)\n    return path_mock.return_value \\\n        .expanduser.return_value \\\n        .open.return_value \\\n        .__enter__.return_value\n\n\n@pytest.fixture(autouse=True)\ndef logs(mocker):\n    return mocker.patch('thefuck.entrypoints.not_configured.logs',\n                        new_callable=MagicMock)\n\n\ndef test_for_generic_shell(shell, logs):\n    shell.how_to_configure.return_value = None\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run(usage_tracker_io, usage_tracker_exists, shell_pid, logs):\n    shell_pid.return_value = 12\n    main()\n    usage_tracker_exists.return_value = False\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_run_after_other_commands(usage_tracker_io, shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.get_history.return_value = ['fuck', 'ls']\n    _change_tracker(usage_tracker_io, 12)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_on_first_run_from_current_shell(usage_tracker_io, shell_pid,\n                                         shell, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    main()\n    _assert_tracker_updated(usage_tracker_io, 12)\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_cant_configure_automatically(shell_pid, shell, logs):\n    shell_pid.return_value = 12\n    shell.how_to_configure.return_value = ShellConfiguration(\n        content='eval $(thefuck --alias)',\n        path='/tmp/.bashrc',\n        reload='bash',\n        can_configure_automatically=False)\n    main()\n    logs.how_to_configure_alias.assert_called_once()\n\n\ndef test_when_already_configured(usage_tracker_io, shell_pid,\n                                 shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = 'eval $(thefuck --alias)'\n    main()\n    logs.already_configured.assert_called_once()\n\n\ndef test_when_successfully_configured(usage_tracker_io, shell_pid,\n                                      shell, shell_config, logs):\n    shell.get_history.return_value = ['fuck']\n    shell_pid.return_value = 12\n    _change_tracker(usage_tracker_io, 12)\n    shell_config.read.return_value = ''\n    main()\n    shell_config.write.assert_any_call('eval $(thefuck --alias)')\n    logs.configured_successfully.assert_called_once()\n",
    "tests/functional/conftest.py": "import pytest\n\nfrom pytest_docker_pexpect.docker import run as pexpect_docker_run, \\\n    stats as pexpect_docker_stats\n\n\n@pytest.fixture(autouse=True)\ndef build_container_mock(mocker):\n    return mocker.patch('pytest_docker_pexpect.docker.build_container')\n\n\ndef run_side_effect(*args, **kwargs):\n    container_id = pexpect_docker_run(*args, **kwargs)\n    pexpect_docker_stats(container_id)\n    return container_id\n\n\n@pytest.fixture(autouse=True)\ndef run_mock(mocker):\n    return mocker.patch('pytest_docker_pexpect.docker.run', side_effect=run_side_effect)\n",
    "tests/functional/plots.py": "def _set_confirmation(proc, require):\n    proc.sendline(u'mkdir -p ~/.thefuck')\n    proc.sendline(\n        u'echo \"require_confirmation = {}\" > ~/.thefuck/settings.py'.format(\n            require))\n\n\ndef with_confirmation(proc, TIMEOUT):\n    \"\"\"Ensures that command can be fixed when confirmation enabled.\"\"\"\n    _set_confirmation(proc, True)\n\n    proc.sendline(u'ehco test')\n\n    proc.sendline(u'fuck')\n    assert proc.expect([TIMEOUT, u'echo test'])\n    assert proc.expect([TIMEOUT, u'enter'])\n    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])\n    proc.send('\\n')\n\n    assert proc.expect([TIMEOUT, u'test'])\n\n\ndef history_changed(proc, TIMEOUT, *to):\n    \"\"\"Ensures that history changed.\"\"\"\n    proc.send('\\033[A')\n    pattern = [TIMEOUT]\n    pattern.extend(to)\n    assert proc.expect(pattern)\n\n\ndef history_not_changed(proc, TIMEOUT):\n    \"\"\"Ensures that history not changed.\"\"\"\n    proc.send('\\033[A')\n    assert proc.expect([TIMEOUT, u'fuck'])\n\n\ndef select_command_with_arrows(proc, TIMEOUT):\n    \"\"\"Ensures that command can be selected with arrow keys.\"\"\"\n    _set_confirmation(proc, True)\n\n    proc.sendline(u'git h')\n    assert proc.expect([TIMEOUT, u\"git: 'h' is not a git command.\"])\n\n    proc.sendline(u'fuck')\n    assert proc.expect([TIMEOUT, u'git show'])\n    proc.send('\\033[B')\n    assert proc.expect([TIMEOUT, u'git push'])\n    proc.send('\\033[B')\n    assert proc.expect([TIMEOUT, u'git help', u'git hook'])\n    proc.send('\\033[A')\n    assert proc.expect([TIMEOUT, u'git push'])\n    proc.send('\\033[B')\n    assert proc.expect([TIMEOUT, u'git help', u'git hook'])\n    proc.send('\\n')\n\n    assert proc.expect([TIMEOUT, u'usage', u'fatal: not a git repository'])\n\n\ndef refuse_with_confirmation(proc, TIMEOUT):\n    \"\"\"Ensures that fix can be refused when confirmation enabled.\"\"\"\n    _set_confirmation(proc, True)\n\n    proc.sendline(u'ehco test')\n\n    proc.sendline(u'fuck')\n    assert proc.expect([TIMEOUT, u'echo test'])\n    assert proc.expect([TIMEOUT, u'enter'])\n    assert proc.expect_exact([TIMEOUT, u'ctrl+c'])\n    proc.send('\\003')\n\n    assert proc.expect([TIMEOUT, u'Aborted'])\n\n\ndef without_confirmation(proc, TIMEOUT):\n    \"\"\"Ensures that command can be fixed when confirmation disabled.\"\"\"\n    _set_confirmation(proc, False)\n\n    proc.sendline(u'ehco test')\n\n    proc.sendline(u'fuck')\n    assert proc.expect([TIMEOUT, u'echo test'])\n    assert proc.expect([TIMEOUT, u'test'])\n\n\ndef how_to_configure(proc, TIMEOUT):\n    proc.sendline(u'fuck')\n    assert proc.expect([TIMEOUT, u\"alias isn't configured\"])\n",
    "tests/functional/test_bash.py": "import pytest\nfrom tests.functional.plots import with_confirmation, without_confirmation, \\\n    refuse_with_confirmation, history_changed, history_not_changed, \\\n    select_command_with_arrows, how_to_configure\n\n\npython_3 = (u'thefuck/python3',\n            u'',\n            u'sh')\n\npython_2 = (u'thefuck/python2',\n            u'',\n            u'sh')\n\n\ninit_bashrc = u'''echo '\nexport SHELL=/bin/bash\nexport PS1=\"$ \"\necho > $HISTFILE\neval $(thefuck --alias {})\necho \"instant mode ready: $THEFUCK_INSTANT_MODE\"\n' > ~/.bashrc'''\n\n\n@pytest.fixture(params=[(python_3, False),\n                        (python_3, True),\n                        (python_2, False)])\ndef proc(request, spawnu, TIMEOUT):\n    container, instant_mode = request.param\n    proc = spawnu(*container)\n    proc.sendline(init_bashrc.format(\n        u'--enable-experimental-instant-mode' if instant_mode else ''))\n    proc.sendline(u\"bash\")\n    if instant_mode:\n        assert proc.expect([TIMEOUT, u'instant mode ready: True'])\n    return proc\n\n\n@pytest.mark.functional\ndef test_with_confirmation(proc, TIMEOUT):\n    with_confirmation(proc, TIMEOUT)\n    history_changed(proc, TIMEOUT, u'echo test')\n\n\n@pytest.mark.functional\ndef test_select_command_with_arrows(proc, TIMEOUT):\n    select_command_with_arrows(proc, TIMEOUT)\n    history_changed(proc, TIMEOUT, u'git help', u'git hook')\n\n\n@pytest.mark.functional\ndef test_refuse_with_confirmation(proc, TIMEOUT):\n    refuse_with_confirmation(proc, TIMEOUT)\n    history_not_changed(proc, TIMEOUT)\n\n\n@pytest.mark.functional\ndef test_without_confirmation(proc, TIMEOUT):\n    without_confirmation(proc, TIMEOUT)\n    history_changed(proc, TIMEOUT, u'echo test')\n\n\n@pytest.mark.functional\ndef test_how_to_configure_alias(proc, TIMEOUT):\n    proc.sendline('unset -f fuck')\n    how_to_configure(proc, TIMEOUT)\n"
  },
  "requirements": "flake8\npytest\nmock\npytest-mock\nwheel\nsetuptools>=17.1\npexpect\npypandoc\npytest-benchmark\npytest-docker-pexpect\ntwine\n"
}