{
  "repo_name": "pallets/flask",
  "repo_url": "https://github.com/pallets/flask",
  "description": "The Python micro framework for building web applications.",
  "stars": 69104,
  "language": "Python",
  "created_at": "2010-04-06T11:11:59Z",
  "updated_at": "2025-03-19T06:47:49Z",
  "files": {
    "examples/javascript/tests/conftest.py": "import pytest\n\nfrom js_example import app\n\n\n@pytest.fixture(name=\"app\")\ndef fixture_app():\n    app.testing = True\n    yield app\n    app.testing = False\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n",
    "examples/javascript/tests/test_js_example.py": "import pytest\nfrom flask import template_rendered\n\n\n@pytest.mark.parametrize(\n    (\"path\", \"template_name\"),\n    (\n        (\"/\", \"fetch.html\"),\n        (\"/plain\", \"xhr.html\"),\n        (\"/fetch\", \"fetch.html\"),\n        (\"/jquery\", \"jquery.html\"),\n    ),\n)\ndef test_index(app, client, path, template_name):\n    def check(sender, template, context):\n        assert template.name == template_name\n\n    with template_rendered.connected_to(check, app):\n        client.get(path)\n\n\n@pytest.mark.parametrize(\n    (\"a\", \"b\", \"result\"), ((2, 3, 5), (2.5, 3, 5.5), (2, None, 2), (2, \"b\", 2))\n)\ndef test_add(client, a, b, result):\n    response = client.post(\"/add\", data={\"a\": a, \"b\": b})\n    assert response.get_json()[\"result\"] == result\n",
    "examples/tutorial/tests/conftest.py": "import os\nimport tempfile\n\nimport pytest\n\nfrom flaskr import create_app\nfrom flaskr.db import get_db\nfrom flaskr.db import init_db\n\n# read in SQL for populating test data\nwith open(os.path.join(os.path.dirname(__file__), \"data.sql\"), \"rb\") as f:\n    _data_sql = f.read().decode(\"utf8\")\n\n\n@pytest.fixture\ndef app():\n    \"\"\"Create and configure a new app instance for each test.\"\"\"\n    # create a temporary file to isolate the database for each test\n    db_fd, db_path = tempfile.mkstemp()\n    # create the app with common test config\n    app = create_app({\"TESTING\": True, \"DATABASE\": db_path})\n\n    # create the database and load test data\n    with app.app_context():\n        init_db()\n        get_db().executescript(_data_sql)\n\n    yield app\n\n    # close and remove the temporary database\n    os.close(db_fd)\n    os.unlink(db_path)\n\n\n@pytest.fixture\ndef client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()\n\n\n@pytest.fixture\ndef runner(app):\n    \"\"\"A test runner for the app's Click commands.\"\"\"\n    return app.test_cli_runner()\n\n\nclass AuthActions:\n    def __init__(self, client):\n        self._client = client\n\n    def login(self, username=\"test\", password=\"test\"):\n        return self._client.post(\n            \"/auth/login\", data={\"username\": username, \"password\": password}\n        )\n\n    def logout(self):\n        return self._client.get(\"/auth/logout\")\n\n\n@pytest.fixture\ndef auth(client):\n    return AuthActions(client)\n",
    "examples/tutorial/tests/test_auth.py": "import pytest\nfrom flask import g\nfrom flask import session\n\nfrom flaskr.db import get_db\n\n\ndef test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"/auth/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert response.headers[\"Location\"] == \"/auth/login\"\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"SELECT * FROM user WHERE username = 'a'\").fetchone()\n            is not None\n        )\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    (\n        (\"\", \"\", b\"Username is required.\"),\n        (\"a\", \"\", b\"Password is required.\"),\n        (\"test\", \"test\", b\"already registered\"),\n    ),\n)\ndef test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"/auth/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data\n\n\ndef test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"\n\n\n@pytest.mark.parametrize(\n    (\"username\", \"password\", \"message\"),\n    ((\"a\", \"test\", b\"Incorrect username.\"), (\"test\", \"a\", b\"Incorrect password.\")),\n)\ndef test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data\n\n\ndef test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session\n",
    "examples/tutorial/tests/test_blog.py": "import pytest\n\nfrom flaskr.db import get_db\n\n\ndef test_index(client, auth):\n    response = client.get(\"/\")\n    assert b\"Log In\" in response.data\n    assert b\"Register\" in response.data\n\n    auth.login()\n    response = client.get(\"/\")\n    assert b\"test title\" in response.data\n    assert b\"by test on 2018-01-01\" in response.data\n    assert b\"test\\nbody\" in response.data\n    assert b'href=\"/1/update\"' in response.data\n\n\n@pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\", \"/1/delete\"))\ndef test_login_required(client, path):\n    response = client.post(path)\n    assert response.headers[\"Location\"] == \"/auth/login\"\n\n\ndef test_author_required(app, client, auth):\n    # change the post author to another user\n    with app.app_context():\n        db = get_db()\n        db.execute(\"UPDATE post SET author_id = 2 WHERE id = 1\")\n        db.commit()\n\n    auth.login()\n    # current user can't modify other user's post\n    assert client.post(\"/1/update\").status_code == 403\n    assert client.post(\"/1/delete\").status_code == 403\n    # current user doesn't see edit link\n    assert b'href=\"/1/update\"' not in client.get(\"/\").data\n\n\n@pytest.mark.parametrize(\"path\", (\"/2/update\", \"/2/delete\"))\ndef test_exists_required(client, auth, path):\n    auth.login()\n    assert client.post(path).status_code == 404\n\n\ndef test_create(client, auth, app):\n    auth.login()\n    assert client.get(\"/create\").status_code == 200\n    client.post(\"/create\", data={\"title\": \"created\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        count = db.execute(\"SELECT COUNT(id) FROM post\").fetchone()[0]\n        assert count == 2\n\n\ndef test_update(client, auth, app):\n    auth.login()\n    assert client.get(\"/1/update\").status_code == 200\n    client.post(\"/1/update\", data={\"title\": \"updated\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post[\"title\"] == \"updated\"\n\n\n@pytest.mark.parametrize(\"path\", (\"/create\", \"/1/update\"))\ndef test_create_update_validate(client, auth, path):\n    auth.login()\n    response = client.post(path, data={\"title\": \"\", \"body\": \"\"})\n    assert b\"Title is required.\" in response.data\n\n\ndef test_delete(client, auth, app):\n    auth.login()\n    response = client.post(\"/1/delete\")\n    assert response.headers[\"Location\"] == \"/\"\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post is None\n",
    "examples/tutorial/tests/test_db.py": "import sqlite3\n\nimport pytest\n\nfrom flaskr.db import get_db\n\n\ndef test_get_close_db(app):\n    with app.app_context():\n        db = get_db()\n        assert db is get_db()\n\n    with pytest.raises(sqlite3.ProgrammingError) as e:\n        db.execute(\"SELECT 1\")\n\n    assert \"closed\" in str(e.value)\n\n\ndef test_init_db_command(runner, monkeypatch):\n    class Recorder:\n        called = False\n\n    def fake_init_db():\n        Recorder.called = True\n\n    monkeypatch.setattr(\"flaskr.db.init_db\", fake_init_db)\n    result = runner.invoke(args=[\"init-db\"])\n    assert \"Initialized\" in result.output\n    assert Recorder.called\n",
    "examples/tutorial/tests/test_factory.py": "from flaskr import create_app\n\n\ndef test_config():\n    \"\"\"Test create_app without passing test config.\"\"\"\n    assert not create_app().testing\n    assert create_app({\"TESTING\": True}).testing\n\n\ndef test_hello(client):\n    response = client.get(\"/hello\")\n    assert response.data == b\"Hello, World!\"\n",
    "src/flask/testing.py": "from __future__ import annotations\n\nimport importlib.metadata\nimport typing as t\nfrom contextlib import contextmanager\nfrom contextlib import ExitStack\nfrom copy import copy\nfrom types import TracebackType\nfrom urllib.parse import urlsplit\n\nimport werkzeug.test\nfrom click.testing import CliRunner\nfrom click.testing import Result\nfrom werkzeug.test import Client\nfrom werkzeug.wrappers import Request as BaseRequest\n\nfrom .cli import ScriptInfo\nfrom .sessions import SessionMixin\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n    from werkzeug.test import TestResponse\n\n    from .app import Flask\n\n\nclass EnvironBuilder(werkzeug.test.EnvironBuilder):\n    \"\"\"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\n    application.\n\n    :param app: The Flask application to configure the environment from.\n    :param path: URL path being requested.\n    :param base_url: Base URL where the app is being served, which\n        ``path`` is relative to. If not given, built from\n        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n    :param url_scheme: Scheme to use instead of\n        :data:`PREFERRED_URL_SCHEME`.\n    :param json: If given, this is serialized as JSON and passed as\n        ``data``. Also defaults ``content_type`` to\n        ``application/json``.\n    :param args: other positional arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    :param kwargs: other keyword arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        path: str = \"/\",\n        base_url: str | None = None,\n        subdomain: str | None = None,\n        url_scheme: str | None = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(\n            subdomain or url_scheme\n        ), 'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = urlsplit(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                path = f\"{path}?{url.query}\"\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:  # type: ignore\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n\n\n_werkzeug_version = \"\"\n\n\ndef _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n    Flask's contexts to defer the cleanup of the request context until\n    the end of a ``with`` block. For general information about how to\n    use this class refer to :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self._cookies is None:\n            raise TypeError(\n                \"Cookies are disabled. Create a client with 'use_cookies=True'.\"\n            )\n\n        app = self.application\n        ctx = app.test_request_context(*args, **kwargs)\n        self._add_cookies_to_wsgi(ctx.request.environ)\n\n        with ctx:\n            sess = app.session_interface.open_session(app, ctx.request)\n\n        if sess is None:\n            raise RuntimeError(\"Session backend did not open a session.\")\n\n        yield sess\n        resp = app.response_class()\n\n        if app.session_interface.is_null_session(sess):\n            return\n\n        with ctx:\n            app.session_interface.save_session(app, sess, resp)\n\n        self._update_cookies_from_response(\n            ctx.request.host.partition(\":\")[0],\n            ctx.request.path,\n            resp.headers.getlist(\"Set-Cookie\"),\n        )\n\n    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out\n\n    def _request_from_builder_args(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> BaseRequest:\n        kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n        builder = EnvironBuilder(self.application, *args, **kwargs)\n\n        try:\n            return builder.get_request()\n        finally:\n            builder.close()\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        if args and isinstance(\n            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n        ):\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                builder = copy(args[0])\n                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]\n                request = builder.get_request()\n            elif isinstance(args[0], dict):\n                request = EnvironBuilder.from_environ(\n                    args[0], app=self.application, environ_base=self._copy_environ({})\n                ).get_request()\n            else:\n                # isinstance(args[0], BaseRequest)\n                request = copy(args[0])\n                request.environ = self._copy_environ(request.environ)\n        else:\n            # request is None\n            request = self._request_from_builder_args(args, kwargs)\n\n        # Pop any previously preserved contexts. This prevents contexts\n        # from being preserved across redirects or multiple requests\n        # within a single block.\n        self._context_stack.close()\n\n        response = super().open(\n            request,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n        response.json_module = self.application.json  # type: ignore[assignment]\n\n        # Re-push contexts that were preserved during the request.\n        while self._new_contexts:\n            cm = self._new_contexts.pop()\n            self._context_stack.enter_context(cm)\n\n        return response\n\n    def __enter__(self) -> FlaskClient:\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.preserve_context = False\n        self._context_stack.close()\n\n\nclass FlaskCliRunner(CliRunner):\n    \"\"\"A :class:`~click.testing.CliRunner` for testing a Flask app's\n    CLI commands. Typically created using\n    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n    \"\"\"\n\n    def __init__(self, app: Flask, **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)\n\n    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)\n",
    "tests/conftest.py": "import os\nimport pkgutil\nimport sys\n\nimport pytest\nfrom _pytest import monkeypatch\n\nfrom flask import Flask\nfrom flask.globals import request_ctx\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef _standard_os_environ():\n    \"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"\n    mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, \"FLASK_ENV_FILE\", monkeypatch.notset),\n        (os.environ, \"FLASK_APP\", monkeypatch.notset),\n        (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n        (os.environ, \"FLASK_RUN_FROM_CLI\", monkeypatch.notset),\n        (os.environ, \"WERKZEUG_RUN_MAIN\", monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()\n\n\n@pytest.fixture(autouse=True)\ndef _reset_os_environ(monkeypatch, _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)\n\n\n@pytest.fixture\ndef app():\n    app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY=\"test key\",\n    )\n    return app\n\n\n@pytest.fixture\ndef app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx\n\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n\n@pytest.fixture\ndef test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for key in sys.modules.keys() - original_modules:\n        sys.modules.pop(key)\n\n\n@pytest.fixture(autouse=True)\ndef leak_detector():\n    yield\n\n    # make sure we're not leaking a request context since we are\n    # testing flask internally in debug mode in a few cases\n    leaks = []\n    while request_ctx:\n        leaks.append(request_ctx._get_current_object())\n        request_ctx.pop()\n\n    assert leaks == []\n\n\n@pytest.fixture(params=(True, False))\ndef limit_loader(request, monkeypatch):\n    \"\"\"Patch pkgutil.get_loader to give loader without get_filename or archive.\n\n    This provides for tests where a system has custom loaders, e.g. Google App\n    Engine's HardenedModulesHook, which have neither the `get_filename` method\n    nor the `archive` attribute.\n\n    This fixture will run the testcase twice, once with and once without the\n    limitation/mock.\n    \"\"\"\n    if not request.param:\n        return\n\n    class LimitedLoader:\n        def __init__(self, loader):\n            self.loader = loader\n\n        def __getattr__(self, name):\n            if name in {\"archive\", \"get_filename\"}:\n                raise AttributeError(f\"Mocking a loader which does not have {name!r}.\")\n            return getattr(self.loader, name)\n\n    old_get_loader = pkgutil.get_loader\n\n    def get_loader(*args, **kwargs):\n        return LimitedLoader(old_get_loader(*args, **kwargs))\n\n    monkeypatch.setattr(pkgutil, \"get_loader\", get_loader)\n\n\n@pytest.fixture\ndef modules_tmp_path(tmp_path, monkeypatch):\n    \"\"\"A temporary directory added to sys.path.\"\"\"\n    rv = tmp_path / \"modules_tmp\"\n    rv.mkdir()\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv\n\n\n@pytest.fixture\ndef modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\n    monkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\n    return modules_tmp_path\n\n\n@pytest.fixture\ndef site_packages(modules_tmp_path, monkeypatch):\n    \"\"\"Create a fake site-packages.\"\"\"\n    py_dir = f\"python{sys.version_info.major}.{sys.version_info.minor}\"\n    rv = modules_tmp_path / \"lib\" / py_dir / \"site-packages\"\n    rv.mkdir(parents=True)\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv\n\n\n@pytest.fixture\ndef purge_module(request):\n    def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n\n    return inner\n",
    "tests/test_appctx.py": "import pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.globals import request_ctx\n\n\ndef test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n\ndef test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")\n\n\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")\n\n\ndef test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app\n\n\ndef test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    assert cleanup_stuff == [None]\n\n\ndef test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"\n\n\ndef test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"\n\n\ndef test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n\ndef test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            with request_ctx:\n                pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]\n\n\ndef test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app\n"
  },
  "requirements": null
}