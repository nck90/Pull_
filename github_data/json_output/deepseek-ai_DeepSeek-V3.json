{
  "repo_name": "deepseek-ai/DeepSeek-V3",
  "repo_url": "https://github.com/deepseek-ai/DeepSeek-V3",
  "description": null,
  "stars": 92520,
  "language": "Python",
  "created_at": "2024-12-26T09:52:40Z",
  "updated_at": "2025-03-19T06:59:46Z",
  "files": {
    "inference/convert.py": "import os\nimport shutil\nfrom argparse import ArgumentParser\nfrom glob import glob\nfrom tqdm import tqdm, trange\n\nimport torch\nfrom safetensors.torch import safe_open, save_file\n\n\nmapping = {\n    \"embed_tokens\": (\"embed\", 0),\n    \"input_layernorm\": (\"attn_norm\", None),\n    \"post_attention_layernorm\": (\"ffn_norm\", None),\n    \"q_proj\": (\"wq\", 0),\n    \"q_a_proj\": (\"wq_a\", None),\n    \"q_a_layernorm\": (\"q_norm\", None),\n    \"q_b_proj\": (\"wq_b\", 0),\n    \"kv_a_proj_with_mqa\": (\"wkv_a\", None),\n    \"kv_a_layernorm\": (\"kv_norm\", None),\n    \"kv_b_proj\": (\"wkv_b\", 0),\n    \"o_proj\": (\"wo\", 1),\n    \"gate\": (\"gate\", None),\n    \"gate_proj\": (\"w1\", 0),\n    \"down_proj\": (\"w2\", 1),\n    \"up_proj\": (\"w3\", 0),\n    \"norm\": (\"norm\", None),\n    \"lm_head\": (\"head\", 0),\n    \"scale\": (\"scale\", None),\n}\n\n\ndef main(hf_ckpt_path, save_path, n_experts, mp):\n    \"\"\"\n    Converts and saves model checkpoint files into a specified format.\n\n    Args:\n        hf_ckpt_path (str): Path to the directory containing the input checkpoint files.\n        save_path (str): Path to the directory where the converted checkpoint files will be saved.\n        n_experts (int): Total number of experts in the model.\n        mp (int): Model parallelism factor.\n        \n    Returns:\n        None\n    \"\"\"\n    torch.set_num_threads(8)\n    n_local_experts = n_experts // mp\n    state_dicts = [{} for _ in range(mp)]\n\n    for file_path in tqdm(glob(os.path.join(hf_ckpt_path, \"*.safetensors\"))):\n        with safe_open(file_path, framework=\"pt\", device=\"cpu\") as f:\n            for name in f.keys():\n                if \"model.layers.61\" in name:\n                    continue\n                param: torch.Tensor = f.get_tensor(name)\n                if name.startswith(\"model.\"):\n                    name = name[len(\"model.\"):]\n                name = name.replace(\"self_attn\", \"attn\")\n                name = name.replace(\"mlp\", \"ffn\")\n                name = name.replace(\"weight_scale_inv\", \"scale\")\n                name = name.replace(\"e_score_correction_bias\", \"bias\")\n                key = name.split(\".\")[-2]\n                assert key in mapping, f\"Key {key} not found in mapping\"\n                new_key, dim = mapping[key]\n                name = name.replace(key, new_key)\n                for i in range(mp):\n                    new_param = param\n                    if \"experts\" in name and \"shared_experts\" not in name:\n                        idx = int(name.split(\".\")[-3])\n                        if idx < i * n_local_experts or idx >= (i + 1) * n_local_experts:\n                            continue\n                    elif dim is not None:\n                        assert param.size(dim) % mp == 0, f\"Dimension {dim} must be divisible by {mp}\"\n                        shard_size = param.size(dim) // mp\n                        new_param = param.narrow(dim, i * shard_size, shard_size).contiguous()\n                    state_dicts[i][name] = new_param\n\n    os.makedirs(save_path, exist_ok=True)\n\n    for i in trange(mp):\n        save_file(state_dicts[i], os.path.join(save_path, f\"model{i}-mp{mp}.safetensors\"))\n\n    for file_path in glob(os.path.join(hf_ckpt_path, \"*token*\")):\n        new_file_path = os.path.join(save_path, os.path.basename(file_path))\n        shutil.copyfile(file_path, new_file_path)\n\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument(\"--hf-ckpt-path\", type=str, required=True)\n    parser.add_argument(\"--save-path\", type=str, required=True)\n    parser.add_argument(\"--n-experts\", type=int, required=True)\n    parser.add_argument(\"--model-parallel\", type=int, required=True)\n    args = parser.parse_args()\n    assert args.n_experts % args.model_parallel == 0, \"Number of experts must be divisible by model parallelism\"\n    main(args.hf_ckpt_path, args.save_path, args.n_experts, args.model_parallel)\n",
    "inference/fp8_cast_bf16.py": "import os\nimport json\nfrom argparse import ArgumentParser\nfrom glob import glob\nfrom tqdm import tqdm\n\nimport torch\nfrom safetensors.torch import load_file, save_file\n\nfrom kernel import weight_dequant\n\ndef main(fp8_path, bf16_path):\n    \"\"\"\n    Converts FP8 weights to BF16 and saves the converted weights.\n\n    This function reads FP8 weights from the specified directory, converts them to BF16,\n    and saves the converted weights to another specified directory. It also updates the\n    model index file to reflect the changes.\n\n    Args:\n    fp8_path (str): The path to the directory containing the FP8 weights and model index file.\n    bf16_path (str): The path to the directory where the converted BF16 weights will be saved.\n\n    Raises:\n    KeyError: If a required scale_inv tensor is missing for a weight.\n\n    Notes:\n    - The function assumes that the FP8 weights are stored in safetensor files.\n    - The function caches loaded safetensor files to optimize memory usage.\n    - The function updates the model index file to remove references to scale_inv tensors.\n    \"\"\"\n    torch.set_default_dtype(torch.bfloat16)\n    os.makedirs(bf16_path, exist_ok=True)\n    model_index_file = os.path.join(fp8_path, \"model.safetensors.index.json\")\n    with open(model_index_file, \"r\") as f:\n        model_index = json.load(f)\n    weight_map = model_index[\"weight_map\"]\n    \n    # Cache for loaded safetensor files\n    loaded_files = {}\n    fp8_weight_names = []\n\n    # Helper function to get tensor from the correct file\n    def get_tensor(tensor_name):\n        \"\"\"\n        Retrieves a tensor from the cached safetensor files or loads it from disk if not cached.\n\n        Args:\n            tensor_name (str): The name of the tensor to retrieve.\n\n        Returns:\n            torch.Tensor: The retrieved tensor.\n\n        Raises:\n            KeyError: If the tensor does not exist in the safetensor file.\n        \"\"\"\n        file_name = weight_map[tensor_name]\n        if file_name not in loaded_files:\n            file_path = os.path.join(fp8_path, file_name)\n            loaded_files[file_name] = load_file(file_path, device=\"cuda\")\n        return loaded_files[file_name][tensor_name]\n\n    safetensor_files = list(glob(os.path.join(fp8_path, \"*.safetensors\")))\n    safetensor_files.sort()\n    for safetensor_file in tqdm(safetensor_files):\n        file_name = os.path.basename(safetensor_file)\n        current_state_dict = load_file(safetensor_file, device=\"cuda\")\n        loaded_files[file_name] = current_state_dict\n        \n        new_state_dict = {}\n        for weight_name, weight in current_state_dict.items():\n            if weight_name.endswith(\"_scale_inv\"):\n                continue\n            elif weight.element_size() == 1:  # FP8 weight\n                scale_inv_name = f\"{weight_name}_scale_inv\"\n                try:\n                    # Get scale_inv from the correct file\n                    scale_inv = get_tensor(scale_inv_name)\n                    fp8_weight_names.append(weight_name)\n                    new_state_dict[weight_name] = weight_dequant(weight, scale_inv)\n                except KeyError:\n                    print(f\"Warning: Missing scale_inv tensor for {weight_name}, skipping conversion\")\n                    new_state_dict[weight_name] = weight\n            else:\n                new_state_dict[weight_name] = weight\n                \n        new_safetensor_file = os.path.join(bf16_path, file_name)\n        save_file(new_state_dict, new_safetensor_file)\n        \n        # Memory management: keep only the 2 most recently used files\n        if len(loaded_files) > 2:\n            oldest_file = next(iter(loaded_files))\n            del loaded_files[oldest_file]\n            torch.cuda.empty_cache()\n    \n    # Update model index\n    new_model_index_file = os.path.join(bf16_path, \"model.safetensors.index.json\")\n    for weight_name in fp8_weight_names:\n        scale_inv_name = f\"{weight_name}_scale_inv\"\n        if scale_inv_name in weight_map:\n            weight_map.pop(scale_inv_name)\n    with open(new_model_index_file, \"w\") as f:\n        json.dump({\"metadata\": {}, \"weight_map\": weight_map}, f, indent=2)\n        \n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument(\"--input-fp8-hf-path\", type=str, required=True)\n    parser.add_argument(\"--output-bf16-hf-path\", type=str, required=True)\n    args = parser.parse_args()\n    main(args.input_fp8_hf_path, args.output_bf16_hf_path)\n    \n",
    "inference/generate.py": "import os\nimport json\nfrom argparse import ArgumentParser\nfrom typing import List\n\nimport torch\nimport torch.distributed as dist\nfrom transformers import AutoTokenizer\nfrom safetensors.torch import load_model\n\nfrom model import Transformer, ModelArgs\n\n\ndef sample(logits, temperature: float = 1.0):\n    \"\"\"\n    Samples a token from the logits using temperature scaling.\n\n    Args:\n        logits (torch.Tensor): The logits tensor for token predictions.\n        temperature (float, optional): Temperature for scaling logits. Defaults to 1.0.\n\n    Returns:\n        torch.Tensor: The sampled token.\n    \"\"\"\n    logits = logits / max(temperature, 1e-5)\n    probs = torch.softmax(logits, dim=-1)\n    return probs.div_(torch.empty_like(probs).exponential_(1)).argmax(dim=-1)\n\n\n@torch.inference_mode()\ndef generate(\n    model: Transformer,\n    prompt_tokens: List[List[int]],\n    max_new_tokens: int,\n    eos_id: int,\n    temperature: float = 1.0\n) -> List[List[int]]:\n    \"\"\"\n    Generates new tokens based on the given prompt tokens using the specified model.\n\n    Args:\n        model (Transformer): The transformer model used for token generation.\n        prompt_tokens (List[List[int]]): A list of lists containing the prompt tokens for each sequence.\n        max_new_tokens (int): The maximum number of new tokens to generate.\n        eos_id (int): The end-of-sequence token ID.\n        temperature (float, optional): The temperature value for sampling. Defaults to 1.0.\n\n    Returns:\n        List[List[int]]: A list of lists containing the generated tokens for each sequence.\n    \"\"\"\n    prompt_lens = [len(t) for t in prompt_tokens]\n    assert max(prompt_lens) <= model.max_seq_len, f\"Prompt length exceeds model maximum sequence length (max_seq_len={model.max_seq_len})\"\n    total_len = min(model.max_seq_len, max_new_tokens + max(prompt_lens))\n    tokens = torch.full((len(prompt_tokens), total_len), -1, dtype=torch.long, device=\"cuda\")\n    for i, t in enumerate(prompt_tokens):\n        tokens[i, :len(t)] = torch.tensor(t, dtype=torch.long, device=\"cuda\")\n    prev_pos = 0\n    finished = torch.tensor([False] * len(prompt_tokens), device=\"cuda\")\n    prompt_mask = tokens != -1\n    for cur_pos in range(min(prompt_lens), total_len):\n        logits = model.forward(tokens[:, prev_pos:cur_pos], prev_pos)\n        if temperature > 0:\n            next_token = sample(logits, temperature)\n        else:\n            next_token = logits.argmax(dim=-1)\n        next_token = torch.where(prompt_mask[:, cur_pos], tokens[:, cur_pos], next_token)\n        tokens[:, cur_pos] = next_token\n        finished |= torch.logical_and(~prompt_mask[:, cur_pos], next_token == eos_id)\n        prev_pos = cur_pos\n        if finished.all():\n            break\n    completion_tokens = []\n    for i, toks in enumerate(tokens.tolist()):\n        toks = toks[prompt_lens[i]:prompt_lens[i]+max_new_tokens]\n        if eos_id in toks:\n            toks = toks[:toks.index(eos_id)]\n        completion_tokens.append(toks)\n    return completion_tokens\n\n\ndef main(\n    ckpt_path: str,\n    config: str,\n    input_file: str = \"\",\n    interactive: bool = True,\n    max_new_tokens: int = 100,\n    temperature: float = 1.0,\n) -> None:\n    \"\"\"\n    Main function to load the model and perform interactive or batch text generation.\n\n    Args:\n        ckpt_path (str): Path to the model checkpoint directory.\n        config (str): Path to the model configuration file.\n        input_file (str, optional): Path to a file containing input prompts. Defaults to \"\".\n        interactive (bool, optional): Whether to run in interactive mode. Defaults to True.\n        max_new_tokens (int, optional): Maximum number of new tokens to generate. Defaults to 100.\n        temperature (float, optional): Temperature for sampling. Defaults to 1.0.\n    \"\"\"\n    world_size = int(os.getenv(\"WORLD_SIZE\", \"1\"))\n    rank = int(os.getenv(\"RANK\", \"0\"))\n    local_rank = int(os.getenv(\"LOCAL_RANK\", \"0\"))\n    if world_size > 1:\n        dist.init_process_group(\"nccl\")\n    global print\n    if rank != 0:\n        print = lambda *_, **__: None\n    torch.cuda.set_device(local_rank)\n    torch.set_default_dtype(torch.bfloat16)\n    torch.set_num_threads(8)\n    torch.manual_seed(965)\n    with open(config) as f:\n        args = ModelArgs(**json.load(f))\n    print(args)\n    with torch.device(\"cuda\"):\n        model = Transformer(args)\n    tokenizer = AutoTokenizer.from_pretrained(ckpt_path)\n    tokenizer.decode(generate(model, [tokenizer.encode(\"DeepSeek\")], 2, -1, 1.)[0])\n    load_model(model, os.path.join(ckpt_path, f\"model{rank}-mp{world_size}.safetensors\"))\n\n    if interactive:\n        messages = []\n        while True:\n            if world_size == 1:\n                prompt = input(\">>> \")\n            elif rank == 0:\n                prompt = input(\">>> \")\n                objects = [prompt]\n                dist.broadcast_object_list(objects, 0)\n            else:\n                objects = [None]\n                dist.broadcast_object_list(objects, 0)\n                prompt = objects[0]\n            if prompt == \"/exit\":\n                break\n            elif prompt == \"/clear\":\n                messages.clear()\n                continue\n            messages.append({\"role\": \"user\", \"content\": prompt})\n            prompt_tokens = tokenizer.apply_chat_template(messages, add_generation_prompt=True)\n            completion_tokens = generate(model, [prompt_tokens], max_new_tokens, tokenizer.eos_token_id, temperature)\n            completion = tokenizer.decode(completion_tokens[0], skip_special_tokens=True)\n            print(completion)\n            messages.append({\"role\": \"assistant\", \"content\": completion})\n    else:\n        with open(input_file) as f:\n            prompts = [line.strip() for line in f.readlines()]\n        assert len(prompts) <= args.max_batch_size, f\"Number of prompts exceeds maximum batch size ({args.max_batch_size})\"\n        prompt_tokens = [tokenizer.apply_chat_template([{\"role\": \"user\", \"content\": prompt}], add_generation_prompt=True) for prompt in prompts]\n        completion_tokens = generate(model, prompt_tokens, max_new_tokens, tokenizer.eos_token_id, temperature)\n        completions = tokenizer.batch_decode(completion_tokens, skip_special_tokens=True)\n        for prompt, completion in zip(prompts, completions):\n            print(\"Prompt:\", prompt)\n            print(\"Completion:\", completion)\n            print()\n\n    if world_size > 1:\n        dist.destroy_process_group()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    Command-line interface for distributed text generation.\n\n    Arguments:\n        --ckpt-path (str): Path to the model checkpoint directory.\n        --config (str): Path to the model configuration file.\n        --input-file (str, optional): File containing prompts for batch processing.\n        --interactive (bool, optional): Enable interactive mode for generating text.\n        --max-new-tokens (int, optional): Maximum number of new tokens to generate. Defaults to 200.\n        --temperature (float, optional): Temperature for sampling. Defaults to 0.2.\n\n    Raises:\n        AssertionError: If neither input-file nor interactive mode is specified.\n    \"\"\"\n    parser = ArgumentParser()\n    parser.add_argument(\"--ckpt-path\", type=str, required=True)\n    parser.add_argument(\"--config\", type=str, required=True)\n    parser.add_argument(\"--input-file\", type=str, default=\"\")\n    parser.add_argument(\"--interactive\", action=\"store_true\")\n    parser.add_argument(\"--max-new-tokens\", type=int, default=200)\n    parser.add_argument(\"--temperature\", type=float, default=0.2)\n    args = parser.parse_args()\n    assert args.input_file or args.interactive, \"Either input-file or interactive mode must be specified\"\n    main(args.ckpt_path, args.config, args.input_file, args.interactive, args.max_new_tokens, args.temperature)\n",
    "inference/kernel.py": "from typing import Tuple\n\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton import Config\n\n\n@triton.jit\ndef act_quant_kernel(x_ptr, y_ptr, s_ptr, BLOCK_SIZE: tl.constexpr):\n    \"\"\"\n    Quantizes the input tensor `x_ptr` and stores the result in `y_ptr` and the scaling factor in `s_ptr`.\n\n    Args:\n        x_ptr (triton.Pointer): Pointer to the input tensor.\n        y_ptr (triton.Pointer): Pointer to the output tensor where quantized values will be stored.\n        s_ptr (triton.Pointer): Pointer to the output tensor where scaling factors will be stored.\n        BLOCK_SIZE (tl.constexpr): The size of the block to be processed by each program instance.\n\n    Returns:\n        None\n    \"\"\"\n    pid = tl.program_id(axis=0)\n    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    x = tl.load(x_ptr + offs).to(tl.float32)\n    s = tl.max(tl.abs(x)) / 448.\n    y = x / s\n    y = y.to(y_ptr.dtype.element_ty)\n    tl.store(y_ptr + offs, y)\n    tl.store(s_ptr + pid, s)\n\n\ndef act_quant(x: torch.Tensor, block_size: int = 128) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Quantizes the input tensor `x` using block-wise quantization.\n\n    Args:\n        x (torch.Tensor): The input tensor to be quantized. Must be contiguous and its last dimension size must be divisible by `block_size`.\n        block_size (int, optional): The size of the blocks to be used for quantization. Default is 128.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: A tuple containing:\n            - The quantized tensor with dtype `torch.float8_e4m3fn`.\n            - A tensor of scaling factors with dtype `torch.float32`.\n    \"\"\"\n    assert x.is_contiguous(), 'Input tensor must be contiguous'\n    assert x.size(-1) % block_size == 0, f'Last dimension size must be divisible by block_size (block_size={block_size})'\n    y = torch.empty_like(x, dtype=torch.float8_e4m3fn)\n    s = x.new_empty(*x.size()[:-1], x.size(-1) // block_size, dtype=torch.float32)\n    grid = lambda meta: (triton.cdiv(x.numel(), meta['BLOCK_SIZE']), )\n    act_quant_kernel[grid](x, y, s, BLOCK_SIZE=block_size)\n    return y, s\n\n\n@triton.jit\ndef weight_dequant_kernel(x_ptr, s_ptr, y_ptr, M, N, BLOCK_SIZE: tl.constexpr):\n    \"\"\"\n    Dequantizes weights using the provided scaling factors and stores the result.\n\n    Args:\n        x_ptr (tl.pointer): Pointer to the quantized weights.\n        s_ptr (tl.pointer): Pointer to the scaling factors.\n        y_ptr (tl.pointer): Pointer to the output buffer for dequantized weights.\n        M (int): Number of rows in the weight matrix.\n        N (int): Number of columns in the weight matrix.\n        BLOCK_SIZE (tl.constexpr): Size of the block for tiling.\n\n    Returns:\n        None\n    \"\"\"\n    pid_m = tl.program_id(axis=0)\n    pid_n = tl.program_id(axis=1)\n    n = tl.cdiv(N, BLOCK_SIZE)\n    offs_m = pid_m * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    offs_n = pid_n * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    offs = offs_m[:, None] * N + offs_n[None, :]\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    x = tl.load(x_ptr + offs, mask=mask).to(tl.float32)\n    s = tl.load(s_ptr + pid_m * n + pid_n)\n    y = x * s\n    tl.store(y_ptr + offs, y, mask=mask)\n\n\ndef weight_dequant(x: torch.Tensor, s: torch.Tensor, block_size: int = 128) -> torch.Tensor:\n    \"\"\"\n    Dequantizes the given weight tensor using the provided scale tensor.\n\n    Args:\n        x (torch.Tensor): The quantized weight tensor of shape (M, N).\n        s (torch.Tensor): The scale tensor of shape (M, N).\n        block_size (int, optional): The block size to use for dequantization. Defaults to 128.\n\n    Returns:\n        torch.Tensor: The dequantized weight tensor of the same shape as `x`.\n\n    Raises:\n        AssertionError: If `x` or `s` are not contiguous or if their dimensions are not 2.\n    \"\"\"\n    assert x.is_contiguous() and s.is_contiguous(), 'Input tensors must be contiguous'\n    assert x.dim() == 2 and s.dim() == 2, 'Input tensors must have 2 dimensions'\n    M, N = x.size()\n    y = torch.empty_like(x, dtype=torch.get_default_dtype())\n    grid = lambda meta: (triton.cdiv(M, meta['BLOCK_SIZE']), triton.cdiv(N, meta['BLOCK_SIZE']))\n    weight_dequant_kernel[grid](x, s, y, M, N, BLOCK_SIZE=block_size)\n    return y\n\n\nfp8_gemm_configs = [\n    Config({'BLOCK_SIZE_M': block_m, 'BLOCK_SIZE_N': block_n, 'BLOCK_SIZE_K': 128}, num_stages=num_stages, num_warps=8)\n    for block_m in [16, 32, 64] for block_n in [32, 64, 128] for num_stages in [3, 4, 5, 6]\n]\n\n@triton.autotune(configs=fp8_gemm_configs, key=['N', 'K'])\n@triton.jit\ndef fp8_gemm_kernel(a_ptr, b_ptr, c_ptr,\n                    a_s_ptr, b_s_ptr,\n                    M, N: tl.constexpr, K: tl.constexpr,\n                    BLOCK_SIZE_M: tl.constexpr,\n                    BLOCK_SIZE_N: tl.constexpr,\n                    BLOCK_SIZE_K: tl.constexpr):\n    \"\"\"\n    Performs a matrix multiplication operation on FP8 matrices with scaling factors.\n\n    Args:\n        a_ptr (tl.tensor): Pointer to the first input matrix A.\n        b_ptr (tl.tensor): Pointer to the second input matrix B.\n        c_ptr (tl.tensor): Pointer to the output matrix C.\n        a_s_ptr (tl.tensor): Pointer to the scaling factors for matrix A.\n        b_s_ptr (tl.tensor): Pointer to the scaling factors for matrix B.\n        M (int): Number of rows in matrix A and C.\n        N (tl.constexpr): Number of columns in matrix B and C.\n        K (tl.constexpr): Number of columns in matrix A and rows in matrix B.\n        BLOCK_SIZE_M (tl.constexpr): Block size for the M dimension.\n        BLOCK_SIZE_N (tl.constexpr): Block size for the N dimension.\n        BLOCK_SIZE_K (tl.constexpr): Block size for the K dimension.\n\n    Returns:\n        None\n    \"\"\"\n    pid_m = tl.program_id(axis=0)\n    pid_n = tl.program_id(axis=1)\n    k = tl.cdiv(K, BLOCK_SIZE_K)\n    offs_m = (pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)) % M\n    offs_n = (pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)) % N\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + offs_m[:, None] * K + offs_k[None, :]\n    b_ptrs = b_ptr + offs_n[None, :] * K + offs_k[:, None]\n    a_s_ptrs = a_s_ptr + offs_m * k\n    b_s_ptrs = b_s_ptr + (offs_n // BLOCK_SIZE_K) * k\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for i in range(k):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - i * BLOCK_SIZE_K, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - i * BLOCK_SIZE_K, other=0.0)\n        a_s = tl.load(a_s_ptrs)\n        b_s = tl.load(b_s_ptrs)\n        accumulator += tl.dot(a, b) * a_s[:, None] * b_s[None, :]\n        a_ptrs += BLOCK_SIZE_K\n        b_ptrs += BLOCK_SIZE_K\n        a_s_ptrs += 1\n        b_s_ptrs += 1\n    c = accumulator.to(c_ptr.dtype.element_ty)\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + offs_m[:, None] * N + offs_n[None, :]\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, c, mask=mask)\n\n\ndef fp8_gemm(a: torch.Tensor, a_s: torch.Tensor, b: torch.Tensor, b_s: torch.Tensor):\n    \"\"\"\n    Perform a matrix multiplication using FP8 precision.\n\n    Args:\n        a (torch.Tensor): The first input matrix, must be contiguous.\n        a_s (torch.Tensor): The scaling factor for the first input matrix, must be contiguous.\n        b (torch.Tensor): The second input matrix, must be contiguous.\n        b_s (torch.Tensor): The scaling factor for the second input matrix, must be contiguous.\n\n    Returns:\n        torch.Tensor: The result of the matrix multiplication.\n    \"\"\"\n    assert a.is_contiguous() and b.is_contiguous(), 'Input tensors must be contiguous'\n    assert a_s.is_contiguous() and b_s.is_contiguous(), 'Scaling factor tensors must be contiguous'\n    K = a.size(-1)\n    M = a.numel() // K\n    N = b.size(0)\n    c = a.new_empty(*a.size()[:-1], N, dtype=torch.get_default_dtype())\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']), triton.cdiv(N, META['BLOCK_SIZE_N']))\n    fp8_gemm_kernel[grid](a, b, c, a_s, b_s, M, N, K)\n    return c\n",
    "inference/model.py": "import math\nfrom dataclasses import dataclass\nfrom typing import Tuple, Optional, Literal\n\nimport torch\nfrom torch import nn\nimport torch.nn.functional as F\nimport torch.distributed as dist\n\nfrom kernel import act_quant, weight_dequant, fp8_gemm\n\n\nworld_size = 1\nrank = 0\nblock_size = 128\ngemm_impl: Literal[\"bf16\", \"fp8\"] = \"bf16\"\nattn_impl: Literal[\"naive\", \"absorb\"] = \"absorb\"\n\n@dataclass\nclass ModelArgs:\n    \"\"\"\n    Data class for defining model arguments and hyperparameters.\n\n    Attributes:\n        max_batch_size (int): Maximum batch size.\n        max_seq_len (int): Maximum sequence length.\n        dtype (Literal[\"bf16\", \"fp8\"]): Data type for computations.\n        vocab_size (int): Vocabulary size.\n        dim (int): Model dimension.\n        inter_dim (int): Intermediate dimension for MLP layers.\n        moe_inter_dim (int): Intermediate dimension for MoE layers.\n        n_layers (int): Number of transformer layers.\n        n_dense_layers (int): Number of dense layers in the model.\n        n_heads (int): Number of attention heads.\n        n_routed_experts (int): Number of routed experts for MoE layers.\n        n_shared_experts (int): Number of shared experts for MoE layers.\n        n_activated_experts (int): Number of activated experts in MoE layers.\n        n_expert_groups (int): Number of expert groups.\n        n_limited_groups (int): Number of limited groups for MoE routing.\n        score_func (Literal[\"softmax\", \"sigmoid\"]): Scoring function for MoE routing.\n        route_scale (float): Scaling factor for routing scores.\n        q_lora_rank (int): LoRA rank for query projections.\n        kv_lora_rank (int): LoRA rank for key-value projections.\n        qk_nope_head_dim (int): Dimension for query-key projections without positional embeddings.\n        qk_rope_head_dim (int): Dimension for query-key projections with rotary embeddings.\n        v_head_dim (int): Dimension for value projections.\n        original_seq_len (int): Original sequence length.\n        rope_theta (float): Base for rotary positional encoding.\n        rope_factor (float): Scaling factor for extended sequence lengths.\n        beta_fast (int): Fast beta correction factor.\n        beta_slow (int): Slow beta correction factor.\n        mscale (float): Scaling factor for extended attention.\n    \"\"\"\n    max_batch_size: int = 8\n    max_seq_len: int = 4096 * 4\n    dtype: Literal[\"bf16\", \"fp8\"] = \"bf16\"\n    vocab_size: int = 102400\n    dim: int = 2048\n    inter_dim: int = 10944\n    moe_inter_dim: int = 1408\n    n_layers: int = 27\n    n_dense_layers: int = 1\n    n_heads: int = 16\n    # moe\n    n_routed_experts: int = 64\n    n_shared_experts: int = 2\n    n_activated_experts: int = 6\n    n_expert_groups: int = 1\n    n_limited_groups: int = 1\n    score_func: Literal[\"softmax\", \"sigmoid\"] = \"softmax\"\n    route_scale: float = 1.\n    # mla\n    q_lora_rank: int = 0\n    kv_lora_rank: int = 512\n    qk_nope_head_dim: int = 128\n    qk_rope_head_dim: int = 64\n    v_head_dim: int = 128\n    # yarn\n    original_seq_len: int = 4096\n    rope_theta: float = 10000.0\n    rope_factor: float = 40\n    beta_fast: int = 32\n    beta_slow: int = 1\n    mscale: float = 1.\n\n\nclass ParallelEmbedding(nn.Module):\n    \"\"\"\n    Embedding layer with parallelism support across distributed processes.\n\n    Args:\n        vocab_size (int): Vocabulary size.\n        dim (int): Embedding dimension.\n    \"\"\"\n    def __init__(self, vocab_size: int, dim: int):\n        super().__init__()\n        self.vocab_size = vocab_size\n        self.dim = dim\n        assert vocab_size % world_size == 0, f\"Vocabulary size must be divisible by world size (world_size={world_size})\"\n        self.part_vocab_size = (vocab_size // world_size)\n        self.vocab_start_idx = rank * self.part_vocab_size\n        self.vocab_end_idx = self.vocab_start_idx + self.part_vocab_size\n        self.weight = nn.Parameter(torch.empty(self.part_vocab_size, self.dim))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for parallel embedding layer.\n\n        Args:\n            x (torch.Tensor): Input tensor containing token indices.\n\n        Returns:\n            torch.Tensor: Embedded representations.\n\n        Raises:\n            ValueError: If `world_size` is not defined.\n        \"\"\"\n        if world_size > 1:\n            mask = (x < self.vocab_start_idx) | (x >= self.vocab_end_idx)\n            x = x - self.vocab_start_idx\n            x[mask] = 0\n        y = F.embedding(x, self.weight)\n        if world_size > 1:\n            y[mask] = 0\n            dist.all_reduce(y)\n        return y\n\n\ndef linear(x: torch.Tensor, weight: torch.Tensor, bias: Optional[torch.Tensor] = None) -> torch.Tensor:\n    \"\"\"\n    Applies a linear transformation to the incoming data: y = xA^T + b.\n    This function supports specialized implementations based on quantization\n    and tensor formats.\n\n    Args:\n        x (torch.Tensor): The input tensor.\n        weight (torch.Tensor): The weight tensor. It may be quantized and \n            requires dequantization for certain cases.\n        bias (Optional[torch.Tensor]): The bias tensor to be added. Default is None.\n\n    Returns:\n        torch.Tensor: The result of the linear transformation, which may involve \n        quantization-aware computations depending on the input parameters.\n\n    Notes:\n        - If `weight` is quantized (e.g., `element_size() == 1`), a dequantized version \n          is used for computation.\n        - If `gemm_impl == \"bf16\"`, dequantization and a `bf16` GEMM operation are applied.\n        - For other cases, the function applies quantization to `x` and uses `fp8_gemm` for computation.\n    \"\"\"\n    if weight.element_size() > 1:\n        return F.linear(x, weight, bias)\n    elif gemm_impl == \"bf16\":\n        weight = weight_dequant(weight, weight.scale)\n        return F.linear(x, weight, bias)\n    else:\n        x, scale = act_quant(x, block_size)\n        y = fp8_gemm(x, scale, weight, weight.scale)\n        if bias is not None:\n            y += bias\n        return y\n\n\nclass Linear(nn.Module):\n    \"\"\"\n    Custom linear layer with support for quantized weights and optional bias.\n\n    Args:\n        in_features (int): Number of input features.\n        out_features (int): Number of output features.\n        bias (bool): Whether to include a bias term. Defaults to False.\n        dtype (optional): Data type for the layer. Defaults to `torch.bfloat16`.\n    \"\"\"\n    dtype = torch.bfloat16\n\n    def __init__(self, in_features: int, out_features: int, bias: bool = False, dtype = None):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features, dtype=dtype or Linear.dtype))\n        if self.weight.element_size() == 1:\n            scale_out_features = (out_features + block_size - 1) // block_size\n            scale_in_features = (in_features + block_size - 1) // block_size\n            self.weight.scale = self.scale = nn.Parameter(torch.empty(scale_out_features, scale_in_features, dtype=torch.float32))\n        else:\n            self.register_parameter(\"scale\", None)\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_features))\n        else:\n            self.register_parameter(\"bias\", None)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for the custom linear layer.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Transformed tensor after linear computation.\n        \"\"\"\n        return linear(x, self.weight, self.bias)\n\n\nclass ColumnParallelLinear(Linear):\n    \"\"\"\n    Linear layer with column parallelism, splitting output features across distributed processes.\n\n    Args:\n        in_features (int): Number of input features.\n        out_features (int): Total number of output features.\n        bias (bool): Whether to include a bias term. Defaults to False.\n        dtype (optional): Data type for the layer. Defaults to `torch.bfloat16`.\n    \"\"\"\n    def __init__(self, in_features: int, out_features: int, bias: bool = False, dtype = None):\n        assert out_features % world_size == 0, f\"Output features must be divisible by world size (world_size={world_size})\"\n        self.part_out_features = out_features // world_size\n        super().__init__(in_features, self.part_out_features, bias, dtype)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for column parallel linear layer.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Transformed tensor with column-parallel computation.\n        \"\"\"\n        y = linear(x, self.weight, self.bias)\n        return y\n\n\nclass RowParallelLinear(Linear):\n    \"\"\"\n    Linear layer with row parallelism, splitting input features across distributed processes.\n\n    Args:\n        in_features (int): Total number of input features.\n        out_features (int): Number of output features.\n        bias (bool): Whether to include a bias term. Defaults to False.\n        dtype (optional): Data type for the layer. Defaults to `torch.bfloat16`.\n    \"\"\"\n    def __init__(self, in_features: int, out_features: int, bias: bool = False, dtype = None):\n        assert in_features % world_size == 0, f\"Input features must be divisible by world size (world_size={world_size})\"\n        self.part_in_features = in_features // world_size\n        super().__init__(self.part_in_features, out_features, bias, dtype)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for row parallel linear layer.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Transformed tensor with row-parallel computation.\n        \"\"\"\n        y = linear(x, self.weight)\n        if world_size > 1:\n            dist.all_reduce(y)\n        if self.bias is not None:\n            y += self.bias\n        return y\n\n\nclass RMSNorm(nn.Module):\n    \"\"\"\n    Root Mean Square Layer Normalization (RMSNorm).\n\n    Args:\n        dim (int): Dimension of the input tensor.\n        eps (float): Epsilon value for numerical stability. Defaults to 1e-6.\n    \"\"\"\n    def __init__(self, dim: int, eps: float = 1e-6):\n        super().__init__()\n        self.dim = dim\n        self.eps = eps\n        self.weight = nn.Parameter(torch.ones(dim))\n\n    def forward(self, x: torch.Tensor):\n        \"\"\"\n        Forward pass for RMSNorm.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Normalized tensor with the same shape as input.\n        \"\"\"\n        return F.rms_norm(x, (self.dim,), self.weight, self.eps)\n\n\ndef precompute_freqs_cis(args: ModelArgs) -> torch.Tensor:\n    \"\"\"\n    Precomputes frequency-based complex exponential values for rotary positional embeddings.\n\n    Args:\n        args (ModelArgs): Model arguments containing positional embedding parameters.\n\n    Returns:\n        torch.Tensor: Precomputed complex exponential values for positional embeddings.\n    \"\"\"\n    dim = args.qk_rope_head_dim\n    seqlen = args.max_seq_len\n    beta_fast = args.beta_fast\n    beta_slow = args.beta_slow\n    base = args.rope_theta\n    factor = args.rope_factor\n\n    def find_correction_dim(num_rotations, dim, base, max_seq_len):\n        \"\"\"\n        Computes the correction dimension for a given number of rotations in the rotary positional embedding.\n\n        Args:\n            num_rotations (float): Number of rotations to compute the correction for.\n            dim (int): Dimensionality of the embedding space.\n            base (float): Base value for the exponential computation.\n            max_seq_len (int): Maximum sequence length.\n\n        Returns:\n            float: The correction dimension based on the input parameters.\n        \"\"\"\n        return dim * math.log(max_seq_len / (num_rotations * 2 * math.pi)) / (2 * math.log(base))\n\n    def find_correction_range(low_rot, high_rot, dim, base, max_seq_len):\n        \"\"\"\n        Computes the range of correction dimensions for rotary positional embeddings.\n\n        Args:\n            low_rot (float): Lower bound for the number of rotations.\n            high_rot (float): Upper bound for the number of rotations.\n            dim (int): Dimensionality of the embedding space.\n            base (float): Base value for the exponential computation.\n            max_seq_len (int): Maximum sequence length.\n\n        Returns:\n            Tuple[int, int]: The range of correction dimensions (low, high), clamped to valid indices.\n        \"\"\"\n        low = math.floor(find_correction_dim(low_rot, dim, base, max_seq_len))\n        high = math.ceil(find_correction_dim(high_rot, dim, base, max_seq_len))\n        return max(low, 0), min(high, dim-1)\n\n    def linear_ramp_factor(min, max, dim):\n        \"\"\"\n        Computes a linear ramp function used to smooth values between a minimum and maximum range.\n\n        Args:\n            min (float): Minimum value for the ramp function.\n            max (float): Maximum value for the ramp function.\n            dim (int): Dimensionality of the ramp tensor.\n\n        Returns:\n            torch.Tensor: A tensor of shape (dim,) with values linearly interpolated between 0 and 1,\n                clamped to the range [0, 1].\n        \"\"\"\n        if min == max:\n            max += 0.001\n        linear_func = (torch.arange(dim, dtype=torch.float32) - min) / (max - min)\n        ramp_func = torch.clamp(linear_func, 0, 1)\n        return ramp_func\n\n    freqs = 1.0 / (base ** (torch.arange(0, dim, 2, dtype=torch.float32) / dim))\n    if seqlen > args.original_seq_len:\n        low, high = find_correction_range(beta_fast, beta_slow, dim, base, args.original_seq_len)\n        smooth = 1 - linear_ramp_factor(low, high, dim // 2)\n        freqs = freqs / factor * (1 - smooth) + freqs * smooth\n\n    t = torch.arange(seqlen)\n    freqs = torch.outer(t, freqs)\n    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)\n    return freqs_cis\n\n\ndef apply_rotary_emb(x: torch.Tensor, freqs_cis: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Applies rotary positional embeddings to the input tensor.\n\n    Args:\n        x (torch.Tensor): Input tensor with positional embeddings to be applied.\n        freqs_cis (torch.Tensor): Precomputed complex exponential values for positional embeddings.\n\n    Returns:\n        torch.Tensor: Tensor with rotary embeddings applied.\n    \"\"\"\n    dtype = x.dtype\n    x = torch.view_as_complex(x.float().view(*x.shape[:-1], -1, 2))\n    freqs_cis = freqs_cis.view(1, x.size(1), 1, x.size(-1))\n    y = torch.view_as_real(x * freqs_cis).flatten(3)\n    return y.to(dtype)\n\n\nclass MLA(nn.Module):\n    \"\"\"\n    Multi-Headed Attention Layer (MLA).\n\n    Attributes:\n        dim (int): Dimensionality of the input features.\n        n_heads (int): Number of attention heads.\n        n_local_heads (int): Number of local attention heads for distributed systems.\n        q_lora_rank (int): Rank for low-rank query projection.\n        kv_lora_rank (int): Rank for low-rank key/value projection.\n        qk_nope_head_dim (int): Dimensionality of non-positional query/key projections.\n        qk_rope_head_dim (int): Dimensionality of rotary-positional query/key projections.\n        qk_head_dim (int): Total dimensionality of query/key projections.\n        v_head_dim (int): Dimensionality of value projections.\n        softmax_scale (float): Scaling factor for softmax in attention computation.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        super().__init__()\n        self.dim = args.dim\n        self.n_heads = args.n_heads\n        self.n_local_heads = args.n_heads // world_size\n        self.q_lora_rank = args.q_lora_rank\n        self.kv_lora_rank = args.kv_lora_rank\n        self.qk_nope_head_dim = args.qk_nope_head_dim\n        self.qk_rope_head_dim = args.qk_rope_head_dim\n        self.qk_head_dim = args.qk_nope_head_dim + args.qk_rope_head_dim\n        self.v_head_dim = args.v_head_dim\n\n        if self.q_lora_rank == 0:\n            self.wq = ColumnParallelLinear(self.dim, self.n_heads * self.qk_head_dim)\n        else:\n            self.wq_a = Linear(self.dim, self.q_lora_rank)\n            self.q_norm = RMSNorm(self.q_lora_rank)\n            self.wq_b = ColumnParallelLinear(self.q_lora_rank, self.n_heads * self.qk_head_dim)\n        self.wkv_a = Linear(self.dim, self.kv_lora_rank + self.qk_rope_head_dim)\n        self.kv_norm = RMSNorm(self.kv_lora_rank)\n        self.wkv_b = ColumnParallelLinear(self.kv_lora_rank, self.n_heads * (self.qk_nope_head_dim + self.v_head_dim))\n        self.wo = RowParallelLinear(self.n_heads * self.v_head_dim, self.dim)\n        self.softmax_scale = self.qk_head_dim ** -0.5\n        if args.max_seq_len > args.original_seq_len:\n            mscale = 0.1 * args.mscale * math.log(args.rope_factor) + 1.0\n            self.softmax_scale = self.softmax_scale * mscale * mscale\n\n        if attn_impl == \"naive\":\n            self.register_buffer(\"k_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.n_local_heads, self.qk_head_dim), persistent=False)\n            self.register_buffer(\"v_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.n_local_heads, self.v_head_dim), persistent=False)\n        else:\n            self.register_buffer(\"kv_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.kv_lora_rank), persistent=False)\n            self.register_buffer(\"pe_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.qk_rope_head_dim), persistent=False)\n\n    def forward(self, x: torch.Tensor, start_pos: int, freqs_cis: torch.Tensor, mask: Optional[torch.Tensor]):\n        \"\"\"\n        Forward pass for the Multi-Headed Attention Layer (MLA).\n\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, seq_len, dim).\n            start_pos (int): Starting position in the sequence for caching.\n            freqs_cis (torch.Tensor): Precomputed complex exponential values for rotary embeddings.\n            mask (Optional[torch.Tensor]): Mask tensor to exclude certain positions from attention.\n\n        Returns:\n            torch.Tensor: Output tensor with the same shape as the input.\n        \"\"\"\n        bsz, seqlen, _ = x.size()\n        end_pos = start_pos + seqlen\n        if self.q_lora_rank == 0:\n            q = self.wq(x)\n        else:\n            q = self.wq_b(self.q_norm(self.wq_a(x)))\n        q = q.view(bsz, seqlen, self.n_local_heads, self.qk_head_dim)\n        q_nope, q_pe = torch.split(q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1)\n        q_pe = apply_rotary_emb(q_pe, freqs_cis)\n        kv = self.wkv_a(x)\n        kv, k_pe = torch.split(kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1)\n        k_pe = apply_rotary_emb(k_pe.unsqueeze(2), freqs_cis)\n        if attn_impl == \"naive\":\n            q = torch.cat([q_nope, q_pe], dim=-1)\n            kv = self.wkv_b(self.kv_norm(kv))\n            kv = kv.view(bsz, seqlen, self.n_local_heads, self.qk_nope_head_dim + self.v_head_dim)\n            k_nope, v = torch.split(kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1)\n            k = torch.cat([k_nope, k_pe.expand(-1, -1, self.n_local_heads, -1)], dim=-1)\n            self.k_cache[:bsz, start_pos:end_pos] = k\n            self.v_cache[:bsz, start_pos:end_pos] = v\n            scores = torch.einsum(\"bshd,bthd->bsht\", q, self.k_cache[:bsz, :end_pos]) * self.softmax_scale\n        else:\n            wkv_b = self.wkv_b.weight if self.wkv_b.scale is None else weight_dequant(self.wkv_b.weight, self.wkv_b.scale, block_size) \n            wkv_b = wkv_b.view(self.n_local_heads, -1, self.kv_lora_rank)\n            q_nope = torch.einsum(\"bshd,hdc->bshc\", q_nope, wkv_b[:, :self.qk_nope_head_dim])\n            self.kv_cache[:bsz, start_pos:end_pos] = self.kv_norm(kv)\n            self.pe_cache[:bsz, start_pos:end_pos] = k_pe.squeeze(2)\n            scores = (torch.einsum(\"bshc,btc->bsht\", q_nope, self.kv_cache[:bsz, :end_pos]) +\n                      torch.einsum(\"bshr,btr->bsht\", q_pe, self.pe_cache[:bsz, :end_pos])) * self.softmax_scale\n        if mask is not None:\n            scores += mask.unsqueeze(1)\n        scores = scores.softmax(dim=-1, dtype=torch.float32).type_as(x)\n        if attn_impl == \"naive\":\n            x = torch.einsum(\"bsht,bthd->bshd\", scores, self.v_cache[:bsz, :end_pos])\n        else:\n            x = torch.einsum(\"bsht,btc->bshc\", scores, self.kv_cache[:bsz, :end_pos])\n            x = torch.einsum(\"bshc,hdc->bshd\", x, wkv_b[:, -self.v_head_dim:])\n        x = self.wo(x.flatten(2))\n        return x\n\n\nclass MLP(nn.Module):\n    \"\"\"\n    Multi-Layer Perceptron (MLP) used as a feed-forward layer.\n\n    Attributes:\n        w1 (nn.Module): Linear layer for input-to-hidden transformation.\n        w2 (nn.Module): Linear layer for hidden-to-output transformation.\n        w3 (nn.Module): Additional linear layer for feature transformation.\n    \"\"\"\n    def __init__(self, dim: int, inter_dim: int):\n        \"\"\"\n        Initializes the MLP layer.\n\n        Args:\n            dim (int): Input and output dimensionality.\n            inter_dim (int): Hidden layer dimensionality.\n        \"\"\"\n        super().__init__()\n        self.w1 = ColumnParallelLinear(dim, inter_dim)\n        self.w2 = RowParallelLinear(inter_dim, dim)\n        self.w3 = ColumnParallelLinear(dim, inter_dim)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for the MLP layer.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Output tensor after MLP computation.\n        \"\"\"\n        return self.w2(F.silu(self.w1(x)) * self.w3(x))\n\n\nclass Gate(nn.Module):\n    \"\"\"\n    Gating mechanism for routing inputs in a mixture-of-experts (MoE) model.\n\n    Attributes:\n        dim (int): Dimensionality of input features.\n        topk (int): Number of top experts activated for each input.\n        n_groups (int): Number of groups for routing.\n        topk_groups (int): Number of groups to route inputs to.\n        score_func (str): Scoring function ('softmax' or 'sigmoid').\n        route_scale (float): Scaling factor for routing weights.\n        weight (torch.nn.Parameter): Learnable weights for the gate.\n        bias (Optional[torch.nn.Parameter]): Optional bias term for the gate.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        \"\"\"\n        Initializes the Gate module.\n\n        Args:\n            args (ModelArgs): Model arguments containing gating parameters.\n        \"\"\"\n        super().__init__()\n        self.dim = args.dim\n        self.topk = args.n_activated_experts\n        self.n_groups = args.n_expert_groups\n        self.topk_groups = args.n_limited_groups\n        self.score_func = args.score_func\n        self.route_scale = args.route_scale\n        self.weight = nn.Parameter(torch.empty(args.n_routed_experts, args.dim))\n        self.bias = nn.Parameter(torch.empty(args.n_routed_experts)) if self.dim == 7168 else None\n\n    def forward(self, x: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Forward pass for the gating mechanism.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            Tuple[torch.Tensor, torch.Tensor]: Routing weights and selected expert indices.\n        \"\"\"\n        scores = linear(x, self.weight)\n        if self.score_func == \"softmax\":\n            scores = scores.softmax(dim=-1, dtype=torch.float32)\n        else:\n            scores = scores.sigmoid()\n        original_scores = scores\n        if self.bias is not None:\n            scores = scores + self.bias\n        if self.n_groups > 1:\n            scores = scores.view(x.size(0), self.n_groups, -1)\n            if self.bias is None:\n                group_scores = scores.amax(dim=-1)\n            else:\n                group_scores = scores.topk(2, dim=-1)[0].sum(dim=-1)\n            indices = group_scores.topk(self.topk_groups, dim=-1)[1]\n            mask = scores.new_ones(x.size(0), self.n_groups, dtype=bool).scatter_(1, indices, False)\n            scores = scores.masked_fill_(mask.unsqueeze(-1), float(\"-inf\")).flatten(1)\n        indices = torch.topk(scores, self.topk, dim=-1)[1]\n        weights = original_scores.gather(1, indices)\n        if self.score_func == \"sigmoid\":\n            weights /= weights.sum(dim=-1, keepdim=True)\n        weights *= self.route_scale\n        return weights.type_as(x), indices\n\n\nclass Expert(nn.Module):\n    \"\"\"\n    Expert layer for Mixture-of-Experts (MoE) models.\n\n    Attributes:\n        w1 (nn.Module): Linear layer for input-to-hidden transformation.\n        w2 (nn.Module): Linear layer for hidden-to-output transformation.\n        w3 (nn.Module): Additional linear layer for feature transformation.\n    \"\"\"\n    def __init__(self, dim: int, inter_dim: int):\n        \"\"\"\n        Initializes the Expert layer.\n\n        Args:\n            dim (int): Input and output dimensionality.\n            inter_dim (int): Hidden layer dimensionality.\n        \"\"\"\n        super().__init__()\n        self.w1 = Linear(dim, inter_dim)\n        self.w2 = Linear(inter_dim, dim)\n        self.w3 = Linear(dim, inter_dim)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for the Expert layer.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Output tensor after expert computation.\n        \"\"\"\n        return self.w2(F.silu(self.w1(x)) * self.w3(x))\n\n\nclass MoE(nn.Module):\n    \"\"\"\n    Mixture-of-Experts (MoE) module.\n\n    Attributes:\n        dim (int): Dimensionality of input features.\n        n_routed_experts (int): Total number of experts in the model.\n        n_local_experts (int): Number of experts handled locally in distributed systems.\n        n_activated_experts (int): Number of experts activated for each input.\n        gate (nn.Module): Gating mechanism to route inputs to experts.\n        experts (nn.ModuleList): List of expert modules.\n        shared_experts (nn.Module): Shared experts applied to all inputs.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        \"\"\"\n        Initializes the MoE module.\n\n        Args:\n            args (ModelArgs): Model arguments containing MoE parameters.\n        \"\"\"\n        super().__init__()\n        self.dim = args.dim\n        assert args.n_routed_experts % world_size == 0, f\"Number of experts must be divisible by world size (world_size={world_size})\"\n        self.n_routed_experts = args.n_routed_experts\n        self.n_local_experts = args.n_routed_experts // world_size\n        self.n_activated_experts = args.n_activated_experts\n        self.experts_start_idx = rank * self.n_local_experts\n        self.experts_end_idx = self.experts_start_idx + self.n_local_experts\n        self.gate = Gate(args)\n        self.experts = nn.ModuleList([Expert(args.dim, args.moe_inter_dim) if self.experts_start_idx <= i < self.experts_end_idx else None\n                                      for i in range(self.n_routed_experts)])\n        self.shared_experts = MLP(args.dim, args.n_shared_experts * args.moe_inter_dim)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Forward pass for the MoE module.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            torch.Tensor: Output tensor after expert routing and computation.\n        \"\"\"\n        shape = x.size()\n        x = x.view(-1, self.dim)\n        weights, indices = self.gate(x)\n        y = torch.zeros_like(x)\n        counts = torch.bincount(indices.flatten(), minlength=self.n_routed_experts).tolist()\n        for i in range(self.experts_start_idx, self.experts_end_idx):\n            if counts[i] == 0:\n                continue\n            expert = self.experts[i]\n            idx, top = torch.where(indices == i)\n            y[idx] += expert(x[idx]) * weights[idx, top, None]\n        z = self.shared_experts(x)\n        if world_size > 1:\n            dist.all_reduce(y)\n        return (y + z).view(shape)\n\n\nclass Block(nn.Module):\n    \"\"\"\n    Transformer block combining attention and feed-forward layers.\n\n    Attributes:\n        attn (nn.Module): Attention layer (MLA).\n        ffn (nn.Module): Feed-forward network (MLP or MoE).\n        attn_norm (nn.Module): Layer normalization for attention.\n        ffn_norm (nn.Module): Layer normalization for feed-forward network.\n    \"\"\"\n    def __init__(self, layer_id: int, args: ModelArgs):\n        \"\"\"\n        Initializes the Transformer block.\n\n        Args:\n            layer_id (int): Layer index in the transformer.\n            args (ModelArgs): Model arguments containing block parameters.\n        \"\"\"\n        super().__init__()\n        self.attn = MLA(args)\n        self.ffn = MLP(args.dim, args.inter_dim) if layer_id < args.n_dense_layers else MoE(args)\n        self.attn_norm = RMSNorm(args.dim)\n        self.ffn_norm = RMSNorm(args.dim)\n\n    def forward(self, x: torch.Tensor, start_pos: int, freqs_cis: torch.Tensor, mask: Optional[torch.Tensor]) -> torch.Tensor:\n        \"\"\"\n        Forward pass for the Transformer block.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n            start_pos (int): Starting position in the sequence.\n            freqs_cis (torch.Tensor): Precomputed complex exponential values for rotary embeddings.\n            mask (Optional[torch.Tensor]): Mask tensor to exclude certain positions from attention.\n\n        Returns:\n            torch.Tensor: Output tensor after block computation.\n        \"\"\"\n        x = x + self.attn(self.attn_norm(x), start_pos, freqs_cis, mask)\n        x = x + self.ffn(self.ffn_norm(x))\n        return x\n\n\nclass Transformer(nn.Module):\n    \"\"\"\n    Transformer model with positional embeddings, multiple layers, and output projection.\n\n    Attributes:\n        max_seq_len (int): Maximum sequence length for the transformer.\n        embed (nn.Module): Embedding layer for input tokens.\n        layers (torch.nn.ModuleList): List of transformer blocks.\n        norm (nn.Module): Layer normalization applied after all blocks.\n        head (nn.Module): Output projection layer mapping to vocabulary size.\n        freqs_cis (torch.Tensor): Precomputed complex exponential values for rotary embeddings.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        \"\"\"\n        Initializes the Transformer model.\n\n        Args:\n            args (ModelArgs): Model arguments containing transformer parameters.\n        \"\"\"\n        global world_size, rank\n        world_size = dist.get_world_size() if dist.is_initialized() else 1\n        rank = dist.get_rank() if dist.is_initialized() else 0\n        Linear.dtype = torch.float8_e4m3fn if args.dtype == \"fp8\" else torch.bfloat16\n        super().__init__()\n        self.max_seq_len = args.max_seq_len\n        self.embed = ParallelEmbedding(args.vocab_size, args.dim)\n        self.layers = torch.nn.ModuleList()\n        for layer_id in range(args.n_layers):\n            self.layers.append(Block(layer_id, args))\n        self.norm = RMSNorm(args.dim)\n        self.head = ColumnParallelLinear(args.dim, args.vocab_size, dtype=torch.get_default_dtype())\n        self.register_buffer(\"freqs_cis\", precompute_freqs_cis(args), persistent=False)\n\n    @torch.inference_mode()\n    def forward(self, tokens: torch.Tensor, start_pos: int = 0):\n        \"\"\"\n        Forward pass for the Transformer model.\n\n        Args:\n            tokens (torch.Tensor): Input tensor of token IDs with shape (batch_size, seq_len).\n            start_pos (int, optional): Starting position in the sequence for rotary embeddings. Defaults to 0.\n\n        Returns:\n            torch.Tensor: Logits tensor of shape (batch_size, vocab_size).\n        \"\"\"\n        seqlen = tokens.size(1)\n        h = self.embed(tokens)\n        freqs_cis = self.freqs_cis[start_pos:start_pos+seqlen]\n        mask = None\n        if seqlen > 1:\n            mask = torch.full((seqlen, seqlen), float(\"-inf\"), device=tokens.device).triu_(1)\n        for layer in self.layers:\n            h = layer(h, start_pos, freqs_cis, mask)\n        h = self.norm(h)[:, -1]\n        logits = self.head(h)\n        if world_size > 1:\n            all_logits = [torch.empty_like(logits) for _ in range(world_size)]\n            dist.all_gather(all_logits, logits)\n            logits = torch.cat(all_logits, dim=-1)\n        return logits\n\n\nif __name__ == \"__main__\":\n    torch.set_default_dtype(torch.bfloat16)\n    torch.set_default_device(\"cuda\")\n    torch.manual_seed(0)\n    args = ModelArgs()\n    x = torch.randint(0, args.vocab_size, (2, 128))\n    model = Transformer(args)\n    print(model(x).size())\n"
  },
  "requirements": null
}