{
  "repo_name": "django/django",
  "repo_url": "https://github.com/django/django",
  "description": "The Web framework for perfectionists with deadlines.",
  "stars": 82767,
  "language": "Python",
  "created_at": "2012-04-28T02:47:18Z",
  "updated_at": "2025-03-19T06:17:03Z",
  "files": {
    "django/contrib/admin/tests.py": "from contextlib import contextmanager\n\nfrom django.contrib.staticfiles.testing import StaticLiveServerTestCase\nfrom django.test import modify_settings\nfrom django.test.selenium import SeleniumTestCase\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.translation import gettext as _\n\n# Make unittest ignore frames in this module when reporting failures.\n__unittest = True\n\n\nclass CSPMiddleware(MiddlewareMixin):\n    \"\"\"The admin's JavaScript should be compatible with CSP.\"\"\"\n\n    def process_response(self, request, response):\n        response.headers[\"Content-Security-Policy\"] = \"default-src 'self'\"\n        return response\n\n\n@modify_settings(MIDDLEWARE={\"append\": \"django.contrib.admin.tests.CSPMiddleware\"})\nclass AdminSeleniumTestCase(SeleniumTestCase, StaticLiveServerTestCase):\n    available_apps = [\n        \"django.contrib.admin\",\n        \"django.contrib.auth\",\n        \"django.contrib.contenttypes\",\n        \"django.contrib.sessions\",\n        \"django.contrib.sites\",\n    ]\n\n    def wait_until(self, callback, timeout=10):\n        \"\"\"\n        Block the execution of the tests until the specified callback returns a\n        value that is not falsy. This method can be called, for example, after\n        clicking a link or submitting a form. See the other public methods that\n        call this function for more details.\n        \"\"\"\n        from selenium.webdriver.support.wait import WebDriverWait\n\n        WebDriverWait(self.selenium, timeout).until(callback)\n\n    def wait_for_and_switch_to_popup(self, num_windows=2, timeout=10):\n        \"\"\"\n        Block until `num_windows` are present and are ready (usually 2, but can\n        be overridden in the case of pop-ups opening other pop-ups). Switch the\n        current window to the new pop-up.\n        \"\"\"\n        self.wait_until(lambda d: len(d.window_handles) == num_windows, timeout)\n        self.selenium.switch_to.window(self.selenium.window_handles[-1])\n        self.wait_page_ready()\n\n    def wait_for(self, css_selector, timeout=10):\n        \"\"\"\n        Block until a CSS selector is found on the page.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        self.wait_until(\n            ec.presence_of_element_located((By.CSS_SELECTOR, css_selector)), timeout\n        )\n\n    def wait_for_text(self, css_selector, text, timeout=10):\n        \"\"\"\n        Block until the text is found in the CSS selector.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        self.wait_until(\n            ec.text_to_be_present_in_element((By.CSS_SELECTOR, css_selector), text),\n            timeout,\n        )\n\n    def wait_for_value(self, css_selector, text, timeout=10):\n        \"\"\"\n        Block until the value is found in the CSS selector.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        self.wait_until(\n            ec.text_to_be_present_in_element_value(\n                (By.CSS_SELECTOR, css_selector), text\n            ),\n            timeout,\n        )\n\n    def wait_until_visible(self, css_selector, timeout=10):\n        \"\"\"\n        Block until the element described by the CSS selector is visible.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        self.wait_until(\n            ec.visibility_of_element_located((By.CSS_SELECTOR, css_selector)), timeout\n        )\n\n    def wait_until_invisible(self, css_selector, timeout=10):\n        \"\"\"\n        Block until the element described by the CSS selector is invisible.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        self.wait_until(\n            ec.invisibility_of_element_located((By.CSS_SELECTOR, css_selector)), timeout\n        )\n\n    def wait_page_ready(self, timeout=10):\n        \"\"\"\n        Block until the  page is ready.\n        \"\"\"\n        self.wait_until(\n            lambda driver: driver.execute_script(\"return document.readyState;\")\n            == \"complete\",\n            timeout,\n        )\n\n    @contextmanager\n    def wait_page_loaded(self, timeout=10):\n        \"\"\"\n        Block until a new page has loaded and is ready.\n        \"\"\"\n        from selenium.common.exceptions import WebDriverException\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support import expected_conditions as ec\n\n        old_page = self.selenium.find_element(By.TAG_NAME, \"html\")\n        yield\n        # Wait for the next page to be loaded\n        try:\n            self.wait_until(ec.staleness_of(old_page), timeout=timeout)\n        except WebDriverException:\n            # Issue in version 113+ of Chrome driver where a WebDriverException\n            # error is raised rather than a StaleElementReferenceException, see:\n            # https://issues.chromium.org/issues/42323468\n            pass\n\n        self.wait_page_ready(timeout=timeout)\n\n    def admin_login(self, username, password, login_url=\"/admin/\"):\n        \"\"\"\n        Log in to the admin.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n\n        self.selenium.get(\"%s%s\" % (self.live_server_url, login_url))\n        username_input = self.selenium.find_element(By.NAME, \"username\")\n        username_input.send_keys(username)\n        password_input = self.selenium.find_element(By.NAME, \"password\")\n        password_input.send_keys(password)\n        login_text = _(\"Log in\")\n        with self.wait_page_loaded():\n            self.selenium.find_element(\n                By.XPATH, '//input[@value=\"%s\"]' % login_text\n            ).click()\n\n    def select_option(self, selector, value):\n        \"\"\"\n        Select the <OPTION> with the value `value` inside the <SELECT> widget\n        identified by the CSS selector `selector`.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support.ui import Select\n\n        select = Select(self.selenium.find_element(By.CSS_SELECTOR, selector))\n        select.select_by_value(value)\n\n    def deselect_option(self, selector, value):\n        \"\"\"\n        Deselect the <OPTION> with the value `value` inside the <SELECT> widget\n        identified by the CSS selector `selector`.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n        from selenium.webdriver.support.ui import Select\n\n        select = Select(self.selenium.find_element(By.CSS_SELECTOR, selector))\n        select.deselect_by_value(value)\n\n    def assertCountSeleniumElements(self, selector, count, root_element=None):\n        \"\"\"\n        Assert number of matches for a CSS selector.\n\n        `root_element` allow restriction to a pre-selected node.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n\n        root_element = root_element or self.selenium\n        self.assertEqual(\n            len(root_element.find_elements(By.CSS_SELECTOR, selector)), count\n        )\n\n    def _assertOptionsValues(self, options_selector, values):\n        from selenium.webdriver.common.by import By\n\n        if values:\n            options = self.selenium.find_elements(By.CSS_SELECTOR, options_selector)\n            actual_values = []\n            for option in options:\n                actual_values.append(option.get_attribute(\"value\"))\n            self.assertEqual(values, actual_values)\n        else:\n            # Prevent the `find_elements(By.CSS_SELECTOR, â€¦)` call from blocking\n            # if the selector doesn't match any options as we expect it\n            # to be the case.\n            with self.disable_implicit_wait():\n                self.wait_until(\n                    lambda driver: not driver.find_elements(\n                        By.CSS_SELECTOR, options_selector\n                    )\n                )\n\n    def assertSelectOptions(self, selector, values):\n        \"\"\"\n        Assert that the <SELECT> widget identified by `selector` has the\n        options with the given `values`.\n        \"\"\"\n        self._assertOptionsValues(\"%s > option\" % selector, values)\n\n    def assertSelectedOptions(self, selector, values):\n        \"\"\"\n        Assert that the <SELECT> widget identified by `selector` has the\n        selected options with the given `values`.\n        \"\"\"\n        self._assertOptionsValues(\"%s > option:checked\" % selector, values)\n\n    def is_disabled(self, selector):\n        \"\"\"\n        Return True if the element identified by `selector` has the `disabled`\n        attribute.\n        \"\"\"\n        from selenium.webdriver.common.by import By\n\n        return (\n            self.selenium.find_element(By.CSS_SELECTOR, selector).get_attribute(\n                \"disabled\"\n            )\n            == \"true\"\n        )\n",
    "django/contrib/messages/test.py": "from .api import get_messages\n\n# Make unittest ignore frames in this module when reporting failures.\n__unittest = True\n\n\nclass MessagesTestMixin:\n    def assertMessages(self, response, expected_messages, *, ordered=True):\n        request_messages = list(get_messages(response.wsgi_request))\n        assertion = self.assertEqual if ordered else self.assertCountEqual\n        assertion(request_messages, expected_messages)\n",
    "django/contrib/staticfiles/testing.py": "from django.contrib.staticfiles.handlers import StaticFilesHandler\nfrom django.test import LiveServerTestCase\n\n\nclass StaticLiveServerTestCase(LiveServerTestCase):\n    \"\"\"\n    Extend django.test.LiveServerTestCase to transparently overlay at test\n    execution-time the assets provided by the staticfiles app finders. This\n    means you don't need to run collectstatic before or as a part of your tests\n    setup.\n    \"\"\"\n\n    static_handler = StaticFilesHandler\n",
    "django/core/management/commands/sendtestemail.py": "import socket\n\nfrom django.core.mail import mail_admins, mail_managers, send_mail\nfrom django.core.management.base import BaseCommand\nfrom django.utils import timezone\n\n\nclass Command(BaseCommand):\n    help = \"Sends a test email to the email addresses specified as arguments.\"\n    missing_args_message = (\n        \"You must specify some email recipients, or pass the --managers or --admin \"\n        \"options.\"\n    )\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"email\",\n            nargs=\"*\",\n            help=\"One or more email addresses to send a test email to.\",\n        )\n        parser.add_argument(\n            \"--managers\",\n            action=\"store_true\",\n            help=\"Send a test email to the addresses specified in settings.MANAGERS.\",\n        )\n        parser.add_argument(\n            \"--admins\",\n            action=\"store_true\",\n            help=\"Send a test email to the addresses specified in settings.ADMINS.\",\n        )\n\n    def handle(self, *args, **kwargs):\n        subject = \"Test email from %s on %s\" % (socket.gethostname(), timezone.now())\n\n        send_mail(\n            subject=subject,\n            message=\"If you're reading this, it was successful.\",\n            from_email=None,\n            recipient_list=kwargs[\"email\"],\n        )\n\n        if kwargs[\"managers\"]:\n            mail_managers(subject, \"This email was sent to the site managers.\")\n\n        if kwargs[\"admins\"]:\n            mail_admins(subject, \"This email was sent to the site admins.\")\n",
    "django/core/management/commands/test.py": "import sys\n\nfrom django.conf import settings\nfrom django.core.management.base import BaseCommand\nfrom django.core.management.utils import get_command_line_option\nfrom django.test.runner import get_max_test_processes\nfrom django.test.utils import NullTimeKeeper, TimeKeeper, get_runner\n\n\nclass Command(BaseCommand):\n    help = \"Discover and run tests in the specified modules or the current directory.\"\n\n    # DiscoverRunner runs the checks after databases are set up.\n    requires_system_checks = []\n    test_runner = None\n\n    def run_from_argv(self, argv):\n        \"\"\"\n        Pre-parse the command line to extract the value of the --testrunner\n        option. This allows a test runner to define additional command line\n        arguments.\n        \"\"\"\n        self.test_runner = get_command_line_option(argv, \"--testrunner\")\n        super().run_from_argv(argv)\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"args\",\n            metavar=\"test_label\",\n            nargs=\"*\",\n            help=(\n                \"Module paths to test; can be modulename, modulename.TestCase or \"\n                \"modulename.TestCase.test_method\"\n            ),\n        )\n        parser.add_argument(\n            \"--noinput\",\n            \"--no-input\",\n            action=\"store_false\",\n            dest=\"interactive\",\n            help=\"Tells Django to NOT prompt the user for input of any kind.\",\n        )\n        parser.add_argument(\n            \"--testrunner\",\n            help=\"Tells Django to use specified test runner class instead of \"\n            \"the one specified by the TEST_RUNNER setting.\",\n        )\n\n        test_runner_class = get_runner(settings, self.test_runner)\n\n        if hasattr(test_runner_class, \"add_arguments\"):\n            test_runner_class.add_arguments(parser)\n\n    def handle(self, *test_labels, **options):\n        TestRunner = get_runner(settings, options[\"testrunner\"])\n\n        time_keeper = TimeKeeper() if options.get(\"timing\", False) else NullTimeKeeper()\n        parallel = options.get(\"parallel\")\n        if parallel == \"auto\":\n            options[\"parallel\"] = get_max_test_processes()\n        test_runner = TestRunner(**options)\n        with time_keeper.timed(\"Total run\"):\n            failures = test_runner.run_tests(test_labels)\n        time_keeper.print_results()\n        if failures:\n            sys.exit(1)\n",
    "django/core/management/commands/testserver.py": "from django.core.management import call_command\nfrom django.core.management.base import BaseCommand\nfrom django.db import connection\n\n\nclass Command(BaseCommand):\n    help = \"Runs a development server with data from the given fixture(s).\"\n\n    requires_system_checks = []\n\n    def add_arguments(self, parser):\n        parser.add_argument(\n            \"args\",\n            metavar=\"fixture\",\n            nargs=\"*\",\n            help=\"Path(s) to fixtures to load before running the server.\",\n        )\n        parser.add_argument(\n            \"--noinput\",\n            \"--no-input\",\n            action=\"store_false\",\n            dest=\"interactive\",\n            help=\"Tells Django to NOT prompt the user for input of any kind.\",\n        )\n        parser.add_argument(\n            \"--addrport\",\n            default=\"\",\n            help=\"Port number or ipaddr:port to run the server on.\",\n        )\n        parser.add_argument(\n            \"--ipv6\",\n            \"-6\",\n            action=\"store_true\",\n            dest=\"use_ipv6\",\n            help=\"Tells Django to use an IPv6 address.\",\n        )\n\n    def handle(self, *fixture_labels, **options):\n        verbosity = options[\"verbosity\"]\n        interactive = options[\"interactive\"]\n\n        # Create a test database.\n        db_name = connection.creation.create_test_db(\n            verbosity=verbosity, autoclobber=not interactive\n        )\n\n        # Import the fixture data into the test database.\n        call_command(\"loaddata\", *fixture_labels, verbosity=verbosity)\n\n        # Run the development server. Turn off auto-reloading because it causes\n        # a strange error -- it causes this handle() method to be called\n        # multiple times.\n        shutdown_message = (\n            \"\\nServer stopped.\\nNote that the test database, %r, has not been \"\n            \"deleted. You can explore it on your own.\" % db_name\n        )\n        use_threading = connection.features.test_db_allows_multiple_connections\n        call_command(\n            \"runserver\",\n            addrport=options[\"addrport\"],\n            shutdown_message=shutdown_message,\n            use_reloader=False,\n            use_ipv6=options[\"use_ipv6\"],\n            use_threading=use_threading,\n        )\n",
    "django/test/__init__.py": "\"\"\"Django Unit Test framework.\"\"\"\n\nfrom django.test.client import AsyncClient, AsyncRequestFactory, Client, RequestFactory\nfrom django.test.testcases import (\n    LiveServerTestCase,\n    SimpleTestCase,\n    TestCase,\n    TransactionTestCase,\n    skipIfDBFeature,\n    skipUnlessAnyDBFeature,\n    skipUnlessDBFeature,\n)\nfrom django.test.utils import (\n    ignore_warnings,\n    modify_settings,\n    override_settings,\n    override_system_checks,\n    tag,\n)\n\n__all__ = [\n    \"AsyncClient\",\n    \"AsyncRequestFactory\",\n    \"Client\",\n    \"RequestFactory\",\n    \"TestCase\",\n    \"TransactionTestCase\",\n    \"SimpleTestCase\",\n    \"LiveServerTestCase\",\n    \"skipIfDBFeature\",\n    \"skipUnlessAnyDBFeature\",\n    \"skipUnlessDBFeature\",\n    \"ignore_warnings\",\n    \"modify_settings\",\n    \"override_settings\",\n    \"override_system_checks\",\n    \"tag\",\n]\n",
    "django/test/client.py": "import json\nimport mimetypes\nimport os\nimport sys\nfrom collections.abc import Iterable\nfrom copy import copy\nfrom functools import partial\nfrom http import HTTPStatus\nfrom importlib import import_module\nfrom io import BytesIO, IOBase\nfrom urllib.parse import unquote_to_bytes, urljoin, urlsplit\n\nfrom asgiref.sync import sync_to_async\n\nfrom django.conf import settings\nfrom django.core.handlers.asgi import ASGIRequest\nfrom django.core.handlers.base import BaseHandler\nfrom django.core.handlers.wsgi import LimitedStream, WSGIRequest\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import got_request_exception, request_finished, request_started\nfrom django.db import close_old_connections\nfrom django.http import HttpHeaders, HttpRequest, QueryDict, SimpleCookie\nfrom django.test import signals\nfrom django.test.utils import ContextList\nfrom django.urls import resolve\nfrom django.utils.encoding import force_bytes\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.http import urlencode\nfrom django.utils.regex_helper import _lazy_re_compile\n\n__all__ = (\n    \"AsyncClient\",\n    \"AsyncRequestFactory\",\n    \"Client\",\n    \"RedirectCycleError\",\n    \"RequestFactory\",\n    \"encode_file\",\n    \"encode_multipart\",\n)\n\n\nBOUNDARY = \"BoUnDaRyStRiNg\"\nMULTIPART_CONTENT = \"multipart/form-data; boundary=%s\" % BOUNDARY\nCONTENT_TYPE_RE = _lazy_re_compile(r\".*; charset=([\\w-]+);?\")\n# Structured suffix spec: https://tools.ietf.org/html/rfc6838#section-4.2.8\nJSON_CONTENT_TYPE_RE = _lazy_re_compile(r\"^application\\/(.+\\+)?json\")\n\nREDIRECT_STATUS_CODES = frozenset(\n    [\n        HTTPStatus.MOVED_PERMANENTLY,\n        HTTPStatus.FOUND,\n        HTTPStatus.SEE_OTHER,\n        HTTPStatus.TEMPORARY_REDIRECT,\n        HTTPStatus.PERMANENT_REDIRECT,\n    ]\n)\n\n\nclass RedirectCycleError(Exception):\n    \"\"\"The test client has been asked to follow a redirect loop.\"\"\"\n\n    def __init__(self, message, last_response):\n        super().__init__(message)\n        self.last_response = last_response\n        self.redirect_chain = last_response.redirect_chain\n\n\nclass FakePayload(IOBase):\n    \"\"\"\n    A wrapper around BytesIO that restricts what can be read since data from\n    the network can't be sought and cannot be read outside of its content\n    length. This makes sure that views can't do anything under the test client\n    that wouldn't work in real life.\n    \"\"\"\n\n    def __init__(self, initial_bytes=None):\n        self.__content = BytesIO()\n        self.__len = 0\n        self.read_started = False\n        if initial_bytes is not None:\n            self.write(initial_bytes)\n\n    def __len__(self):\n        return self.__len\n\n    def read(self, size=-1, /):\n        if not self.read_started:\n            self.__content.seek(0)\n            self.read_started = True\n        if size == -1 or size is None:\n            size = self.__len\n        assert (\n            self.__len >= size\n        ), \"Cannot read more than the available bytes from the HTTP incoming data.\"\n        content = self.__content.read(size)\n        self.__len -= len(content)\n        return content\n\n    def readline(self, size=-1, /):\n        if not self.read_started:\n            self.__content.seek(0)\n            self.read_started = True\n        if size == -1 or size is None:\n            size = self.__len\n        assert (\n            self.__len >= size\n        ), \"Cannot read more than the available bytes from the HTTP incoming data.\"\n        content = self.__content.readline(size)\n        self.__len -= len(content)\n        return content\n\n    def write(self, b, /):\n        if self.read_started:\n            raise ValueError(\"Unable to write a payload after it's been read\")\n        content = force_bytes(b)\n        self.__content.write(content)\n        self.__len += len(content)\n\n\ndef closing_iterator_wrapper(iterable, close):\n    try:\n        yield from iterable\n    finally:\n        request_finished.disconnect(close_old_connections)\n        close()  # will fire request_finished\n        request_finished.connect(close_old_connections)\n\n\nasync def aclosing_iterator_wrapper(iterable, close):\n    try:\n        async for chunk in iterable:\n            yield chunk\n    finally:\n        request_finished.disconnect(close_old_connections)\n        close()  # will fire request_finished\n        request_finished.connect(close_old_connections)\n\n\ndef conditional_content_removal(request, response):\n    \"\"\"\n    Simulate the behavior of most web servers by removing the content of\n    responses for HEAD requests, 1xx, 204, and 304 responses. Ensure\n    compliance with RFC 9112 Section 6.3.\n    \"\"\"\n    if 100 <= response.status_code < 200 or response.status_code in (204, 304):\n        if response.streaming:\n            response.streaming_content = []\n        else:\n            response.content = b\"\"\n    if request.method == \"HEAD\":\n        if response.streaming:\n            response.streaming_content = []\n        else:\n            response.content = b\"\"\n    return response\n\n\nclass ClientHandler(BaseHandler):\n    \"\"\"\n    An HTTP Handler that can be used for testing purposes. Use the WSGI\n    interface to compose requests, but return the raw HttpResponse object with\n    the originating WSGIRequest attached to its ``wsgi_request`` attribute.\n    \"\"\"\n\n    def __init__(self, enforce_csrf_checks=True, *args, **kwargs):\n        self.enforce_csrf_checks = enforce_csrf_checks\n        super().__init__(*args, **kwargs)\n\n    def __call__(self, environ):\n        # Set up middleware if needed. We couldn't do this earlier, because\n        # settings weren't available.\n        if self._middleware_chain is None:\n            self.load_middleware()\n\n        request_started.disconnect(close_old_connections)\n        request_started.send(sender=self.__class__, environ=environ)\n        request_started.connect(close_old_connections)\n        request = WSGIRequest(environ)\n        # sneaky little hack so that we can easily get round\n        # CsrfViewMiddleware.  This makes life easier, and is probably\n        # required for backwards compatibility with external tests against\n        # admin views.\n        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks\n\n        # Request goes through middleware.\n        response = self.get_response(request)\n\n        # Simulate behaviors of most web servers.\n        conditional_content_removal(request, response)\n\n        # Attach the originating request to the response so that it could be\n        # later retrieved.\n        response.wsgi_request = request\n\n        # Emulate a WSGI server by calling the close method on completion.\n        if response.streaming:\n            if response.is_async:\n                response.streaming_content = aclosing_iterator_wrapper(\n                    response.streaming_content, response.close\n                )\n            else:\n                response.streaming_content = closing_iterator_wrapper(\n                    response.streaming_content, response.close\n                )\n        else:\n            request_finished.disconnect(close_old_connections)\n            response.close()  # will fire request_finished\n            request_finished.connect(close_old_connections)\n\n        return response\n\n\nclass AsyncClientHandler(BaseHandler):\n    \"\"\"An async version of ClientHandler.\"\"\"\n\n    def __init__(self, enforce_csrf_checks=True, *args, **kwargs):\n        self.enforce_csrf_checks = enforce_csrf_checks\n        super().__init__(*args, **kwargs)\n\n    async def __call__(self, scope):\n        # Set up middleware if needed. We couldn't do this earlier, because\n        # settings weren't available.\n        if self._middleware_chain is None:\n            self.load_middleware(is_async=True)\n        # Extract body file from the scope, if provided.\n        if \"_body_file\" in scope:\n            body_file = scope.pop(\"_body_file\")\n        else:\n            body_file = FakePayload(\"\")\n\n        request_started.disconnect(close_old_connections)\n        await request_started.asend(sender=self.__class__, scope=scope)\n        request_started.connect(close_old_connections)\n        # Wrap FakePayload body_file to allow large read() in test environment.\n        request = ASGIRequest(scope, LimitedStream(body_file, len(body_file)))\n        # Sneaky little hack so that we can easily get round\n        # CsrfViewMiddleware. This makes life easier, and is probably required\n        # for backwards compatibility with external tests against admin views.\n        request._dont_enforce_csrf_checks = not self.enforce_csrf_checks\n        # Request goes through middleware.\n        response = await self.get_response_async(request)\n        # Simulate behaviors of most web servers.\n        conditional_content_removal(request, response)\n        # Attach the originating ASGI request to the response so that it could\n        # be later retrieved.\n        response.asgi_request = request\n        # Emulate a server by calling the close method on completion.\n        if response.streaming:\n            if response.is_async:\n                response.streaming_content = aclosing_iterator_wrapper(\n                    response.streaming_content, response.close\n                )\n            else:\n                response.streaming_content = closing_iterator_wrapper(\n                    response.streaming_content, response.close\n                )\n        else:\n            request_finished.disconnect(close_old_connections)\n            # Will fire request_finished.\n            await sync_to_async(response.close, thread_sensitive=False)()\n            request_finished.connect(close_old_connections)\n        return response\n\n\ndef store_rendered_templates(store, signal, sender, template, context, **kwargs):\n    \"\"\"\n    Store templates and contexts that are rendered.\n\n    The context is copied so that it is an accurate representation at the time\n    of rendering.\n    \"\"\"\n    store.setdefault(\"templates\", []).append(template)\n    if \"context\" not in store:\n        store[\"context\"] = ContextList()\n    store[\"context\"].append(copy(context))\n\n\ndef encode_multipart(boundary, data):\n    \"\"\"\n    Encode multipart POST data from a dictionary of form values.\n\n    The key will be used as the form data name; the value will be transmitted\n    as content. If the value is a file, the contents of the file will be sent\n    as an application/octet-stream; otherwise, str(value) will be sent.\n    \"\"\"\n    lines = []\n\n    def to_bytes(s):\n        return force_bytes(s, settings.DEFAULT_CHARSET)\n\n    # Not by any means perfect, but good enough for our purposes.\n    def is_file(thing):\n        return hasattr(thing, \"read\") and callable(thing.read)\n\n    # Each bit of the multipart form data could be either a form value or a\n    # file, or a *list* of form values and/or files. Remember that HTTP field\n    # names can be duplicated!\n    for key, value in data.items():\n        if value is None:\n            raise TypeError(\n                \"Cannot encode None for key '%s' as POST data. Did you mean \"\n                \"to pass an empty string or omit the value?\" % key\n            )\n        elif is_file(value):\n            lines.extend(encode_file(boundary, key, value))\n        elif not isinstance(value, str) and isinstance(value, Iterable):\n            for item in value:\n                if is_file(item):\n                    lines.extend(encode_file(boundary, key, item))\n                else:\n                    lines.extend(\n                        to_bytes(val)\n                        for val in [\n                            \"--%s\" % boundary,\n                            'Content-Disposition: form-data; name=\"%s\"' % key,\n                            \"\",\n                            item,\n                        ]\n                    )\n        else:\n            lines.extend(\n                to_bytes(val)\n                for val in [\n                    \"--%s\" % boundary,\n                    'Content-Disposition: form-data; name=\"%s\"' % key,\n                    \"\",\n                    value,\n                ]\n            )\n\n    lines.extend(\n        [\n            to_bytes(\"--%s--\" % boundary),\n            b\"\",\n        ]\n    )\n    return b\"\\r\\n\".join(lines)\n\n\ndef encode_file(boundary, key, file):\n    def to_bytes(s):\n        return force_bytes(s, settings.DEFAULT_CHARSET)\n\n    # file.name might not be a string. For example, it's an int for\n    # tempfile.TemporaryFile().\n    file_has_string_name = hasattr(file, \"name\") and isinstance(file.name, str)\n    filename = os.path.basename(file.name) if file_has_string_name else \"\"\n\n    if hasattr(file, \"content_type\"):\n        content_type = file.content_type\n    elif filename:\n        content_type = mimetypes.guess_type(filename)[0]\n    else:\n        content_type = None\n\n    if content_type is None:\n        content_type = \"application/octet-stream\"\n    filename = filename or key\n    return [\n        to_bytes(\"--%s\" % boundary),\n        to_bytes(\n            'Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"' % (key, filename)\n        ),\n        to_bytes(\"Content-Type: %s\" % content_type),\n        b\"\",\n        to_bytes(file.read()),\n    ]\n\n\nclass RequestFactory:\n    \"\"\"\n    Class that lets you create mock Request objects for use in testing.\n\n    Usage:\n\n    rf = RequestFactory()\n    get_request = rf.get('/hello/')\n    post_request = rf.post('/submit/', {'foo': 'bar'})\n\n    Once you have a request object you can pass it to any view function,\n    just as if that view had been hooked up using a URLconf.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        json_encoder=DjangoJSONEncoder,\n        headers=None,\n        query_params=None,\n        **defaults,\n    ):\n        self.json_encoder = json_encoder\n        self.defaults = defaults\n        self.cookies = SimpleCookie()\n        self.errors = BytesIO()\n        if headers:\n            self.defaults.update(HttpHeaders.to_wsgi_names(headers))\n        if query_params:\n            self.defaults[\"QUERY_STRING\"] = urlencode(query_params, doseq=True)\n\n    def _base_environ(self, **request):\n        \"\"\"\n        The base environment for a request.\n        \"\"\"\n        # This is a minimal valid WSGI environ dictionary, plus:\n        # - HTTP_COOKIE: for cookie support,\n        # - REMOTE_ADDR: often useful, see #8551.\n        # See https://www.python.org/dev/peps/pep-3333/#environ-variables\n        return {\n            \"HTTP_COOKIE\": \"; \".join(\n                sorted(\n                    \"%s=%s\" % (morsel.key, morsel.coded_value)\n                    for morsel in self.cookies.values()\n                )\n            ),\n            \"PATH_INFO\": \"/\",\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"REQUEST_METHOD\": \"GET\",\n            \"SCRIPT_NAME\": \"\",\n            \"SERVER_NAME\": \"testserver\",\n            \"SERVER_PORT\": \"80\",\n            \"SERVER_PROTOCOL\": \"HTTP/1.1\",\n            \"wsgi.version\": (1, 0),\n            \"wsgi.url_scheme\": \"http\",\n            \"wsgi.input\": FakePayload(b\"\"),\n            \"wsgi.errors\": self.errors,\n            \"wsgi.multiprocess\": True,\n            \"wsgi.multithread\": False,\n            \"wsgi.run_once\": False,\n            **self.defaults,\n            **request,\n        }\n\n    def request(self, **request):\n        \"Construct a generic request object.\"\n        return WSGIRequest(self._base_environ(**request))\n\n    def _encode_data(self, data, content_type):\n        if content_type is MULTIPART_CONTENT:\n            return encode_multipart(BOUNDARY, data)\n        else:\n            # Encode the content so that the byte representation is correct.\n            match = CONTENT_TYPE_RE.match(content_type)\n            if match:\n                charset = match[1]\n            else:\n                charset = settings.DEFAULT_CHARSET\n            return force_bytes(data, encoding=charset)\n\n    def _encode_json(self, data, content_type):\n        \"\"\"\n        Return encoded JSON if data is a dict, list, or tuple and content_type\n        is application/json.\n        \"\"\"\n        should_encode = JSON_CONTENT_TYPE_RE.match(content_type) and isinstance(\n            data, (dict, list, tuple)\n        )\n        return json.dumps(data, cls=self.json_encoder) if should_encode else data\n\n    def _get_path(self, parsed):\n        path = unquote_to_bytes(parsed.path)\n        # Replace the behavior where non-ASCII values in the WSGI environ are\n        # arbitrarily decoded with ISO-8859-1.\n        # Refs comment in `get_bytes_from_wsgi()`.\n        return path.decode(\"iso-8859-1\")\n\n    def get(\n        self, path, data=None, secure=False, *, headers=None, query_params=None, **extra\n    ):\n        \"\"\"Construct a GET request.\"\"\"\n        if query_params and data:\n            raise ValueError(\"query_params and data arguments are mutually exclusive.\")\n        query_params = data or query_params\n        query_params = {} if query_params is None else query_params\n        return self.generic(\n            \"GET\",\n            path,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def post(\n        self,\n        path,\n        data=None,\n        content_type=MULTIPART_CONTENT,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct a POST request.\"\"\"\n        data = self._encode_json({} if data is None else data, content_type)\n        post_data = self._encode_data(data, content_type)\n\n        return self.generic(\n            \"POST\",\n            path,\n            post_data,\n            content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def head(\n        self, path, data=None, secure=False, *, headers=None, query_params=None, **extra\n    ):\n        \"\"\"Construct a HEAD request.\"\"\"\n        if query_params and data:\n            raise ValueError(\"query_params and data arguments are mutually exclusive.\")\n        query_params = data or query_params\n        query_params = {} if query_params is None else query_params\n        return self.generic(\n            \"HEAD\",\n            path,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def trace(self, path, secure=False, *, headers=None, query_params=None, **extra):\n        \"\"\"Construct a TRACE request.\"\"\"\n        return self.generic(\n            \"TRACE\",\n            path,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def options(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"Construct an OPTIONS request.\"\n        return self.generic(\n            \"OPTIONS\",\n            path,\n            data,\n            content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def put(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct a PUT request.\"\"\"\n        data = self._encode_json(data, content_type)\n        return self.generic(\n            \"PUT\",\n            path,\n            data,\n            content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def patch(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct a PATCH request.\"\"\"\n        data = self._encode_json(data, content_type)\n        return self.generic(\n            \"PATCH\",\n            path,\n            data,\n            content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def delete(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct a DELETE request.\"\"\"\n        data = self._encode_json(data, content_type)\n        return self.generic(\n            \"DELETE\",\n            path,\n            data,\n            content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def generic(\n        self,\n        method,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct an arbitrary HTTP request.\"\"\"\n        parsed = urlsplit(str(path))  # path can be lazy\n        data = force_bytes(data, settings.DEFAULT_CHARSET)\n        r = {\n            \"PATH_INFO\": self._get_path(parsed),\n            \"REQUEST_METHOD\": method,\n            \"SERVER_PORT\": \"443\" if secure else \"80\",\n            \"wsgi.url_scheme\": \"https\" if secure else \"http\",\n        }\n        if data:\n            r.update(\n                {\n                    \"CONTENT_LENGTH\": str(len(data)),\n                    \"CONTENT_TYPE\": content_type,\n                    \"wsgi.input\": FakePayload(data),\n                }\n            )\n        if headers:\n            extra.update(HttpHeaders.to_wsgi_names(headers))\n        if query_params:\n            extra[\"QUERY_STRING\"] = urlencode(query_params, doseq=True)\n        r.update(extra)\n        # If QUERY_STRING is absent or empty, we want to extract it from the URL.\n        if not r.get(\"QUERY_STRING\"):\n            # WSGI requires latin-1 encoded strings. See get_path_info().\n            r[\"QUERY_STRING\"] = parsed.query.encode().decode(\"iso-8859-1\")\n        return self.request(**r)\n\n\nclass AsyncRequestFactory(RequestFactory):\n    \"\"\"\n    Class that lets you create mock ASGI-like Request objects for use in\n    testing. Usage:\n\n    rf = AsyncRequestFactory()\n    get_request = rf.get(\"/hello/\")\n    post_request = rf.post(\"/submit/\", {\"foo\": \"bar\"})\n\n    Once you have a request object you can pass it to any view function,\n    including synchronous ones. The reason we have a separate class here is:\n    a) this makes ASGIRequest subclasses, and\n    b) AsyncClient can subclass it.\n    \"\"\"\n\n    def _base_scope(self, **request):\n        \"\"\"The base scope for a request.\"\"\"\n        # This is a minimal valid ASGI scope, plus:\n        # - headers['cookie'] for cookie support,\n        # - 'client' often useful, see #8551.\n        scope = {\n            \"asgi\": {\"version\": \"3.0\"},\n            \"type\": \"http\",\n            \"http_version\": \"1.1\",\n            \"client\": [\"127.0.0.1\", 0],\n            \"server\": (\"testserver\", \"80\"),\n            \"scheme\": \"http\",\n            \"method\": \"GET\",\n            \"headers\": [],\n            **self.defaults,\n            **request,\n        }\n        scope[\"headers\"].append(\n            (\n                b\"cookie\",\n                b\"; \".join(\n                    sorted(\n                        (\"%s=%s\" % (morsel.key, morsel.coded_value)).encode(\"ascii\")\n                        for morsel in self.cookies.values()\n                    )\n                ),\n            )\n        )\n        return scope\n\n    def request(self, **request):\n        \"\"\"Construct a generic request object.\"\"\"\n        # This is synchronous, which means all methods on this class are.\n        # AsyncClient, however, has an async request function, which makes all\n        # its methods async.\n        if \"_body_file\" in request:\n            body_file = request.pop(\"_body_file\")\n        else:\n            body_file = FakePayload(\"\")\n        # Wrap FakePayload body_file to allow large read() in test environment.\n        return ASGIRequest(\n            self._base_scope(**request), LimitedStream(body_file, len(body_file))\n        )\n\n    def generic(\n        self,\n        method,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Construct an arbitrary HTTP request.\"\"\"\n        parsed = urlsplit(str(path))  # path can be lazy.\n        data = force_bytes(data, settings.DEFAULT_CHARSET)\n        s = {\n            \"method\": method,\n            \"path\": self._get_path(parsed),\n            \"server\": (\"127.0.0.1\", \"443\" if secure else \"80\"),\n            \"scheme\": \"https\" if secure else \"http\",\n            \"headers\": [(b\"host\", b\"testserver\")],\n        }\n        if self.defaults:\n            extra = {**self.defaults, **extra}\n        if data:\n            s[\"headers\"].extend(\n                [\n                    (b\"content-length\", str(len(data)).encode(\"ascii\")),\n                    (b\"content-type\", content_type.encode(\"ascii\")),\n                ]\n            )\n            s[\"_body_file\"] = FakePayload(data)\n        if query_params:\n            s[\"query_string\"] = urlencode(query_params, doseq=True)\n        elif query_string := extra.pop(\"QUERY_STRING\", None):\n            s[\"query_string\"] = query_string\n        else:\n            # If QUERY_STRING is absent or empty, we want to extract it from\n            # the URL.\n            s[\"query_string\"] = parsed.query\n        if headers:\n            extra.update(HttpHeaders.to_asgi_names(headers))\n        s[\"headers\"] += [\n            (key.lower().encode(\"ascii\"), value.encode(\"latin1\"))\n            for key, value in extra.items()\n        ]\n        return self.request(**s)\n\n\nclass ClientMixin:\n    \"\"\"\n    Mixin with common methods between Client and AsyncClient.\n    \"\"\"\n\n    def store_exc_info(self, **kwargs):\n        \"\"\"Store exceptions when they are generated by a view.\"\"\"\n        self.exc_info = sys.exc_info()\n\n    def check_exception(self, response):\n        \"\"\"\n        Look for a signaled exception, clear the current context exception\n        data, re-raise the signaled exception, and clear the signaled exception\n        from the local cache.\n        \"\"\"\n        response.exc_info = self.exc_info\n        if self.exc_info:\n            _, exc_value, _ = self.exc_info\n            self.exc_info = None\n            if self.raise_request_exception:\n                raise exc_value\n\n    @property\n    def session(self):\n        \"\"\"Return the current session variables.\"\"\"\n        engine = import_module(settings.SESSION_ENGINE)\n        cookie = self.cookies.get(settings.SESSION_COOKIE_NAME)\n        if cookie:\n            return engine.SessionStore(cookie.value)\n        session = engine.SessionStore()\n        session.save()\n        self.cookies[settings.SESSION_COOKIE_NAME] = session.session_key\n        return session\n\n    async def asession(self):\n        engine = import_module(settings.SESSION_ENGINE)\n        cookie = self.cookies.get(settings.SESSION_COOKIE_NAME)\n        if cookie:\n            return engine.SessionStore(cookie.value)\n        session = engine.SessionStore()\n        await session.asave()\n        self.cookies[settings.SESSION_COOKIE_NAME] = session.session_key\n        return session\n\n    def login(self, **credentials):\n        \"\"\"\n        Set the Factory to appear as if it has successfully logged into a site.\n\n        Return True if login is possible or False if the provided credentials\n        are incorrect.\n        \"\"\"\n        from django.contrib.auth import authenticate\n\n        user = authenticate(**credentials)\n        if user:\n            self._login(user)\n            return True\n        return False\n\n    async def alogin(self, **credentials):\n        \"\"\"See login().\"\"\"\n        from django.contrib.auth import aauthenticate\n\n        user = await aauthenticate(**credentials)\n        if user:\n            await self._alogin(user)\n            return True\n        return False\n\n    def force_login(self, user, backend=None):\n        if backend is None:\n            backend = self._get_backend()\n        user.backend = backend\n        self._login(user, backend)\n\n    async def aforce_login(self, user, backend=None):\n        if backend is None:\n            backend = self._get_backend()\n        user.backend = backend\n        await self._alogin(user, backend)\n\n    def _get_backend(self):\n        from django.contrib.auth import load_backend\n\n        for backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            if hasattr(backend, \"get_user\"):\n                return backend_path\n\n    def _login(self, user, backend=None):\n        from django.contrib.auth import login\n\n        # Create a fake request to store login details.\n        request = HttpRequest()\n        if self.session:\n            request.session = self.session\n        else:\n            engine = import_module(settings.SESSION_ENGINE)\n            request.session = engine.SessionStore()\n        login(request, user, backend)\n        # Save the session values.\n        request.session.save()\n        self._set_login_cookies(request)\n\n    async def _alogin(self, user, backend=None):\n        from django.contrib.auth import alogin\n\n        # Create a fake request to store login details.\n        request = HttpRequest()\n        session = await self.asession()\n        if session:\n            request.session = session\n        else:\n            engine = import_module(settings.SESSION_ENGINE)\n            request.session = engine.SessionStore()\n\n        await alogin(request, user, backend)\n        # Save the session values.\n        await request.session.asave()\n        self._set_login_cookies(request)\n\n    def _set_login_cookies(self, request):\n        # Set the cookie to represent the session.\n        session_cookie = settings.SESSION_COOKIE_NAME\n        self.cookies[session_cookie] = request.session.session_key\n        cookie_data = {\n            \"max-age\": None,\n            \"path\": \"/\",\n            \"domain\": settings.SESSION_COOKIE_DOMAIN,\n            \"secure\": settings.SESSION_COOKIE_SECURE or None,\n            \"expires\": None,\n        }\n        self.cookies[session_cookie].update(cookie_data)\n\n    def logout(self):\n        \"\"\"Log out the user by removing the cookies and session object.\"\"\"\n        from django.contrib.auth import get_user, logout\n\n        request = HttpRequest()\n        if self.session:\n            request.session = self.session\n            request.user = get_user(request)\n        else:\n            engine = import_module(settings.SESSION_ENGINE)\n            request.session = engine.SessionStore()\n        logout(request)\n        self.cookies = SimpleCookie()\n\n    async def alogout(self):\n        \"\"\"See logout().\"\"\"\n        from django.contrib.auth import aget_user, alogout\n\n        request = HttpRequest()\n        session = await self.asession()\n        if session:\n            request.session = session\n            request.user = await aget_user(request)\n        else:\n            engine = import_module(settings.SESSION_ENGINE)\n            request.session = engine.SessionStore()\n        await alogout(request)\n        self.cookies = SimpleCookie()\n\n    def _parse_json(self, response, **extra):\n        if not hasattr(response, \"_json\"):\n            if not JSON_CONTENT_TYPE_RE.match(response.get(\"Content-Type\")):\n                raise ValueError(\n                    'Content-Type header is \"%s\", not \"application/json\"'\n                    % response.get(\"Content-Type\")\n                )\n            response._json = json.loads(response.text, **extra)\n        return response._json\n\n    def _follow_redirect(\n        self,\n        response,\n        *,\n        data=\"\",\n        content_type=\"\",\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Follow a single redirect contained in response using GET.\"\"\"\n        response_url = response.url\n        redirect_chain = response.redirect_chain\n        redirect_chain.append((response_url, response.status_code))\n\n        url = urlsplit(response_url)\n        if url.scheme:\n            extra[\"wsgi.url_scheme\"] = url.scheme\n        if url.hostname:\n            extra[\"SERVER_NAME\"] = url.hostname\n            extra[\"HTTP_HOST\"] = url.hostname\n        if url.port:\n            extra[\"SERVER_PORT\"] = str(url.port)\n\n        path = url.path\n        # RFC 3986 Section 6.2.3: Empty path should be normalized to \"/\".\n        if not path and url.netloc:\n            path = \"/\"\n        # Prepend the request path to handle relative path redirects\n        if not path.startswith(\"/\"):\n            path = urljoin(response.request[\"PATH_INFO\"], path)\n\n        if response.status_code in (\n            HTTPStatus.TEMPORARY_REDIRECT,\n            HTTPStatus.PERMANENT_REDIRECT,\n        ):\n            # Preserve request method and query string (if needed)\n            # post-redirect for 307/308 responses.\n            request_method = response.request[\"REQUEST_METHOD\"].lower()\n            if request_method not in (\"get\", \"head\"):\n                extra[\"QUERY_STRING\"] = url.query\n            request_method = getattr(self, request_method)\n        else:\n            request_method = self.get\n            data = QueryDict(url.query)\n            content_type = None\n\n        return request_method(\n            path,\n            data=data,\n            content_type=content_type,\n            follow=False,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n\n    def _ensure_redirects_not_cyclic(self, response):\n        \"\"\"\n        Raise a RedirectCycleError if response contains too many redirects.\n        \"\"\"\n        redirect_chain = response.redirect_chain\n        if redirect_chain[-1] in redirect_chain[:-1]:\n            # Check that we're not redirecting to somewhere we've already been\n            # to, to prevent loops.\n            raise RedirectCycleError(\"Redirect loop detected.\", last_response=response)\n        if len(redirect_chain) > 20:\n            # Such a lengthy chain likely also means a loop, but one with a\n            # growing path, changing view, or changing query argument. 20 is\n            # the value of \"network.http.redirection-limit\" from Firefox.\n            raise RedirectCycleError(\"Too many redirects.\", last_response=response)\n\n\nclass Client(ClientMixin, RequestFactory):\n    \"\"\"\n    A class that can act as a client for testing purposes.\n\n    It allows the user to compose GET and POST requests, and\n    obtain the response that the server gave to those requests.\n    The server Response objects are annotated with the details\n    of the contexts and templates that were rendered during the\n    process of serving the request.\n\n    Client objects are stateful - they will retain cookie (and\n    thus session) details for the lifetime of the Client instance.\n\n    This is not intended as a replacement for Twill/Selenium or\n    the like - it is here to allow testing against the\n    contexts and templates produced by a view, rather than the\n    HTML rendered to the end-user.\n    \"\"\"\n\n    def __init__(\n        self,\n        enforce_csrf_checks=False,\n        raise_request_exception=True,\n        *,\n        headers=None,\n        query_params=None,\n        **defaults,\n    ):\n        super().__init__(headers=headers, query_params=query_params, **defaults)\n        self.handler = ClientHandler(enforce_csrf_checks)\n        self.raise_request_exception = raise_request_exception\n        self.exc_info = None\n        self.extra = None\n        self.headers = None\n\n    def request(self, **request):\n        \"\"\"\n        Make a generic request. Compose the environment dictionary and pass\n        to the handler, return the result of the handler. Assume defaults for\n        the query environment, which can be overridden using the arguments to\n        the request.\n        \"\"\"\n        environ = self._base_environ(**request)\n\n        # Curry a data dictionary into an instance of the template renderer\n        # callback function.\n        data = {}\n        on_template_render = partial(store_rendered_templates, data)\n        signal_uid = \"template-render-%s\" % id(request)\n        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)\n        # Capture exceptions created by the handler.\n        exception_uid = \"request-exception-%s\" % id(request)\n        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)\n        try:\n            response = self.handler(environ)\n        finally:\n            signals.template_rendered.disconnect(dispatch_uid=signal_uid)\n            got_request_exception.disconnect(dispatch_uid=exception_uid)\n        # Check for signaled exceptions.\n        self.check_exception(response)\n        # Save the client and request that stimulated the response.\n        response.client = self\n        response.request = request\n        # Add any rendered template detail to the response.\n        response.templates = data.get(\"templates\", [])\n        response.context = data.get(\"context\")\n        response.json = partial(self._parse_json, response)\n        # Attach the ResolverMatch instance to the response.\n        urlconf = getattr(response.wsgi_request, \"urlconf\", None)\n        response.resolver_match = SimpleLazyObject(\n            lambda: resolve(request[\"PATH_INFO\"], urlconf=urlconf),\n        )\n        # Flatten a single context. Not really necessary anymore thanks to the\n        # __getattr__ flattening in ContextList, but has some edge case\n        # backwards compatibility implications.\n        if response.context and len(response.context) == 1:\n            response.context = response.context[0]\n        # Update persistent cookie data.\n        if response.cookies:\n            self.cookies.update(response.cookies)\n        return response\n\n    def get(\n        self,\n        path,\n        data=None,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using GET.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().get(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    def post(\n        self,\n        path,\n        data=None,\n        content_type=MULTIPART_CONTENT,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using POST.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().post(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    def head(\n        self,\n        path,\n        data=None,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using HEAD.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().head(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    def options(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using OPTIONS.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().options(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    def put(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a resource to the server using PUT.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().put(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    def patch(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a resource to the server using PATCH.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().patch(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    def delete(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a DELETE request to the server.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().delete(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    def trace(\n        self,\n        path,\n        data=\"\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a TRACE request to the server.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = super().trace(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = self._handle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    def _handle_redirects(\n        self,\n        response,\n        data=\"\",\n        content_type=\"\",\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"\n        Follow any redirects by requesting responses from the server using GET.\n        \"\"\"\n        response.redirect_chain = []\n        while response.status_code in REDIRECT_STATUS_CODES:\n            redirect_chain = response.redirect_chain\n            response = self._follow_redirect(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n            response.redirect_chain = redirect_chain\n            self._ensure_redirects_not_cyclic(response)\n        return response\n\n\nclass AsyncClient(ClientMixin, AsyncRequestFactory):\n    \"\"\"\n    An async version of Client that creates ASGIRequests and calls through an\n    async request path.\n\n    Does not currently support \"follow\" on its methods.\n    \"\"\"\n\n    def __init__(\n        self,\n        enforce_csrf_checks=False,\n        raise_request_exception=True,\n        *,\n        headers=None,\n        query_params=None,\n        **defaults,\n    ):\n        super().__init__(headers=headers, query_params=query_params, **defaults)\n        self.handler = AsyncClientHandler(enforce_csrf_checks)\n        self.raise_request_exception = raise_request_exception\n        self.exc_info = None\n        self.extra = None\n        self.headers = None\n\n    async def request(self, **request):\n        \"\"\"\n        Make a generic request. Compose the scope dictionary and pass to the\n        handler, return the result of the handler. Assume defaults for the\n        query environment, which can be overridden using the arguments to the\n        request.\n        \"\"\"\n        scope = self._base_scope(**request)\n        # Curry a data dictionary into an instance of the template renderer\n        # callback function.\n        data = {}\n        on_template_render = partial(store_rendered_templates, data)\n        signal_uid = \"template-render-%s\" % id(request)\n        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)\n        # Capture exceptions created by the handler.\n        exception_uid = \"request-exception-%s\" % id(request)\n        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)\n        try:\n            response = await self.handler(scope)\n        finally:\n            signals.template_rendered.disconnect(dispatch_uid=signal_uid)\n            got_request_exception.disconnect(dispatch_uid=exception_uid)\n        # Check for signaled exceptions.\n        self.check_exception(response)\n        # Save the client and request that stimulated the response.\n        response.client = self\n        response.request = request\n        # Add any rendered template detail to the response.\n        response.templates = data.get(\"templates\", [])\n        response.context = data.get(\"context\")\n        response.json = partial(self._parse_json, response)\n        # Attach the ResolverMatch instance to the response.\n        urlconf = getattr(response.asgi_request, \"urlconf\", None)\n        response.resolver_match = SimpleLazyObject(\n            lambda: resolve(request[\"path\"], urlconf=urlconf),\n        )\n        # Flatten a single context. Not really necessary anymore thanks to the\n        # __getattr__ flattening in ContextList, but has some edge case\n        # backwards compatibility implications.\n        if response.context and len(response.context) == 1:\n            response.context = response.context[0]\n        # Update persistent cookie data.\n        if response.cookies:\n            self.cookies.update(response.cookies)\n        return response\n\n    async def get(\n        self,\n        path,\n        data=None,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using GET.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().get(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    async def post(\n        self,\n        path,\n        data=None,\n        content_type=MULTIPART_CONTENT,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using POST.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().post(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    async def head(\n        self,\n        path,\n        data=None,\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using HEAD.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().head(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    async def options(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Request a response from the server using OPTIONS.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().options(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    async def put(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a resource to the server using PUT.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().put(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    async def patch(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a resource to the server using PATCH.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().patch(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    async def delete(\n        self,\n        path,\n        data=\"\",\n        content_type=\"application/octet-stream\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a DELETE request to the server.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().delete(\n            path,\n            data=data,\n            content_type=content_type,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n        return response\n\n    async def trace(\n        self,\n        path,\n        data=\"\",\n        follow=False,\n        secure=False,\n        *,\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"Send a TRACE request to the server.\"\"\"\n        self.extra = extra\n        self.headers = headers\n        response = await super().trace(\n            path,\n            data=data,\n            secure=secure,\n            headers=headers,\n            query_params=query_params,\n            **extra,\n        )\n        if follow:\n            response = await self._ahandle_redirects(\n                response, data=data, headers=headers, query_params=query_params, **extra\n            )\n        return response\n\n    async def _ahandle_redirects(\n        self,\n        response,\n        data=\"\",\n        content_type=\"\",\n        headers=None,\n        query_params=None,\n        **extra,\n    ):\n        \"\"\"\n        Follow any redirects by requesting responses from the server using GET.\n        \"\"\"\n        response.redirect_chain = []\n        while response.status_code in REDIRECT_STATUS_CODES:\n            redirect_chain = response.redirect_chain\n            response = await self._follow_redirect(\n                response,\n                data=data,\n                content_type=content_type,\n                headers=headers,\n                query_params=query_params,\n                **extra,\n            )\n            response.redirect_chain = redirect_chain\n            self._ensure_redirects_not_cyclic(response)\n        return response\n",
    "django/test/html.py": "\"\"\"Compare two HTML documents.\"\"\"\n\nimport html\nfrom html.parser import HTMLParser\n\nfrom django.utils.html import VOID_ELEMENTS\nfrom django.utils.regex_helper import _lazy_re_compile\n\n# ASCII whitespace is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or U+0020\n# SPACE.\n# https://infra.spec.whatwg.org/#ascii-whitespace\nASCII_WHITESPACE = _lazy_re_compile(r\"[\\t\\n\\f\\r ]+\")\n\n# https://html.spec.whatwg.org/#attributes-3\nBOOLEAN_ATTRIBUTES = {\n    \"allowfullscreen\",\n    \"async\",\n    \"autofocus\",\n    \"autoplay\",\n    \"checked\",\n    \"controls\",\n    \"default\",\n    \"defer \",\n    \"disabled\",\n    \"formnovalidate\",\n    \"hidden\",\n    \"ismap\",\n    \"itemscope\",\n    \"loop\",\n    \"multiple\",\n    \"muted\",\n    \"nomodule\",\n    \"novalidate\",\n    \"open\",\n    \"playsinline\",\n    \"readonly\",\n    \"required\",\n    \"reversed\",\n    \"selected\",\n    # Attributes for deprecated tags.\n    \"truespeed\",\n}\n\n\ndef normalize_whitespace(string):\n    return ASCII_WHITESPACE.sub(\" \", string)\n\n\ndef normalize_attributes(attributes):\n    normalized = []\n    for name, value in attributes:\n        if name == \"class\" and value:\n            # Special case handling of 'class' attribute, so that comparisons\n            # of DOM instances are not sensitive to ordering of classes.\n            value = \" \".join(\n                sorted(value for value in ASCII_WHITESPACE.split(value) if value)\n            )\n        # Boolean attributes without a value is same as attribute with value\n        # that equals the attributes name. For example:\n        #   <input checked> == <input checked=\"checked\">\n        if name in BOOLEAN_ATTRIBUTES:\n            if not value or value == name:\n                value = None\n        elif value is None:\n            value = \"\"\n        normalized.append((name, value))\n    return normalized\n\n\nclass Element:\n    def __init__(self, name, attributes):\n        self.name = name\n        self.attributes = sorted(attributes)\n        self.children = []\n\n    def append(self, element):\n        if isinstance(element, str):\n            element = normalize_whitespace(element)\n            if self.children and isinstance(self.children[-1], str):\n                self.children[-1] += element\n                self.children[-1] = normalize_whitespace(self.children[-1])\n                return\n        elif self.children:\n            # removing last children if it is only whitespace\n            # this can result in incorrect dom representations since\n            # whitespace between inline tags like <span> is significant\n            if isinstance(self.children[-1], str) and self.children[-1].isspace():\n                self.children.pop()\n        if element:\n            self.children.append(element)\n\n    def finalize(self):\n        def rstrip_last_element(children):\n            if children and isinstance(children[-1], str):\n                children[-1] = children[-1].rstrip()\n                if not children[-1]:\n                    children.pop()\n                    children = rstrip_last_element(children)\n            return children\n\n        rstrip_last_element(self.children)\n        for i, child in enumerate(self.children):\n            if isinstance(child, str):\n                self.children[i] = child.strip()\n            elif hasattr(child, \"finalize\"):\n                child.finalize()\n\n    def __eq__(self, element):\n        if not hasattr(element, \"name\") or self.name != element.name:\n            return False\n        if self.attributes != element.attributes:\n            return False\n        return self.children == element.children\n\n    def __hash__(self):\n        return hash((self.name, *self.attributes))\n\n    def _count(self, element, count=True):\n        if not isinstance(element, str) and self == element:\n            return 1\n        if isinstance(element, RootElement) and self.children == element.children:\n            return 1\n        i = 0\n        elem_child_idx = 0\n        for child in self.children:\n            # child is text content and element is also text content, then\n            # make a simple \"text\" in \"text\"\n            if isinstance(child, str):\n                if isinstance(element, str):\n                    if count:\n                        i += child.count(element)\n                    elif element in child:\n                        return 1\n            else:\n                # Look for element wholly within this child.\n                i += child._count(element, count=count)\n                if not count and i:\n                    return i\n                # Also look for a sequence of element's children among self's\n                # children. self.children == element.children is tested above,\n                # but will fail if self has additional children. Ex: '<a/><b/>'\n                # is contained in '<a/><b/><c/>'.\n                if isinstance(element, RootElement) and element.children:\n                    elem_child = element.children[elem_child_idx]\n                    # Start or continue match, advance index.\n                    if elem_child == child:\n                        elem_child_idx += 1\n                        # Match found, reset index.\n                        if elem_child_idx == len(element.children):\n                            i += 1\n                            elem_child_idx = 0\n                    # No match, reset index.\n                    else:\n                        elem_child_idx = 0\n        return i\n\n    def __contains__(self, element):\n        return self._count(element, count=False) > 0\n\n    def count(self, element):\n        return self._count(element, count=True)\n\n    def __getitem__(self, key):\n        return self.children[key]\n\n    def __str__(self):\n        output = \"<%s\" % self.name\n        for key, value in self.attributes:\n            if value is not None:\n                output += ' %s=\"%s\"' % (key, value)\n            else:\n                output += \" %s\" % key\n        if self.children:\n            output += \">\\n\"\n            output += \"\".join(\n                [\n                    html.escape(c) if isinstance(c, str) else str(c)\n                    for c in self.children\n                ]\n            )\n            output += \"\\n</%s>\" % self.name\n        else:\n            output += \">\"\n        return output\n\n    def __repr__(self):\n        return str(self)\n\n\nclass RootElement(Element):\n    def __init__(self):\n        super().__init__(None, ())\n\n    def __str__(self):\n        return \"\".join(\n            [html.escape(c) if isinstance(c, str) else str(c) for c in self.children]\n        )\n\n\nclass HTMLParseError(Exception):\n    pass\n\n\nclass Parser(HTMLParser):\n    def __init__(self):\n        super().__init__()\n        self.root = RootElement()\n        self.open_tags = []\n        self.element_positions = {}\n\n    def error(self, msg):\n        raise HTMLParseError(msg, self.getpos())\n\n    def format_position(self, position=None, element=None):\n        if not position and element:\n            position = self.element_positions[element]\n        if position is None:\n            position = self.getpos()\n        if hasattr(position, \"lineno\"):\n            position = position.lineno, position.offset\n        return \"Line %d, Column %d\" % position\n\n    @property\n    def current(self):\n        if self.open_tags:\n            return self.open_tags[-1]\n        else:\n            return self.root\n\n    def handle_startendtag(self, tag, attrs):\n        self.handle_starttag(tag, attrs)\n        if tag not in VOID_ELEMENTS:\n            self.handle_endtag(tag)\n\n    def handle_starttag(self, tag, attrs):\n        attrs = normalize_attributes(attrs)\n        element = Element(tag, attrs)\n        self.current.append(element)\n        if tag not in VOID_ELEMENTS:\n            self.open_tags.append(element)\n        self.element_positions[element] = self.getpos()\n\n    def handle_endtag(self, tag):\n        if not self.open_tags:\n            self.error(\"Unexpected end tag `%s` (%s)\" % (tag, self.format_position()))\n        element = self.open_tags.pop()\n        while element.name != tag:\n            if not self.open_tags:\n                self.error(\n                    \"Unexpected end tag `%s` (%s)\" % (tag, self.format_position())\n                )\n            element = self.open_tags.pop()\n\n    def handle_data(self, data):\n        self.current.append(data)\n\n\ndef parse_html(html):\n    \"\"\"\n    Take a string that contains HTML and turn it into a Python object structure\n    that can be easily compared against other HTML on semantic equivalence.\n    Syntactical differences like which quotation is used on arguments will be\n    ignored.\n    \"\"\"\n    parser = Parser()\n    parser.feed(html)\n    parser.close()\n    document = parser.root\n    document.finalize()\n    # Removing ROOT element if it's not necessary\n    if len(document.children) == 1 and not isinstance(document.children[0], str):\n        document = document.children[0]\n    return document\n",
    "django/test/runner.py": "import argparse\nimport ctypes\nimport faulthandler\nimport hashlib\nimport io\nimport itertools\nimport logging\nimport multiprocessing\nimport os\nimport pickle\nimport random\nimport sys\nimport textwrap\nimport unittest\nimport unittest.suite\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom io import StringIO\n\nimport django\nfrom django.core.management import call_command\nfrom django.db import connections\nfrom django.test import SimpleTestCase, TestCase\nfrom django.test.utils import NullTimeKeeper, TimeKeeper, iter_test_cases\nfrom django.test.utils import setup_databases as _setup_databases\nfrom django.test.utils import setup_test_environment\nfrom django.test.utils import teardown_databases as _teardown_databases\nfrom django.test.utils import teardown_test_environment\nfrom django.utils.datastructures import OrderedSet\nfrom django.utils.version import PY313\n\ntry:\n    import ipdb as pdb\nexcept ImportError:\n    import pdb\n\ntry:\n    import tblib.pickling_support\nexcept ImportError:\n    tblib = None\n\n\nclass DebugSQLTextTestResult(unittest.TextTestResult):\n    def __init__(self, stream, descriptions, verbosity):\n        self.logger = logging.getLogger(\"django.db.backends\")\n        self.logger.setLevel(logging.DEBUG)\n        self.debug_sql_stream = None\n        super().__init__(stream, descriptions, verbosity)\n\n    def startTest(self, test):\n        self.debug_sql_stream = StringIO()\n        self.handler = logging.StreamHandler(self.debug_sql_stream)\n        self.logger.addHandler(self.handler)\n        super().startTest(test)\n\n    def stopTest(self, test):\n        super().stopTest(test)\n        self.logger.removeHandler(self.handler)\n        if self.showAll:\n            self.debug_sql_stream.seek(0)\n            self.stream.write(self.debug_sql_stream.read())\n            self.stream.writeln(self.separator2)\n\n    def addError(self, test, err):\n        super().addError(test, err)\n        if self.debug_sql_stream is None:\n            # Error before tests e.g. in setUpTestData().\n            sql = \"\"\n        else:\n            self.debug_sql_stream.seek(0)\n            sql = self.debug_sql_stream.read()\n        self.errors[-1] = self.errors[-1] + (sql,)\n\n    def addFailure(self, test, err):\n        super().addFailure(test, err)\n        self.debug_sql_stream.seek(0)\n        self.failures[-1] = self.failures[-1] + (self.debug_sql_stream.read(),)\n\n    def addSubTest(self, test, subtest, err):\n        super().addSubTest(test, subtest, err)\n        if err is not None:\n            self.debug_sql_stream.seek(0)\n            errors = (\n                self.failures\n                if issubclass(err[0], test.failureException)\n                else self.errors\n            )\n            errors[-1] = errors[-1] + (self.debug_sql_stream.read(),)\n\n    def printErrorList(self, flavour, errors):\n        for test, err, sql_debug in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln(\"%s: %s\" % (flavour, self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln(err)\n            self.stream.writeln(self.separator2)\n            self.stream.writeln(sql_debug)\n\n\nclass PDBDebugResult(unittest.TextTestResult):\n    \"\"\"\n    Custom result class that triggers a PDB session when an error or failure\n    occurs.\n    \"\"\"\n\n    def addError(self, test, err):\n        super().addError(test, err)\n        self.debug(err)\n\n    def addFailure(self, test, err):\n        super().addFailure(test, err)\n        self.debug(err)\n\n    def addSubTest(self, test, subtest, err):\n        if err is not None:\n            self.debug(err)\n        super().addSubTest(test, subtest, err)\n\n    def debug(self, error):\n        self._restoreStdout()\n        self.buffer = False\n        exc_type, exc_value, traceback = error\n        print(\"\\nOpening PDB: %r\" % exc_value)\n        if PY313:\n            pdb.post_mortem(exc_value)\n        else:\n            pdb.post_mortem(traceback)\n\n\nclass DummyList:\n    \"\"\"\n    Dummy list class for faking storage of results in unittest.TestResult.\n    \"\"\"\n\n    __slots__ = ()\n\n    def append(self, item):\n        pass\n\n\nclass RemoteTestResult(unittest.TestResult):\n    \"\"\"\n    Extend unittest.TestResult to record events in the child processes so they\n    can be replayed in the parent process. Events include things like which\n    tests succeeded or failed.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Fake storage of results to reduce memory usage. These are used by the\n        # unittest default methods, but here 'events' is used instead.\n        dummy_list = DummyList()\n        self.failures = dummy_list\n        self.errors = dummy_list\n        self.skipped = dummy_list\n        self.expectedFailures = dummy_list\n        self.unexpectedSuccesses = dummy_list\n\n        if tblib is not None:\n            tblib.pickling_support.install()\n        self.events = []\n\n    def __getstate__(self):\n        # Make this class picklable by removing the file-like buffer\n        # attributes. This is possible since they aren't used after unpickling\n        # after being sent to ParallelTestSuite.\n        state = self.__dict__.copy()\n        state.pop(\"_stdout_buffer\", None)\n        state.pop(\"_stderr_buffer\", None)\n        state.pop(\"_original_stdout\", None)\n        state.pop(\"_original_stderr\", None)\n        return state\n\n    @property\n    def test_index(self):\n        return self.testsRun - 1\n\n    def _confirm_picklable(self, obj):\n        \"\"\"\n        Confirm that obj can be pickled and unpickled as multiprocessing will\n        need to pickle the exception in the child process and unpickle it in\n        the parent process. Let the exception rise, if not.\n        \"\"\"\n        pickle.loads(pickle.dumps(obj))\n\n    def _print_unpicklable_subtest(self, test, subtest, pickle_exc):\n        print(\n            \"\"\"\nSubtest failed:\n\n    test: {}\n subtest: {}\n\nUnfortunately, the subtest that failed cannot be pickled, so the parallel\ntest runner cannot handle it cleanly. Here is the pickling error:\n\n> {}\n\nYou should re-run this test with --parallel=1 to reproduce the failure\nwith a cleaner failure message.\n\"\"\".format(\n                test, subtest, pickle_exc\n            )\n        )\n\n    def check_picklable(self, test, err):\n        # Ensure that sys.exc_info() tuples are picklable. This displays a\n        # clear multiprocessing.pool.RemoteTraceback generated in the child\n        # process instead of a multiprocessing.pool.MaybeEncodingError, making\n        # the root cause easier to figure out for users who aren't familiar\n        # with the multiprocessing module. Since we're in a forked process,\n        # our best chance to communicate with them is to print to stdout.\n        try:\n            self._confirm_picklable(err)\n        except Exception as exc:\n            original_exc_txt = repr(err[1])\n            original_exc_txt = textwrap.fill(\n                original_exc_txt, 75, initial_indent=\"    \", subsequent_indent=\"    \"\n            )\n            pickle_exc_txt = repr(exc)\n            pickle_exc_txt = textwrap.fill(\n                pickle_exc_txt, 75, initial_indent=\"    \", subsequent_indent=\"    \"\n            )\n            if tblib is None:\n                print(\n                    \"\"\"\n\n{} failed:\n\n{}\n\nUnfortunately, tracebacks cannot be pickled, making it impossible for the\nparallel test runner to handle this exception cleanly.\n\nIn order to see the traceback, you should install tblib:\n\n    python -m pip install tblib\n\"\"\".format(\n                        test, original_exc_txt\n                    )\n                )\n            else:\n                print(\n                    \"\"\"\n\n{} failed:\n\n{}\n\nUnfortunately, the exception it raised cannot be pickled, making it impossible\nfor the parallel test runner to handle it cleanly.\n\nHere's the error encountered while trying to pickle the exception:\n\n{}\n\nYou should re-run this test with the --parallel=1 option to reproduce the\nfailure and get a correct traceback.\n\"\"\".format(\n                        test, original_exc_txt, pickle_exc_txt\n                    )\n                )\n            raise\n\n    def check_subtest_picklable(self, test, subtest):\n        try:\n            self._confirm_picklable(subtest)\n        except Exception as exc:\n            self._print_unpicklable_subtest(test, subtest, exc)\n            raise\n\n    def startTestRun(self):\n        super().startTestRun()\n        self.events.append((\"startTestRun\",))\n\n    def stopTestRun(self):\n        super().stopTestRun()\n        self.events.append((\"stopTestRun\",))\n\n    def startTest(self, test):\n        super().startTest(test)\n        self.events.append((\"startTest\", self.test_index))\n\n    def stopTest(self, test):\n        super().stopTest(test)\n        self.events.append((\"stopTest\", self.test_index))\n\n    def addDuration(self, test, elapsed):\n        super().addDuration(test, elapsed)\n        self.events.append((\"addDuration\", self.test_index, elapsed))\n\n    def addError(self, test, err):\n        self.check_picklable(test, err)\n\n        event_occurred_before_first_test = self.test_index == -1\n        if event_occurred_before_first_test and isinstance(\n            test, unittest.suite._ErrorHolder\n        ):\n            self.events.append((\"addError\", self.test_index, test.id(), err))\n        else:\n            self.events.append((\"addError\", self.test_index, err))\n\n        super().addError(test, err)\n\n    def addFailure(self, test, err):\n        self.check_picklable(test, err)\n        self.events.append((\"addFailure\", self.test_index, err))\n        super().addFailure(test, err)\n\n    def addSubTest(self, test, subtest, err):\n        # Follow Python's implementation of unittest.TestResult.addSubTest() by\n        # not doing anything when a subtest is successful.\n        if err is not None:\n            # Call check_picklable() before check_subtest_picklable() since\n            # check_picklable() performs the tblib check.\n            self.check_picklable(test, err)\n            self.check_subtest_picklable(test, subtest)\n            self.events.append((\"addSubTest\", self.test_index, subtest, err))\n        super().addSubTest(test, subtest, err)\n\n    def addSuccess(self, test):\n        self.events.append((\"addSuccess\", self.test_index))\n        super().addSuccess(test)\n\n    def addSkip(self, test, reason):\n        self.events.append((\"addSkip\", self.test_index, reason))\n        super().addSkip(test, reason)\n\n    def addExpectedFailure(self, test, err):\n        # If tblib isn't installed, pickling the traceback will always fail.\n        # However we don't want tblib to be required for running the tests\n        # when they pass or fail as expected. Drop the traceback when an\n        # expected failure occurs.\n        if tblib is None:\n            err = err[0], err[1], None\n        self.check_picklable(test, err)\n        self.events.append((\"addExpectedFailure\", self.test_index, err))\n        super().addExpectedFailure(test, err)\n\n    def addUnexpectedSuccess(self, test):\n        self.events.append((\"addUnexpectedSuccess\", self.test_index))\n        super().addUnexpectedSuccess(test)\n\n    def wasSuccessful(self):\n        \"\"\"Tells whether or not this result was a success.\"\"\"\n        failure_types = {\"addError\", \"addFailure\", \"addSubTest\", \"addUnexpectedSuccess\"}\n        return all(e[0] not in failure_types for e in self.events)\n\n    def _exc_info_to_string(self, err, test):\n        # Make this method no-op. It only powers the default unittest behavior\n        # for recording errors, but this class pickles errors into 'events'\n        # instead.\n        return \"\"\n\n\nclass RemoteTestRunner:\n    \"\"\"\n    Run tests and record everything but don't display anything.\n\n    The implementation matches the unpythonic coding style of unittest2.\n    \"\"\"\n\n    resultclass = RemoteTestResult\n\n    def __init__(self, failfast=False, resultclass=None, buffer=False):\n        self.failfast = failfast\n        self.buffer = buffer\n        if resultclass is not None:\n            self.resultclass = resultclass\n\n    def run(self, test):\n        result = self.resultclass()\n        unittest.registerResult(result)\n        result.failfast = self.failfast\n        result.buffer = self.buffer\n        test(result)\n        return result\n\n\ndef get_max_test_processes():\n    \"\"\"\n    The maximum number of test processes when using the --parallel option.\n    \"\"\"\n    # The current implementation of the parallel test runner requires\n    # multiprocessing to start subprocesses with fork() or spawn().\n    if multiprocessing.get_start_method() not in {\"fork\", \"spawn\"}:\n        return 1\n    try:\n        return int(os.environ[\"DJANGO_TEST_PROCESSES\"])\n    except KeyError:\n        return multiprocessing.cpu_count()\n\n\ndef parallel_type(value):\n    \"\"\"Parse value passed to the --parallel option.\"\"\"\n    if value == \"auto\":\n        return value\n    try:\n        return int(value)\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            f\"{value!r} is not an integer or the string 'auto'\"\n        )\n\n\n_worker_id = 0\n\n\ndef _init_worker(\n    counter,\n    initial_settings=None,\n    serialized_contents=None,\n    process_setup=None,\n    process_setup_args=None,\n    debug_mode=None,\n    used_aliases=None,\n):\n    \"\"\"\n    Switch to databases dedicated to this worker.\n\n    This helper lives at module-level because of the multiprocessing module's\n    requirements.\n    \"\"\"\n\n    global _worker_id\n\n    with counter.get_lock():\n        counter.value += 1\n        _worker_id = counter.value\n\n    start_method = multiprocessing.get_start_method()\n\n    if start_method == \"spawn\":\n        if process_setup and callable(process_setup):\n            if process_setup_args is None:\n                process_setup_args = ()\n            process_setup(*process_setup_args)\n        django.setup()\n        setup_test_environment(debug=debug_mode)\n\n    db_aliases = used_aliases if used_aliases is not None else connections\n    for alias in db_aliases:\n        connection = connections[alias]\n        if start_method == \"spawn\":\n            # Restore initial settings in spawned processes.\n            connection.settings_dict.update(initial_settings[alias])\n            if value := serialized_contents.get(alias):\n                connection._test_serialized_contents = value\n        connection.creation.setup_worker_connection(_worker_id)\n\n\ndef _run_subsuite(args):\n    \"\"\"\n    Run a suite of tests with a RemoteTestRunner and return a RemoteTestResult.\n\n    This helper lives at module-level and its arguments are wrapped in a tuple\n    because of the multiprocessing module's requirements.\n    \"\"\"\n    runner_class, subsuite_index, subsuite, failfast, buffer = args\n    runner = runner_class(failfast=failfast, buffer=buffer)\n    result = runner.run(subsuite)\n    return subsuite_index, result.events\n\n\ndef _process_setup_stub(*args):\n    \"\"\"Stub method to simplify run() implementation.\"\"\"\n    pass\n\n\nclass ParallelTestSuite(unittest.TestSuite):\n    \"\"\"\n    Run a series of tests in parallel in several processes.\n\n    While the unittest module's documentation implies that orchestrating the\n    execution of tests is the responsibility of the test runner, in practice,\n    it appears that TestRunner classes are more concerned with formatting and\n    displaying test results.\n\n    Since there are fewer use cases for customizing TestSuite than TestRunner,\n    implementing parallelization at the level of the TestSuite improves\n    interoperability with existing custom test runners. A single instance of a\n    test runner can still collect results from all tests without being aware\n    that they have been run in parallel.\n    \"\"\"\n\n    # In case someone wants to modify these in a subclass.\n    init_worker = _init_worker\n    process_setup = _process_setup_stub\n    process_setup_args = ()\n    run_subsuite = _run_subsuite\n    runner_class = RemoteTestRunner\n\n    def __init__(\n        self, subsuites, processes, failfast=False, debug_mode=False, buffer=False\n    ):\n        self.subsuites = subsuites\n        self.processes = processes\n        self.failfast = failfast\n        self.debug_mode = debug_mode\n        self.buffer = buffer\n        self.initial_settings = None\n        self.serialized_contents = None\n        self.used_aliases = None\n        super().__init__()\n\n    def run(self, result):\n        \"\"\"\n        Distribute TestCases across workers.\n\n        Return an identifier of each TestCase with its result in order to use\n        imap_unordered to show results as soon as they're available.\n\n        To minimize pickling errors when getting results from workers:\n\n        - pass back numeric indexes in self.subsuites instead of tests\n        - make tracebacks picklable with tblib, if available\n\n        Even with tblib, errors may still occur for dynamically created\n        exception classes which cannot be unpickled.\n        \"\"\"\n        self.initialize_suite()\n        counter = multiprocessing.Value(ctypes.c_int, 0)\n        pool = multiprocessing.Pool(\n            processes=self.processes,\n            initializer=self.init_worker.__func__,\n            initargs=[\n                counter,\n                self.initial_settings,\n                self.serialized_contents,\n                self.process_setup.__func__,\n                self.process_setup_args,\n                self.debug_mode,\n                self.used_aliases,\n            ],\n        )\n        args = [\n            (self.runner_class, index, subsuite, self.failfast, self.buffer)\n            for index, subsuite in enumerate(self.subsuites)\n        ]\n        test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n\n        while True:\n            if result.shouldStop:\n                pool.terminate()\n                break\n\n            try:\n                subsuite_index, events = test_results.next(timeout=0.1)\n            except multiprocessing.TimeoutError:\n                continue\n            except StopIteration:\n                pool.close()\n                break\n\n            tests = list(self.subsuites[subsuite_index])\n            for event in events:\n                self.handle_event(result, tests, event)\n\n        pool.join()\n\n        return result\n\n    def handle_event(self, result, tests, event):\n        event_name = event[0]\n        handler = getattr(result, event_name, None)\n        if handler is None:\n            return\n        test_index = event[1]\n        event_occurred_before_first_test = test_index == -1\n        if (\n            event_name == \"addError\"\n            and event_occurred_before_first_test\n            and len(event) >= 4\n        ):\n            test_id = event[2]\n            test = unittest.suite._ErrorHolder(test_id)\n            args = event[3:]\n        else:\n            test = tests[test_index]\n            args = event[2:]\n        handler(test, *args)\n\n    def __iter__(self):\n        return iter(self.subsuites)\n\n    def initialize_suite(self):\n        if multiprocessing.get_start_method() == \"spawn\":\n            self.initial_settings = {\n                alias: connections[alias].settings_dict for alias in connections\n            }\n            self.serialized_contents = {\n                alias: connections[alias]._test_serialized_contents\n                for alias in connections\n                if alias in self.serialized_aliases\n            }\n\n\nclass Shuffler:\n    \"\"\"\n    This class implements shuffling with a special consistency property.\n    Consistency means that, for a given seed and key function, if two sets of\n    items are shuffled, the resulting order will agree on the intersection of\n    the two sets. For example, if items are removed from an original set, the\n    shuffled order for the new set will be the shuffled order of the original\n    set restricted to the smaller set.\n    \"\"\"\n\n    # This doesn't need to be cryptographically strong, so use what's fastest.\n    hash_algorithm = \"md5\"\n\n    @classmethod\n    def _hash_text(cls, text):\n        h = hashlib.new(cls.hash_algorithm, usedforsecurity=False)\n        h.update(text.encode(\"utf-8\"))\n        return h.hexdigest()\n\n    def __init__(self, seed=None):\n        if seed is None:\n            # Limit seeds to 10 digits for simpler output.\n            seed = random.randint(0, 10**10 - 1)\n            seed_source = \"generated\"\n        else:\n            seed_source = \"given\"\n        self.seed = seed\n        self.seed_source = seed_source\n\n    @property\n    def seed_display(self):\n        return f\"{self.seed!r} ({self.seed_source})\"\n\n    def _hash_item(self, item, key):\n        text = \"{}{}\".format(self.seed, key(item))\n        return self._hash_text(text)\n\n    def shuffle(self, items, key):\n        \"\"\"\n        Return a new list of the items in a shuffled order.\n\n        The `key` is a function that accepts an item in `items` and returns\n        a string unique for that item that can be viewed as a string id. The\n        order of the return value is deterministic. It depends on the seed\n        and key function but not on the original order.\n        \"\"\"\n        hashes = {}\n        for item in items:\n            hashed = self._hash_item(item, key)\n            if hashed in hashes:\n                msg = \"item {!r} has same hash {!r} as item {!r}\".format(\n                    item,\n                    hashed,\n                    hashes[hashed],\n                )\n                raise RuntimeError(msg)\n            hashes[hashed] = item\n        return [hashes[hashed] for hashed in sorted(hashes)]\n\n\nclass DiscoverRunner:\n    \"\"\"A Django test runner that uses unittest2 test discovery.\"\"\"\n\n    test_suite = unittest.TestSuite\n    parallel_test_suite = ParallelTestSuite\n    test_runner = unittest.TextTestRunner\n    test_loader = unittest.defaultTestLoader\n    reorder_by = (TestCase, SimpleTestCase)\n\n    def __init__(\n        self,\n        pattern=None,\n        top_level=None,\n        verbosity=1,\n        interactive=True,\n        failfast=False,\n        keepdb=False,\n        reverse=False,\n        debug_mode=False,\n        debug_sql=False,\n        parallel=0,\n        tags=None,\n        exclude_tags=None,\n        test_name_patterns=None,\n        pdb=False,\n        buffer=False,\n        enable_faulthandler=True,\n        timing=False,\n        shuffle=False,\n        logger=None,\n        durations=None,\n        **kwargs,\n    ):\n        self.pattern = pattern\n        self.top_level = top_level\n        self.verbosity = verbosity\n        self.interactive = interactive\n        self.failfast = failfast\n        self.keepdb = keepdb\n        self.reverse = reverse\n        self.debug_mode = debug_mode\n        self.debug_sql = debug_sql\n        self.parallel = parallel\n        self.tags = set(tags or [])\n        self.exclude_tags = set(exclude_tags or [])\n        if not faulthandler.is_enabled() and enable_faulthandler:\n            try:\n                faulthandler.enable(file=sys.stderr.fileno())\n            except (AttributeError, io.UnsupportedOperation):\n                faulthandler.enable(file=sys.__stderr__.fileno())\n        self.pdb = pdb\n        if self.pdb and self.parallel > 1:\n            raise ValueError(\n                \"You cannot use --pdb with parallel tests; pass --parallel=1 to use it.\"\n            )\n        self.buffer = buffer\n        self.test_name_patterns = None\n        self.time_keeper = TimeKeeper() if timing else NullTimeKeeper()\n        if test_name_patterns:\n            # unittest does not export the _convert_select_pattern function\n            # that converts command-line arguments to patterns.\n            self.test_name_patterns = {\n                pattern if \"*\" in pattern else \"*%s*\" % pattern\n                for pattern in test_name_patterns\n            }\n        self.shuffle = shuffle\n        self._shuffler = None\n        self.logger = logger\n        self.durations = durations\n\n    @classmethod\n    def add_arguments(cls, parser):\n        parser.add_argument(\n            \"--failfast\",\n            action=\"store_true\",\n            help=\"Stops the test suite after the first failure.\",\n        )\n        parser.add_argument(\n            \"-t\",\n            \"--top-level-directory\",\n            dest=\"top_level\",\n            help=\"Top level of project for unittest discovery.\",\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--pattern\",\n            default=\"test*.py\",\n            help=\"The test matching pattern. Defaults to test*.py.\",\n        )\n        parser.add_argument(\n            \"--keepdb\", action=\"store_true\", help=\"Preserves the test DB between runs.\"\n        )\n        parser.add_argument(\n            \"--shuffle\",\n            nargs=\"?\",\n            default=False,\n            type=int,\n            metavar=\"SEED\",\n            help=\"Shuffles test case order.\",\n        )\n        parser.add_argument(\n            \"-r\",\n            \"--reverse\",\n            action=\"store_true\",\n            help=\"Reverses test case order.\",\n        )\n        parser.add_argument(\n            \"--debug-mode\",\n            action=\"store_true\",\n            help=\"Sets settings.DEBUG to True.\",\n        )\n        parser.add_argument(\n            \"-d\",\n            \"--debug-sql\",\n            action=\"store_true\",\n            help=\"Prints logged SQL queries on failure.\",\n        )\n        parser.add_argument(\n            \"--parallel\",\n            nargs=\"?\",\n            const=\"auto\",\n            default=0,\n            type=parallel_type,\n            metavar=\"N\",\n            help=(\n                \"Run tests using up to N parallel processes. Use the value \"\n                '\"auto\" to run one test process for each processor core.'\n            ),\n        )\n        parser.add_argument(\n            \"--tag\",\n            action=\"append\",\n            dest=\"tags\",\n            help=\"Run only tests with the specified tag. Can be used multiple times.\",\n        )\n        parser.add_argument(\n            \"--exclude-tag\",\n            action=\"append\",\n            dest=\"exclude_tags\",\n            help=\"Do not run tests with the specified tag. Can be used multiple times.\",\n        )\n        parser.add_argument(\n            \"--pdb\",\n            action=\"store_true\",\n            help=\"Runs a debugger (pdb, or ipdb if installed) on error or failure.\",\n        )\n        parser.add_argument(\n            \"-b\",\n            \"--buffer\",\n            action=\"store_true\",\n            help=\"Discard output from passing tests.\",\n        )\n        parser.add_argument(\n            \"--no-faulthandler\",\n            action=\"store_false\",\n            dest=\"enable_faulthandler\",\n            help=\"Disables the Python faulthandler module during tests.\",\n        )\n        parser.add_argument(\n            \"--timing\",\n            action=\"store_true\",\n            help=(\"Output timings, including database set up and total run time.\"),\n        )\n        parser.add_argument(\n            \"-k\",\n            action=\"append\",\n            dest=\"test_name_patterns\",\n            help=(\n                \"Only run test methods and classes that match the pattern \"\n                \"or substring. Can be used multiple times. Same as \"\n                \"unittest -k option.\"\n            ),\n        )\n        parser.add_argument(\n            \"--durations\",\n            dest=\"durations\",\n            type=int,\n            default=None,\n            metavar=\"N\",\n            help=\"Show the N slowest test cases (N=0 for all).\",\n        )\n\n    @property\n    def shuffle_seed(self):\n        if self._shuffler is None:\n            return None\n        return self._shuffler.seed\n\n    def log(self, msg, level=None):\n        \"\"\"\n        Log the message at the given logging level (the default is INFO).\n\n        If a logger isn't set, the message is instead printed to the console,\n        respecting the configured verbosity. A verbosity of 0 prints no output,\n        a verbosity of 1 prints INFO and above, and a verbosity of 2 or higher\n        prints all levels.\n        \"\"\"\n        if level is None:\n            level = logging.INFO\n        if self.logger is None:\n            if self.verbosity <= 0 or (self.verbosity == 1 and level < logging.INFO):\n                return\n            print(msg)\n        else:\n            self.logger.log(level, msg)\n\n    def setup_test_environment(self, **kwargs):\n        setup_test_environment(debug=self.debug_mode)\n        unittest.installHandler()\n\n    def setup_shuffler(self):\n        if self.shuffle is False:\n            return\n        shuffler = Shuffler(seed=self.shuffle)\n        self.log(f\"Using shuffle seed: {shuffler.seed_display}\")\n        self._shuffler = shuffler\n\n    @contextmanager\n    def load_with_patterns(self):\n        original_test_name_patterns = self.test_loader.testNamePatterns\n        self.test_loader.testNamePatterns = self.test_name_patterns\n        try:\n            yield\n        finally:\n            # Restore the original patterns.\n            self.test_loader.testNamePatterns = original_test_name_patterns\n\n    def load_tests_for_label(self, label, discover_kwargs):\n        label_as_path = os.path.abspath(label)\n        tests = None\n\n        # If a module, or \"module.ClassName[.method_name]\", just run those.\n        if not os.path.exists(label_as_path):\n            with self.load_with_patterns():\n                tests = self.test_loader.loadTestsFromName(label)\n            if tests.countTestCases():\n                return tests\n        # Try discovery if \"label\" is a package or directory.\n        is_importable, is_package = try_importing(label)\n        if is_importable:\n            if not is_package:\n                return tests\n        elif not os.path.isdir(label_as_path):\n            if os.path.exists(label_as_path):\n                assert tests is None\n                raise RuntimeError(\n                    f\"One of the test labels is a path to a file: {label!r}, \"\n                    f\"which is not supported. Use a dotted module name or \"\n                    f\"path to a directory instead.\"\n                )\n            return tests\n\n        kwargs = discover_kwargs.copy()\n        if os.path.isdir(label_as_path) and not self.top_level:\n            kwargs[\"top_level_dir\"] = find_top_level(label_as_path)\n\n        with self.load_with_patterns():\n            tests = self.test_loader.discover(start_dir=label, **kwargs)\n\n        # Make unittest forget the top-level dir it calculated from this run,\n        # to support running tests from two different top-levels.\n        self.test_loader._top_level_dir = None\n        return tests\n\n    def build_suite(self, test_labels=None, **kwargs):\n        test_labels = test_labels or [\".\"]\n\n        discover_kwargs = {}\n        if self.pattern is not None:\n            discover_kwargs[\"pattern\"] = self.pattern\n        if self.top_level is not None:\n            discover_kwargs[\"top_level_dir\"] = self.top_level\n        self.setup_shuffler()\n\n        all_tests = []\n        for label in test_labels:\n            tests = self.load_tests_for_label(label, discover_kwargs)\n            all_tests.extend(iter_test_cases(tests))\n\n        if self.tags or self.exclude_tags:\n            if self.tags:\n                self.log(\n                    \"Including test tag(s): %s.\" % \", \".join(sorted(self.tags)),\n                    level=logging.DEBUG,\n                )\n            if self.exclude_tags:\n                self.log(\n                    \"Excluding test tag(s): %s.\" % \", \".join(sorted(self.exclude_tags)),\n                    level=logging.DEBUG,\n                )\n            all_tests = filter_tests_by_tags(all_tests, self.tags, self.exclude_tags)\n\n        # Put the failures detected at load time first for quicker feedback.\n        # _FailedTest objects include things like test modules that couldn't be\n        # found or that couldn't be loaded due to syntax errors.\n        test_types = (unittest.loader._FailedTest, *self.reorder_by)\n        all_tests = list(\n            reorder_tests(\n                all_tests,\n                test_types,\n                shuffler=self._shuffler,\n                reverse=self.reverse,\n            )\n        )\n        self.log(\"Found %d test(s).\" % len(all_tests))\n        suite = self.test_suite(all_tests)\n\n        if self.parallel > 1:\n            subsuites = partition_suite_by_case(suite)\n            # Since tests are distributed across processes on a per-TestCase\n            # basis, there's no need for more processes than TestCases.\n            processes = min(self.parallel, len(subsuites))\n            # Update also \"parallel\" because it's used to determine the number\n            # of test databases.\n            self.parallel = processes\n            if processes > 1:\n                suite = self.parallel_test_suite(\n                    subsuites,\n                    processes,\n                    self.failfast,\n                    self.debug_mode,\n                    self.buffer,\n                )\n        return suite\n\n    def setup_databases(self, **kwargs):\n        return _setup_databases(\n            self.verbosity,\n            self.interactive,\n            time_keeper=self.time_keeper,\n            keepdb=self.keepdb,\n            debug_sql=self.debug_sql,\n            parallel=self.parallel,\n            **kwargs,\n        )\n\n    def get_resultclass(self):\n        if self.debug_sql:\n            return DebugSQLTextTestResult\n        elif self.pdb:\n            return PDBDebugResult\n\n    def get_test_runner_kwargs(self):\n        kwargs = {\n            \"failfast\": self.failfast,\n            \"resultclass\": self.get_resultclass(),\n            \"verbosity\": self.verbosity,\n            \"buffer\": self.buffer,\n            \"durations\": self.durations,\n        }\n        return kwargs\n\n    def run_checks(self, databases):\n        # Checks are run after database creation since some checks require\n        # database access.\n        call_command(\"check\", verbosity=self.verbosity, databases=databases)\n\n    def run_suite(self, suite, **kwargs):\n        kwargs = self.get_test_runner_kwargs()\n        runner = self.test_runner(**kwargs)\n        try:\n            return runner.run(suite)\n        finally:\n            if self._shuffler is not None:\n                seed_display = self._shuffler.seed_display\n                self.log(f\"Used shuffle seed: {seed_display}\")\n\n    def teardown_databases(self, old_config, **kwargs):\n        \"\"\"Destroy all the non-mirror databases.\"\"\"\n        _teardown_databases(\n            old_config,\n            verbosity=self.verbosity,\n            parallel=self.parallel,\n            keepdb=self.keepdb,\n        )\n\n    def teardown_test_environment(self, **kwargs):\n        unittest.removeHandler()\n        teardown_test_environment()\n\n    def suite_result(self, suite, result, **kwargs):\n        return (\n            len(result.failures) + len(result.errors) + len(result.unexpectedSuccesses)\n        )\n\n    def _get_databases(self, suite):\n        databases = {}\n        for test in iter_test_cases(suite):\n            test_databases = getattr(test, \"databases\", None)\n            if test_databases == \"__all__\":\n                test_databases = connections\n            if test_databases:\n                serialized_rollback = getattr(test, \"serialized_rollback\", False)\n                databases.update(\n                    (alias, serialized_rollback or databases.get(alias, False))\n                    for alias in test_databases\n                )\n        return databases\n\n    def get_databases(self, suite):\n        databases = self._get_databases(suite)\n        unused_databases = [alias for alias in connections if alias not in databases]\n        if unused_databases:\n            self.log(\n                \"Skipping setup of unused database(s): %s.\"\n                % \", \".join(sorted(unused_databases)),\n                level=logging.DEBUG,\n            )\n        return databases\n\n    def run_tests(self, test_labels, **kwargs):\n        \"\"\"\n        Run the unit tests for all the test labels in the provided list.\n\n        Test labels should be dotted Python paths to test modules, test\n        classes, or test methods.\n\n        Return the number of tests that failed.\n        \"\"\"\n        self.setup_test_environment()\n        suite = self.build_suite(test_labels)\n        databases = self.get_databases(suite)\n        suite.serialized_aliases = set(\n            alias for alias, serialize in databases.items() if serialize\n        )\n        suite.used_aliases = set(databases)\n        with self.time_keeper.timed(\"Total database setup\"):\n            old_config = self.setup_databases(\n                aliases=databases,\n                serialized_aliases=suite.serialized_aliases,\n            )\n        run_failed = False\n        try:\n            self.run_checks(databases)\n            result = self.run_suite(suite)\n        except Exception:\n            run_failed = True\n            raise\n        finally:\n            try:\n                with self.time_keeper.timed(\"Total database teardown\"):\n                    self.teardown_databases(old_config)\n                self.teardown_test_environment()\n            except Exception:\n                # Silence teardown exceptions if an exception was raised during\n                # runs to avoid shadowing it.\n                if not run_failed:\n                    raise\n        self.time_keeper.print_results()\n        return self.suite_result(suite, result)\n\n\ndef try_importing(label):\n    \"\"\"\n    Try importing a test label, and return (is_importable, is_package).\n\n    Relative labels like \".\" and \"..\" are seen as directories.\n    \"\"\"\n    try:\n        mod = import_module(label)\n    except (ImportError, TypeError):\n        return (False, False)\n\n    return (True, hasattr(mod, \"__path__\"))\n\n\ndef find_top_level(top_level):\n    # Try to be a bit smarter than unittest about finding the default top-level\n    # for a given directory path, to avoid breaking relative imports.\n    # (Unittest's default is to set top-level equal to the path, which means\n    # relative imports will result in \"Attempted relative import in\n    # non-package.\").\n\n    # We'd be happy to skip this and require dotted module paths (which don't\n    # cause this problem) instead of file paths (which do), but in the case of\n    # a directory in the cwd, which would be equally valid if considered as a\n    # top-level module or as a directory path, unittest unfortunately prefers\n    # the latter.\n    while True:\n        init_py = os.path.join(top_level, \"__init__.py\")\n        if not os.path.exists(init_py):\n            break\n        try_next = os.path.dirname(top_level)\n        if try_next == top_level:\n            # __init__.py all the way down? give up.\n            break\n        top_level = try_next\n    return top_level\n\n\ndef _class_shuffle_key(cls):\n    return f\"{cls.__module__}.{cls.__qualname__}\"\n\n\ndef shuffle_tests(tests, shuffler):\n    \"\"\"\n    Return an iterator over the given tests in a shuffled order, keeping tests\n    next to other tests of their class.\n\n    `tests` should be an iterable of tests.\n    \"\"\"\n    tests_by_type = {}\n    for _, class_tests in itertools.groupby(tests, type):\n        class_tests = list(class_tests)\n        test_type = type(class_tests[0])\n        class_tests = shuffler.shuffle(class_tests, key=lambda test: test.id())\n        tests_by_type[test_type] = class_tests\n\n    classes = shuffler.shuffle(tests_by_type, key=_class_shuffle_key)\n\n    return itertools.chain(*(tests_by_type[cls] for cls in classes))\n\n\ndef reorder_test_bin(tests, shuffler=None, reverse=False):\n    \"\"\"\n    Return an iterator that reorders the given tests, keeping tests next to\n    other tests of their class.\n\n    `tests` should be an iterable of tests that supports reversed().\n    \"\"\"\n    if shuffler is None:\n        if reverse:\n            return reversed(tests)\n        # The function must return an iterator.\n        return iter(tests)\n\n    tests = shuffle_tests(tests, shuffler)\n    if not reverse:\n        return tests\n    # Arguments to reversed() must be reversible.\n    return reversed(list(tests))\n\n\ndef reorder_tests(tests, classes, reverse=False, shuffler=None):\n    \"\"\"\n    Reorder an iterable of tests, grouping by the given TestCase classes.\n\n    This function also removes any duplicates and reorders so that tests of the\n    same type are consecutive.\n\n    The result is returned as an iterator. `classes` is a sequence of types.\n    Tests that are instances of `classes[0]` are grouped first, followed by\n    instances of `classes[1]`, etc. Tests that are not instances of any of the\n    classes are grouped last.\n\n    If `reverse` is True, the tests within each `classes` group are reversed,\n    but without reversing the order of `classes` itself.\n\n    The `shuffler` argument is an optional instance of this module's `Shuffler`\n    class. If provided, tests will be shuffled within each `classes` group, but\n    keeping tests with other tests of their TestCase class. Reversing is\n    applied after shuffling to allow reversing the same random order.\n    \"\"\"\n    # Each bin maps TestCase class to OrderedSet of tests. This permits tests\n    # to be grouped by TestCase class even if provided non-consecutively.\n    bins = [defaultdict(OrderedSet) for i in range(len(classes) + 1)]\n    *class_bins, last_bin = bins\n\n    for test in tests:\n        for test_bin, test_class in zip(class_bins, classes):\n            if isinstance(test, test_class):\n                break\n        else:\n            test_bin = last_bin\n        test_bin[type(test)].add(test)\n\n    for test_bin in bins:\n        # Call list() since reorder_test_bin()'s input must support reversed().\n        tests = list(itertools.chain.from_iterable(test_bin.values()))\n        yield from reorder_test_bin(tests, shuffler=shuffler, reverse=reverse)\n\n\ndef partition_suite_by_case(suite):\n    \"\"\"Partition a test suite by TestCase, preserving the order of tests.\"\"\"\n    suite_class = type(suite)\n    all_tests = iter_test_cases(suite)\n    return [suite_class(tests) for _, tests in itertools.groupby(all_tests, type)]\n\n\ndef test_match_tags(test, tags, exclude_tags):\n    if isinstance(test, unittest.loader._FailedTest):\n        # Tests that couldn't load always match to prevent tests from falsely\n        # passing due e.g. to syntax errors.\n        return True\n    test_tags = set(getattr(test, \"tags\", []))\n    test_fn_name = getattr(test, \"_testMethodName\", str(test))\n    if hasattr(test, test_fn_name):\n        test_fn = getattr(test, test_fn_name)\n        test_fn_tags = list(getattr(test_fn, \"tags\", []))\n        test_tags = test_tags.union(test_fn_tags)\n    if tags and test_tags.isdisjoint(tags):\n        return False\n    return test_tags.isdisjoint(exclude_tags)\n\n\ndef filter_tests_by_tags(tests, tags, exclude_tags):\n    \"\"\"Return the matching tests as an iterator.\"\"\"\n    return (test for test in tests if test_match_tags(test, tags, exclude_tags))\n"
  },
  "requirements": null
}