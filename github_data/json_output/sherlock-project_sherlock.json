{
  "repo_name": "sherlock-project/sherlock",
  "repo_url": "https://github.com/sherlock-project/sherlock",
  "description": "Hunt down social media accounts by username across social networks",
  "stars": 63091,
  "language": "Python",
  "created_at": "2018-12-24T14:30:48Z",
  "updated_at": "2025-03-19T06:42:48Z",
  "files": {
    "tests/conftest.py": "import os\nimport json\nimport urllib\nimport pytest\nfrom sherlock_project.sites import SitesInformation\n\n@pytest.fixture()\ndef sites_obj():\n    sites_obj = SitesInformation(data_file_path=os.path.join(os.path.dirname(__file__), \"../sherlock_project/resources/data.json\"))\n    yield sites_obj\n\n@pytest.fixture(scope=\"session\")\ndef sites_info():\n    sites_obj = SitesInformation(data_file_path=os.path.join(os.path.dirname(__file__), \"../sherlock_project/resources/data.json\"))\n    sites_iterable = {site.name: site.information for site in sites_obj}\n    yield sites_iterable\n\n@pytest.fixture(scope=\"session\")\ndef remote_schema():\n    schema_url: str = 'https://raw.githubusercontent.com/sherlock-project/sherlock/master/sherlock_project/resources/data.schema.json'\n    with urllib.request.urlopen(schema_url) as remoteschema:\n        schemadat = json.load(remoteschema)\n    yield schemadat\n",
    "tests/few_test_basic.py": "import sherlock_project\n\n#from sherlock.sites import SitesInformation\n#local_manifest = data_file_path=os.path.join(os.path.dirname(__file__), \"../sherlock/resources/data.json\")\n\ndef test_username_via_message():\n    sherlock_project.__main__(\"--version\")\n",
    "tests/sherlock_interactives.py": "import os\nimport platform\nimport re\nimport subprocess\n\nclass Interactives:\n    def run_cli(args:str = \"\") -> str:\n        \"\"\"Pass arguments to Sherlock as a normal user on the command line\"\"\"\n        # Adapt for platform differences (Windows likes to be special)\n        if platform.system() == \"Windows\":\n            command:str = f\"py -m sherlock_project {args}\"\n        else:\n            command:str = f\"sherlock {args}\"\n\n        proc_out:str = \"\"\n        try:\n            proc_out = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)\n            return proc_out.decode()\n        except subprocess.CalledProcessError as e:\n            raise InteractivesSubprocessError(e.output.decode())\n\n\n    def walk_sherlock_for_files_with(pattern: str) -> list[str]:\n        \"\"\"Check all files within the Sherlock package for matching patterns\"\"\"\n        pattern:re.Pattern = re.compile(pattern)\n        matching_files:list[str] = []\n        for root, dirs, files in os.walk(\"sherlock_project\"):\n            for file in files:\n                file_path = os.path.join(root,file)\n                if \"__pycache__\" in file_path:\n                    continue\n                with open(file_path, 'r', errors='ignore') as f:\n                    if pattern.search(f.read()):\n                        matching_files.append(file_path)\n        return matching_files\n\nclass InteractivesSubprocessError(Exception):\n    pass\n",
    "tests/test_manifest.py": "import os\nimport json\nimport pytest\nfrom jsonschema import validate\n\ndef test_validate_manifest_against_local_schema():\n    \"\"\"Ensures that the manifest matches the local schema, for situations where the schema is being changed.\"\"\"\n    json_relative: str = '../sherlock_project/resources/data.json'\n    schema_relative: str = '../sherlock_project/resources/data.schema.json'\n    \n    json_path: str = os.path.join(os.path.dirname(__file__), json_relative)\n    schema_path: str = os.path.join(os.path.dirname(__file__), schema_relative)\n\n    with open(json_path, 'r') as f:\n        jsondat = json.load(f)\n    with open(schema_path, 'r') as f:\n        schemadat = json.load(f)\n\n    validate(instance=jsondat, schema=schemadat)\n\n\n@pytest.mark.online\ndef test_validate_manifest_against_remote_schema(remote_schema):\n    \"\"\"Ensures that the manifest matches the remote schema, so as to not unexpectedly break clients.\"\"\"\n    json_relative: str = '../sherlock_project/resources/data.json'\n    json_path: str = os.path.join(os.path.dirname(__file__), json_relative)\n\n    with open(json_path, 'r') as f:\n        jsondat = json.load(f)\n\n    validate(instance=jsondat, schema=remote_schema)\n\n# Ensure that the expected values are beind returned by the site list\n@pytest.mark.parametrize(\"target_name,target_expected_err_type\", [\n    ('GitHub', 'status_code'),\n    ('GitLab', 'message'),\n])\ndef test_site_list_iterability (sites_info, target_name, target_expected_err_type):\n    assert sites_info[target_name]['errorType'] == target_expected_err_type\n",
    "tests/test_probes.py": "import pytest\nimport random\nimport string\nimport re\nfrom sherlock_project.sherlock import sherlock\nfrom sherlock_project.notify import QueryNotify\nfrom sherlock_project.result import QueryStatus\n#from sherlock_interactives import Interactives\n\n\ndef simple_query(sites_info: dict, site: str, username: str) -> QueryStatus:\n    query_notify = QueryNotify()\n    site_data: dict = {}\n    site_data[site] = sites_info[site]\n    return sherlock(\n        username=username,\n        site_data=site_data,\n        query_notify=query_notify,\n    )[site]['status'].status\n\n\n@pytest.mark.online\nclass TestLiveTargets:\n    \"\"\"Actively test probes against live and trusted targets\"\"\"\n    # Known positives should only use sites trusted to be reliable and unchanging\n    @pytest.mark.parametrize('site,username',[\n        ('GitLab', 'ppfeister'),\n        ('AllMyLinks', 'blue'),\n    ])\n    def test_known_positives_via_message(self, sites_info, site, username):\n        assert simple_query(sites_info=sites_info, site=site, username=username) is QueryStatus.CLAIMED\n\n\n    # Known positives should only use sites trusted to be reliable and unchanging\n    @pytest.mark.parametrize('site,username',[\n        ('GitHub', 'ppfeister'),\n        ('GitHub', 'sherlock-project'),\n        ('Docker Hub', 'ppfeister'),\n        ('Docker Hub', 'sherlock'),\n    ])\n    def test_known_positives_via_status_code(self, sites_info, site, username):\n        assert simple_query(sites_info=sites_info, site=site, username=username) is QueryStatus.CLAIMED\n\n\n    # Known positives should only use sites trusted to be reliable and unchanging\n    @pytest.mark.parametrize('site,username',[\n        ('Keybase', 'blue'),\n        ('devRant', 'blue'),\n    ])\n    def test_known_positives_via_response_url(self, sites_info, site, username):\n        assert simple_query(sites_info=sites_info, site=site, username=username) is QueryStatus.CLAIMED\n\n\n    # Randomly generate usernames of high length and test for positive availability\n    # Randomly generated usernames should be simple alnum for simplicity and high\n    # compatibility. Several attempts may be made ~just in case~ a real username is\n    # generated.\n    @pytest.mark.parametrize('site,random_len',[\n        ('GitLab', 255),\n        ('Codecademy', 30)\n    ])\n    def test_likely_negatives_via_message(self, sites_info, site, random_len):\n        num_attempts: int = 3\n        attempted_usernames: list[str] = []\n        status: QueryStatus = QueryStatus.CLAIMED\n        for i in range(num_attempts):\n            acceptable_types = string.ascii_letters + string.digits\n            random_handle = ''.join(random.choice(acceptable_types) for _ in range (random_len))\n            attempted_usernames.append(random_handle)\n            status = simple_query(sites_info=sites_info, site=site, username=random_handle)\n            if status is QueryStatus.AVAILABLE:\n                break\n        assert status is QueryStatus.AVAILABLE, f\"Could not validate available username after {num_attempts} attempts with randomly generated usernames {attempted_usernames}.\"\n\n\n    # Randomly generate usernames of high length and test for positive availability\n    # Randomly generated usernames should be simple alnum for simplicity and high\n    # compatibility. Several attempts may be made ~just in case~ a real username is\n    # generated.\n    @pytest.mark.parametrize('site,random_len',[\n        ('GitHub', 39),\n        ('Docker Hub', 30)\n    ])\n    def test_likely_negatives_via_status_code(self, sites_info, site, random_len):\n        num_attempts: int = 3\n        attempted_usernames: list[str] = []\n        status: QueryStatus = QueryStatus.CLAIMED\n        for i in range(num_attempts):\n            acceptable_types = string.ascii_letters + string.digits\n            random_handle = ''.join(random.choice(acceptable_types) for _ in range (random_len))\n            attempted_usernames.append(random_handle)\n            status = simple_query(sites_info=sites_info, site=site, username=random_handle)\n            if status is QueryStatus.AVAILABLE:\n                break\n        assert status is QueryStatus.AVAILABLE, f\"Could not validate available username after {num_attempts} attempts with randomly generated usernames {attempted_usernames}.\"\n\n\ndef test_username_illegal_regex(sites_info):\n    site: str = 'BitBucket'\n    invalid_handle: str = '*#$Y&*JRE'\n    pattern = re.compile(sites_info[site]['regexCheck'])\n    # Ensure that the username actually fails regex before testing sherlock\n    assert pattern.match(invalid_handle) is None\n    assert simple_query(sites_info=sites_info, site=site, username=invalid_handle) is QueryStatus.ILLEGAL\n\n",
    "tests/test_ux.py": "import pytest\nfrom sherlock_project import sherlock\nfrom sherlock_interactives import Interactives\nfrom sherlock_interactives import InteractivesSubprocessError\n\ndef test_remove_nsfw(sites_obj):\n    nsfw_target: str = 'Pornhub'\n    assert nsfw_target in {site.name: site.information for site in sites_obj}\n    sites_obj.remove_nsfw_sites()\n    assert nsfw_target not in {site.name: site.information for site in sites_obj}\n\n\n# Parametrized sites should *not* include Motherless, which is acting as the control\n@pytest.mark.parametrize('nsfwsites', [\n    ['Pornhub'],\n    ['Pornhub', 'Xvideos'],\n])\ndef test_nsfw_explicit_selection(sites_obj, nsfwsites):\n    for site in nsfwsites:\n        assert site in {site.name: site.information for site in sites_obj}\n    sites_obj.remove_nsfw_sites(do_not_remove=nsfwsites)\n    for site in nsfwsites:\n        assert site in {site.name: site.information for site in sites_obj}\n        assert 'Motherless' not in {site.name: site.information for site in sites_obj}\n\ndef test_wildcard_username_expansion():\n    assert sherlock.check_for_parameter('test{?}test') is True\n    assert sherlock.check_for_parameter('test{.}test') is False\n    assert sherlock.check_for_parameter('test{}test') is False\n    assert sherlock.check_for_parameter('testtest') is False\n    assert sherlock.check_for_parameter('test{?test') is False\n    assert sherlock.check_for_parameter('test?}test') is False\n    assert sherlock.multiple_usernames('test{?}test') == [\"test_test\" , \"test-test\" , \"test.test\"]\n\n\n@pytest.mark.parametrize('cliargs', [\n    '',\n    '--site urghrtuight --egiotr',\n    '--',\n])\ndef test_no_usernames_provided(cliargs):\n    with pytest.raises(InteractivesSubprocessError, match=r\"error: the following arguments are required: USERNAMES\"):\n        Interactives.run_cli(cliargs)\n",
    "tests/test_version.py": "import os\nfrom sherlock_interactives import Interactives\nimport sherlock_project\n\ndef test_versioning() -> None:\n    # Ensure __version__ matches version presented to the user\n    assert sherlock_project.__version__ in Interactives.run_cli(\"--version\")\n    # Ensure __init__ is single source of truth for __version__ in package\n    # Temporarily allows sherlock.py so as to not trigger early upgrades\n    found:list = Interactives.walk_sherlock_for_files_with(r'__version__ *= *')\n    expected:list = [\n        # Normalization is REQUIRED for Windows ( / vs \\ )\n        os.path.normpath(\"sherlock_project/__init__.py\"),\n    ]\n    # Sorting is REQUIRED for Mac\n    assert sorted(found) == sorted(expected)\n"
  },
  "requirements": null
}