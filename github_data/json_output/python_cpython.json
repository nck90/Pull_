{
  "repo_name": "python/cpython",
  "repo_url": "https://github.com/python/cpython",
  "description": "The Python programming language",
  "stars": 65833,
  "language": "Python",
  "created_at": "2017-02-10T19:23:51Z",
  "updated_at": "2025-03-19T06:22:39Z",
  "files": {
    "Android/testbed/app/src/main/python/main.py": "import os\nimport runpy\nimport shlex\nimport signal\nimport sys\n\n# Some tests use SIGUSR1, but that's blocked by default in an Android app in\n# order to make it available to `sigwait` in the Signal Catcher thread.\n# (https://cs.android.com/android/platform/superproject/+/android14-qpr3-release:art/runtime/signal_catcher.cc).\n# That thread's functionality is only useful for debugging the JVM, so disabling\n# it should not weaken the tests.\n#\n# There's no safe way of stopping the thread completely (#123982), but simply\n# unblocking SIGUSR1 is enough to fix most tests.\n#\n# However, in tests that generate multiple different signals in quick\n# succession, it's possible for SIGUSR1 to arrive while the main thread is busy\n# running the C-level handler for a different signal. In that case, the SIGUSR1\n# may be sent to the Signal Catcher thread instead, which will generate a log\n# message containing the text \"reacting to signal\".\n#\n# Such tests may need to be changed in one of the following ways:\n#   * Use a signal other than SIGUSR1 (e.g. test_stress_delivery_simultaneous in\n#     test_signal.py).\n#   * Send the signal to a specific thread rather than the whole process (e.g.\n#     test_signals in test_threadsignals.py.\nsignal.pthread_sigmask(signal.SIG_UNBLOCK, [signal.SIGUSR1])\n\nsys.argv[1:] = shlex.split(os.environ[\"PYTHON_ARGS\"])\n\n# The test module will call sys.exit to indicate whether the tests passed.\nrunpy.run_module(\"test\")\n",
    "Doc/includes/newtypes/test.py": "\"\"\"Test module for the custom examples\n\nCustom 1:\n\n>>> import custom\n>>> c1 = custom.Custom()\n>>> c2 = custom.Custom()\n>>> del c1\n>>> del c2\n\n\nCustom 2\n\n>>> import custom2\n>>> c1 = custom2.Custom('jim', 'fulton', 42)\n>>> c1.first\n'jim'\n>>> c1.last\n'fulton'\n>>> c1.number\n42\n>>> c1.name()\n'jim fulton'\n>>> c1.first = 'will'\n>>> c1.name()\n'will fulton'\n>>> c1.last = 'tell'\n>>> c1.name()\n'will tell'\n>>> del c1.first\n>>> c1.name()\nTraceback (most recent call last):\n...\nAttributeError: first\n>>> c1.first\nTraceback (most recent call last):\n...\nAttributeError: first\n>>> c1.first = 'drew'\n>>> c1.first\n'drew'\n>>> del c1.number\nTraceback (most recent call last):\n...\nTypeError: can't delete numeric/char attribute\n>>> c1.number=2\n>>> c1.number\n2\n>>> c1.first = 42\n>>> c1.name()\n'42 tell'\n>>> c2 = custom2.Custom()\n>>> c2.name()\n' '\n>>> c2.first\n''\n>>> c2.last\n''\n>>> del c2.first\n>>> c2.first\nTraceback (most recent call last):\n...\nAttributeError: first\n>>> c2.first\nTraceback (most recent call last):\n...\nAttributeError: first\n>>> c2.name()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nAttributeError: first\n>>> c2.number\n0\n>>> n3 = custom2.Custom('jim', 'fulton', 'waaa')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: an integer is required (got type str)\n>>> del c1\n>>> del c2\n\n\nCustom 3\n\n>>> import custom3\n>>> c1 = custom3.Custom('jim', 'fulton', 42)\n>>> c1 = custom3.Custom('jim', 'fulton', 42)\n>>> c1.name()\n'jim fulton'\n>>> del c1.first\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: Cannot delete the first attribute\n>>> c1.first = 42\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: The first attribute value must be a string\n>>> c1.first = 'will'\n>>> c1.name()\n'will fulton'\n>>> c2 = custom3.Custom()\n>>> c2 = custom3.Custom()\n>>> c2 = custom3.Custom()\n>>> n3 = custom3.Custom('jim', 'fulton', 'waaa')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: an integer is required (got type str)\n>>> del c1\n>>> del c2\n\nCustom 4\n\n>>> import custom4\n>>> c1 = custom4.Custom('jim', 'fulton', 42)\n>>> c1.first\n'jim'\n>>> c1.last\n'fulton'\n>>> c1.number\n42\n>>> c1.name()\n'jim fulton'\n>>> c1.first = 'will'\n>>> c1.name()\n'will fulton'\n>>> c1.last = 'tell'\n>>> c1.name()\n'will tell'\n>>> del c1.first\nTraceback (most recent call last):\n...\nTypeError: Cannot delete the first attribute\n>>> c1.name()\n'will tell'\n>>> c1.first = 'drew'\n>>> c1.first\n'drew'\n>>> del c1.number\nTraceback (most recent call last):\n...\nTypeError: can't delete numeric/char attribute\n>>> c1.number=2\n>>> c1.number\n2\n>>> c1.first = 42\nTraceback (most recent call last):\n...\nTypeError: The first attribute value must be a string\n>>> c1.name()\n'drew tell'\n>>> c2 = custom4.Custom()\n>>> c2 = custom4.Custom()\n>>> c2 = custom4.Custom()\n>>> c2 = custom4.Custom()\n>>> c2.name()\n' '\n>>> c2.first\n''\n>>> c2.last\n''\n>>> c2.number\n0\n>>> n3 = custom4.Custom('jim', 'fulton', 'waaa')\nTraceback (most recent call last):\n...\nTypeError: an integer is required (got type str)\n\n\nTest cyclic gc(?)\n\n>>> import gc\n>>> gc.disable()\n\n>>> class Subclass(custom4.Custom): pass\n...\n>>> s = Subclass()\n>>> s.cycle = [s]\n>>> s.cycle.append(s.cycle)\n>>> x = object()\n>>> s.x = x\n>>> del s\n>>> sys.getrefcount(x)\n3\n>>> ignore = gc.collect()\n>>> sys.getrefcount(x)\n2\n\n>>> gc.enable()\n\"\"\"\n\nif __name__ == \"__main__\":\n    import doctest, __main__\n    doctest.testmod(__main__)\n",
    "Lib/doctest.py": "# Module doctest.\n# Released to the public domain 16-Jan-2001, by Tim Peters (tim@python.org).\n# Major enhancements and refactoring by:\n#     Jim Fulton\n#     Edward Loper\n\n# Provided as-is; use at your own risk; no warranty; no promises; enjoy!\n\nr\"\"\"Module doctest -- a framework for running examples in docstrings.\n\nIn simplest use, end each module M to be tested with:\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    _test()\n\nThen running the module as a script will cause the examples in the\ndocstrings to get executed and verified:\n\npython M.py\n\nThis won't display anything unless an example fails, in which case the\nfailing example(s) and the cause(s) of the failure(s) are printed to stdout\n(why not stderr? because stderr is a lame hack <0.2 wink>), and the final\nline of output is \"Test failed.\".\n\nRun it with the -v switch instead:\n\npython M.py -v\n\nand a detailed report of all examples tried is printed to stdout, along\nwith assorted summaries at the end.\n\nYou can force verbose mode by passing \"verbose=True\" to testmod, or prohibit\nit by passing \"verbose=False\".  In either of those cases, sys.argv is not\nexamined by testmod.\n\nThere are a variety of other ways to run doctests, including integration\nwith the unittest framework, and support for running non-Python text\nfiles containing doctests.  There are also many ways to override parts\nof doctest's default behaviors.  See the Library Reference Manual for\ndetails.\n\"\"\"\n\n__docformat__ = 'reStructuredText en'\n\n__all__ = [\n    # 0, Option Flags\n    'register_optionflag',\n    'DONT_ACCEPT_TRUE_FOR_1',\n    'DONT_ACCEPT_BLANKLINE',\n    'NORMALIZE_WHITESPACE',\n    'ELLIPSIS',\n    'SKIP',\n    'IGNORE_EXCEPTION_DETAIL',\n    'COMPARISON_FLAGS',\n    'REPORT_UDIFF',\n    'REPORT_CDIFF',\n    'REPORT_NDIFF',\n    'REPORT_ONLY_FIRST_FAILURE',\n    'REPORTING_FLAGS',\n    'FAIL_FAST',\n    # 1. Utility Functions\n    # 2. Example & DocTest\n    'Example',\n    'DocTest',\n    # 3. Doctest Parser\n    'DocTestParser',\n    # 4. Doctest Finder\n    'DocTestFinder',\n    # 5. Doctest Runner\n    'DocTestRunner',\n    'OutputChecker',\n    'DocTestFailure',\n    'UnexpectedException',\n    'DebugRunner',\n    # 6. Test Functions\n    'testmod',\n    'testfile',\n    'run_docstring_examples',\n    # 7. Unittest Support\n    'DocTestSuite',\n    'DocFileSuite',\n    'set_unittest_reportflags',\n    # 8. Debugging Support\n    'script_from_examples',\n    'testsource',\n    'debug_src',\n    'debug',\n]\n\nimport __future__\nimport difflib\nimport inspect\nimport linecache\nimport os\nimport pdb\nimport re\nimport sys\nimport traceback\nimport unittest\nfrom io import StringIO, IncrementalNewlineDecoder\nfrom collections import namedtuple\nimport _colorize  # Used in doctests\nfrom _colorize import ANSIColors, can_colorize\n\n\nclass TestResults(namedtuple('TestResults', 'failed attempted')):\n    def __new__(cls, failed, attempted, *, skipped=0):\n        results = super().__new__(cls, failed, attempted)\n        results.skipped = skipped\n        return results\n\n    def __repr__(self):\n        if self.skipped:\n            return (f'TestResults(failed={self.failed}, '\n                    f'attempted={self.attempted}, '\n                    f'skipped={self.skipped})')\n        else:\n            # Leave the repr() unchanged for backward compatibility\n            # if skipped is zero\n            return super().__repr__()\n\n\n# There are 4 basic classes:\n#  - Example: a <source, want> pair, plus an intra-docstring line number.\n#  - DocTest: a collection of examples, parsed from a docstring, plus\n#    info about where the docstring came from (name, filename, lineno).\n#  - DocTestFinder: extracts DocTests from a given object's docstring and\n#    its contained objects' docstrings.\n#  - DocTestRunner: runs DocTest cases, and accumulates statistics.\n#\n# So the basic picture is:\n#\n#                             list of:\n# +------+                   +---------+                   +-------+\n# |object| --DocTestFinder-> | DocTest | --DocTestRunner-> |results|\n# +------+                   +---------+                   +-------+\n#                            | Example |\n#                            |   ...   |\n#                            | Example |\n#                            +---------+\n\n# Option constants.\n\nOPTIONFLAGS_BY_NAME = {}\ndef register_optionflag(name):\n    # Create a new flag unless `name` is already known.\n    return OPTIONFLAGS_BY_NAME.setdefault(name, 1 << len(OPTIONFLAGS_BY_NAME))\n\nDONT_ACCEPT_TRUE_FOR_1 = register_optionflag('DONT_ACCEPT_TRUE_FOR_1')\nDONT_ACCEPT_BLANKLINE = register_optionflag('DONT_ACCEPT_BLANKLINE')\nNORMALIZE_WHITESPACE = register_optionflag('NORMALIZE_WHITESPACE')\nELLIPSIS = register_optionflag('ELLIPSIS')\nSKIP = register_optionflag('SKIP')\nIGNORE_EXCEPTION_DETAIL = register_optionflag('IGNORE_EXCEPTION_DETAIL')\n\nCOMPARISON_FLAGS = (DONT_ACCEPT_TRUE_FOR_1 |\n                    DONT_ACCEPT_BLANKLINE |\n                    NORMALIZE_WHITESPACE |\n                    ELLIPSIS |\n                    SKIP |\n                    IGNORE_EXCEPTION_DETAIL)\n\nREPORT_UDIFF = register_optionflag('REPORT_UDIFF')\nREPORT_CDIFF = register_optionflag('REPORT_CDIFF')\nREPORT_NDIFF = register_optionflag('REPORT_NDIFF')\nREPORT_ONLY_FIRST_FAILURE = register_optionflag('REPORT_ONLY_FIRST_FAILURE')\nFAIL_FAST = register_optionflag('FAIL_FAST')\n\nREPORTING_FLAGS = (REPORT_UDIFF |\n                   REPORT_CDIFF |\n                   REPORT_NDIFF |\n                   REPORT_ONLY_FIRST_FAILURE |\n                   FAIL_FAST)\n\n# Special string markers for use in `want` strings:\nBLANKLINE_MARKER = '<BLANKLINE>'\nELLIPSIS_MARKER = '...'\n\n######################################################################\n## Table of Contents\n######################################################################\n#  1. Utility Functions\n#  2. Example & DocTest -- store test cases\n#  3. DocTest Parser -- extracts examples from strings\n#  4. DocTest Finder -- extracts test cases from objects\n#  5. DocTest Runner -- runs test cases\n#  6. Test Functions -- convenient wrappers for testing\n#  7. Unittest Support\n#  8. Debugging Support\n#  9. Example Usage\n\n######################################################################\n## 1. Utility Functions\n######################################################################\n\ndef _extract_future_flags(globs):\n    \"\"\"\n    Return the compiler-flags associated with the future features that\n    have been imported into the given namespace (globs).\n    \"\"\"\n    flags = 0\n    for fname in __future__.all_feature_names:\n        feature = globs.get(fname, None)\n        if feature is getattr(__future__, fname):\n            flags |= feature.compiler_flag\n    return flags\n\ndef _normalize_module(module, depth=2):\n    \"\"\"\n    Return the module specified by `module`.  In particular:\n      - If `module` is a module, then return module.\n      - If `module` is a string, then import and return the\n        module with that name.\n      - If `module` is None, then return the calling module.\n        The calling module is assumed to be the module of\n        the stack frame at the given depth in the call stack.\n    \"\"\"\n    if inspect.ismodule(module):\n        return module\n    elif isinstance(module, str):\n        return __import__(module, globals(), locals(), [\"*\"])\n    elif module is None:\n        try:\n            try:\n                return sys.modules[sys._getframemodulename(depth)]\n            except AttributeError:\n                return sys.modules[sys._getframe(depth).f_globals['__name__']]\n        except KeyError:\n            pass\n    else:\n        raise TypeError(\"Expected a module, string, or None\")\n\ndef _newline_convert(data):\n    # The IO module provides a handy decoder for universal newline conversion\n    return IncrementalNewlineDecoder(None, True).decode(data, True)\n\ndef _load_testfile(filename, package, module_relative, encoding):\n    if module_relative:\n        package = _normalize_module(package, 3)\n        filename = _module_relative_path(package, filename)\n        if (loader := getattr(package, '__loader__', None)) is None:\n            try:\n                loader = package.__spec__.loader\n            except AttributeError:\n                pass\n        if hasattr(loader, 'get_data'):\n            file_contents = loader.get_data(filename)\n            file_contents = file_contents.decode(encoding)\n            # get_data() opens files as 'rb', so one must do the equivalent\n            # conversion as universal newlines would do.\n            return _newline_convert(file_contents), filename\n    with open(filename, encoding=encoding) as f:\n        return f.read(), filename\n\ndef _indent(s, indent=4):\n    \"\"\"\n    Add the given number of space characters to the beginning of\n    every non-blank line in `s`, and return the result.\n    \"\"\"\n    # This regexp matches the start of non-blank lines:\n    return re.sub('(?m)^(?!$)', indent*' ', s)\n\ndef _exception_traceback(exc_info):\n    \"\"\"\n    Return a string containing a traceback message for the given\n    exc_info tuple (as returned by sys.exc_info()).\n    \"\"\"\n    # Get a traceback message.\n    excout = StringIO()\n    exc_type, exc_val, exc_tb = exc_info\n    traceback.print_exception(exc_type, exc_val, exc_tb, file=excout)\n    return excout.getvalue()\n\n# Override some StringIO methods.\nclass _SpoofOut(StringIO):\n    def getvalue(self):\n        result = StringIO.getvalue(self)\n        # If anything at all was written, make sure there's a trailing\n        # newline.  There's no way for the expected output to indicate\n        # that a trailing newline is missing.\n        if result and not result.endswith(\"\\n\"):\n            result += \"\\n\"\n        return result\n\n    def truncate(self, size=None):\n        self.seek(size)\n        StringIO.truncate(self)\n\n# Worst-case linear-time ellipsis matching.\ndef _ellipsis_match(want, got):\n    \"\"\"\n    Essentially the only subtle case:\n    >>> _ellipsis_match('aa...aa', 'aaa')\n    False\n    \"\"\"\n    if ELLIPSIS_MARKER not in want:\n        return want == got\n\n    # Find \"the real\" strings.\n    ws = want.split(ELLIPSIS_MARKER)\n    assert len(ws) >= 2\n\n    # Deal with exact matches possibly needed at one or both ends.\n    startpos, endpos = 0, len(got)\n    w = ws[0]\n    if w:   # starts with exact match\n        if got.startswith(w):\n            startpos = len(w)\n            del ws[0]\n        else:\n            return False\n    w = ws[-1]\n    if w:   # ends with exact match\n        if got.endswith(w):\n            endpos -= len(w)\n            del ws[-1]\n        else:\n            return False\n\n    if startpos > endpos:\n        # Exact end matches required more characters than we have, as in\n        # _ellipsis_match('aa...aa', 'aaa')\n        return False\n\n    # For the rest, we only need to find the leftmost non-overlapping\n    # match for each piece.  If there's no overall match that way alone,\n    # there's no overall match period.\n    for w in ws:\n        # w may be '' at times, if there are consecutive ellipses, or\n        # due to an ellipsis at the start or end of `want`.  That's OK.\n        # Search for an empty string succeeds, and doesn't change startpos.\n        startpos = got.find(w, startpos, endpos)\n        if startpos < 0:\n            return False\n        startpos += len(w)\n\n    return True\n\ndef _comment_line(line):\n    \"Return a commented form of the given line\"\n    line = line.rstrip()\n    if line:\n        return '# '+line\n    else:\n        return '#'\n\ndef _strip_exception_details(msg):\n    # Support for IGNORE_EXCEPTION_DETAIL.\n    # Get rid of everything except the exception name; in particular, drop\n    # the possibly dotted module path (if any) and the exception message (if\n    # any).  We assume that a colon is never part of a dotted name, or of an\n    # exception name.\n    # E.g., given\n    #    \"foo.bar.MyError: la di da\"\n    # return \"MyError\"\n    # Or for \"abc.def\" or \"abc.def:\\n\" return \"def\".\n\n    start, end = 0, len(msg)\n    # The exception name must appear on the first line.\n    i = msg.find(\"\\n\")\n    if i >= 0:\n        end = i\n    # retain up to the first colon (if any)\n    i = msg.find(':', 0, end)\n    if i >= 0:\n        end = i\n    # retain just the exception name\n    i = msg.rfind('.', 0, end)\n    if i >= 0:\n        start = i+1\n    return msg[start: end]\n\nclass _OutputRedirectingPdb(pdb.Pdb):\n    \"\"\"\n    A specialized version of the python debugger that redirects stdout\n    to a given stream when interacting with the user.  Stdout is *not*\n    redirected when traced code is executed.\n    \"\"\"\n    def __init__(self, out):\n        self.__out = out\n        self.__debugger_used = False\n        # do not play signal games in the pdb\n        pdb.Pdb.__init__(self, stdout=out, nosigint=True)\n        # still use input() to get user input\n        self.use_rawinput = 1\n\n    def set_trace(self, frame=None, *, commands=None):\n        self.__debugger_used = True\n        if frame is None:\n            frame = sys._getframe().f_back\n        pdb.Pdb.set_trace(self, frame, commands=commands)\n\n    def set_continue(self):\n        # Calling set_continue unconditionally would break unit test\n        # coverage reporting, as Bdb.set_continue calls sys.settrace(None).\n        if self.__debugger_used:\n            pdb.Pdb.set_continue(self)\n\n    def trace_dispatch(self, *args):\n        # Redirect stdout to the given stream.\n        save_stdout = sys.stdout\n        sys.stdout = self.__out\n        # Call Pdb's trace dispatch method.\n        try:\n            return pdb.Pdb.trace_dispatch(self, *args)\n        finally:\n            sys.stdout = save_stdout\n\n# [XX] Normalize with respect to os.path.pardir?\ndef _module_relative_path(module, test_path):\n    if not inspect.ismodule(module):\n        raise TypeError('Expected a module: %r' % module)\n    if test_path.startswith('/'):\n        raise ValueError('Module-relative files may not have absolute paths')\n\n    # Normalize the path. On Windows, replace \"/\" with \"\\\".\n    test_path = os.path.join(*(test_path.split('/')))\n\n    # Find the base directory for the path.\n    if hasattr(module, '__file__'):\n        # A normal module/package\n        basedir = os.path.split(module.__file__)[0]\n    elif module.__name__ == '__main__':\n        # An interactive session.\n        if len(sys.argv)>0 and sys.argv[0] != '':\n            basedir = os.path.split(sys.argv[0])[0]\n        else:\n            basedir = os.curdir\n    else:\n        if hasattr(module, '__path__'):\n            for directory in module.__path__:\n                fullpath = os.path.join(directory, test_path)\n                if os.path.exists(fullpath):\n                    return fullpath\n\n        # A module w/o __file__ (this includes builtins)\n        raise ValueError(\"Can't resolve paths relative to the module \"\n                         \"%r (it has no __file__)\"\n                         % module.__name__)\n\n    # Combine the base directory and the test path.\n    return os.path.join(basedir, test_path)\n\n######################################################################\n## 2. Example & DocTest\n######################################################################\n## - An \"example\" is a <source, want> pair, where \"source\" is a\n##   fragment of source code, and \"want\" is the expected output for\n##   \"source.\"  The Example class also includes information about\n##   where the example was extracted from.\n##\n## - A \"doctest\" is a collection of examples, typically extracted from\n##   a string (such as an object's docstring).  The DocTest class also\n##   includes information about where the string was extracted from.\n\nclass Example:\n    \"\"\"\n    A single doctest example, consisting of source code and expected\n    output.  `Example` defines the following attributes:\n\n      - source: A single Python statement, always ending with a newline.\n        The constructor adds a newline if needed.\n\n      - want: The expected output from running the source code (either\n        from stdout, or a traceback in case of exception).  `want` ends\n        with a newline unless it's empty, in which case it's an empty\n        string.  The constructor adds a newline if needed.\n\n      - exc_msg: The exception message generated by the example, if\n        the example is expected to generate an exception; or `None` if\n        it is not expected to generate an exception.  This exception\n        message is compared against the return value of\n        `traceback.format_exception_only()`.  `exc_msg` ends with a\n        newline unless it's `None`.  The constructor adds a newline\n        if needed.\n\n      - lineno: The line number within the DocTest string containing\n        this Example where the Example begins.  This line number is\n        zero-based, with respect to the beginning of the DocTest.\n\n      - indent: The example's indentation in the DocTest string.\n        I.e., the number of space characters that precede the\n        example's first prompt.\n\n      - options: A dictionary mapping from option flags to True or\n        False, which is used to override default options for this\n        example.  Any option flags not contained in this dictionary\n        are left at their default value (as specified by the\n        DocTestRunner's optionflags).  By default, no options are set.\n    \"\"\"\n    def __init__(self, source, want, exc_msg=None, lineno=0, indent=0,\n                 options=None):\n        # Normalize inputs.\n        if not source.endswith('\\n'):\n            source += '\\n'\n        if want and not want.endswith('\\n'):\n            want += '\\n'\n        if exc_msg is not None and not exc_msg.endswith('\\n'):\n            exc_msg += '\\n'\n        # Store properties.\n        self.source = source\n        self.want = want\n        self.lineno = lineno\n        self.indent = indent\n        if options is None: options = {}\n        self.options = options\n        self.exc_msg = exc_msg\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return NotImplemented\n\n        return self.source == other.source and \\\n               self.want == other.want and \\\n               self.lineno == other.lineno and \\\n               self.indent == other.indent and \\\n               self.options == other.options and \\\n               self.exc_msg == other.exc_msg\n\n    def __hash__(self):\n        return hash((self.source, self.want, self.lineno, self.indent,\n                     self.exc_msg))\n\nclass DocTest:\n    \"\"\"\n    A collection of doctest examples that should be run in a single\n    namespace.  Each `DocTest` defines the following attributes:\n\n      - examples: the list of examples.\n\n      - globs: The namespace (aka globals) that the examples should\n        be run in.\n\n      - name: A name identifying the DocTest (typically, the name of\n        the object whose docstring this DocTest was extracted from).\n\n      - filename: The name of the file that this DocTest was extracted\n        from, or `None` if the filename is unknown.\n\n      - lineno: The line number within filename where this DocTest\n        begins, or `None` if the line number is unavailable.  This\n        line number is zero-based, with respect to the beginning of\n        the file.\n\n      - docstring: The string that the examples were extracted from,\n        or `None` if the string is unavailable.\n    \"\"\"\n    def __init__(self, examples, globs, name, filename, lineno, docstring):\n        \"\"\"\n        Create a new DocTest containing the given examples.  The\n        DocTest's globals are initialized with a copy of `globs`.\n        \"\"\"\n        assert not isinstance(examples, str), \\\n               \"DocTest no longer accepts str; use DocTestParser instead\"\n        self.examples = examples\n        self.docstring = docstring\n        self.globs = globs.copy()\n        self.name = name\n        self.filename = filename\n        self.lineno = lineno\n\n    def __repr__(self):\n        if len(self.examples) == 0:\n            examples = 'no examples'\n        elif len(self.examples) == 1:\n            examples = '1 example'\n        else:\n            examples = '%d examples' % len(self.examples)\n        return ('<%s %s from %s:%s (%s)>' %\n                (self.__class__.__name__,\n                 self.name, self.filename, self.lineno, examples))\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return NotImplemented\n\n        return self.examples == other.examples and \\\n               self.docstring == other.docstring and \\\n               self.globs == other.globs and \\\n               self.name == other.name and \\\n               self.filename == other.filename and \\\n               self.lineno == other.lineno\n\n    def __hash__(self):\n        return hash((self.docstring, self.name, self.filename, self.lineno))\n\n    # This lets us sort tests by name:\n    def __lt__(self, other):\n        if not isinstance(other, DocTest):\n            return NotImplemented\n        self_lno = self.lineno if self.lineno is not None else -1\n        other_lno = other.lineno if other.lineno is not None else -1\n        return ((self.name, self.filename, self_lno, id(self))\n                <\n                (other.name, other.filename, other_lno, id(other)))\n\n######################################################################\n## 3. DocTestParser\n######################################################################\n\nclass DocTestParser:\n    \"\"\"\n    A class used to parse strings containing doctest examples.\n    \"\"\"\n    # This regular expression is used to find doctest examples in a\n    # string.  It defines three groups: `source` is the source code\n    # (including leading indentation and prompts); `indent` is the\n    # indentation of the first (PS1) line of the source code; and\n    # `want` is the expected output (including leading indentation).\n    _EXAMPLE_RE = re.compile(r'''\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n            (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*>>>)  # Not a line starting with PS1\n                     .+$\\n?       # But any other line\n                  )*)\n        ''', re.MULTILINE | re.VERBOSE)\n\n    # A regular expression for handling `want` strings that contain\n    # expected exceptions.  It divides `want` into three pieces:\n    #    - the traceback header line (`hdr`)\n    #    - the traceback stack (`stack`)\n    #    - the exception message (`msg`), as generated by\n    #      traceback.format_exception_only()\n    # `msg` may have multiple lines.  We assume/require that the\n    # exception message is the first non-indented line starting with a word\n    # character following the traceback header line.\n    _EXCEPTION_RE = re.compile(r\"\"\"\n        # Grab the traceback header.  Different versions of Python have\n        # said different things on the first traceback line.\n        ^(?P<hdr> Traceback\\ \\(\n            (?: most\\ recent\\ call\\ last\n            |   innermost\\ last\n            ) \\) :\n        )\n        \\s* $                # toss trailing whitespace on the header.\n        (?P<stack> .*?)      # don't blink: absorb stuff until...\n        ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n        \"\"\", re.VERBOSE | re.MULTILINE | re.DOTALL)\n\n    # A callable returning a true value iff its argument is a blank line\n    # or contains a single comment.\n    _IS_BLANK_OR_COMMENT = re.compile(r'^[ ]*(#.*)?$').match\n\n    def parse(self, string, name='<string>'):\n        \"\"\"\n        Divide the given string into examples and intervening text,\n        and return them as a list of alternating Examples and strings.\n        Line numbers for the Examples are 0-based.  The optional\n        argument `name` is a name identifying this string, and is only\n        used for error messages.\n        \"\"\"\n        string = string.expandtabs()\n        # If all lines begin with the same indentation, then strip it.\n        min_indent = self._min_indent(string)\n        if min_indent > 0:\n            string = '\\n'.join([l[min_indent:] for l in string.split('\\n')])\n\n        output = []\n        charno, lineno = 0, 0\n        # Find all doctest examples in the string:\n        for m in self._EXAMPLE_RE.finditer(string):\n            # Add the pre-example text to `output`.\n            output.append(string[charno:m.start()])\n            # Update lineno (lines before this example)\n            lineno += string.count('\\n', charno, m.start())\n            # Extract info from the regexp match.\n            (source, options, want, exc_msg) = \\\n                     self._parse_example(m, name, lineno)\n            # Create an Example, and add it to the list.\n            if not self._IS_BLANK_OR_COMMENT(source):\n                output.append( Example(source, want, exc_msg,\n                                    lineno=lineno,\n                                    indent=min_indent+len(m.group('indent')),\n                                    options=options) )\n            # Update lineno (lines inside this example)\n            lineno += string.count('\\n', m.start(), m.end())\n            # Update charno.\n            charno = m.end()\n        # Add any remaining post-example text to `output`.\n        output.append(string[charno:])\n        return output\n\n    def get_doctest(self, string, globs, name, filename, lineno):\n        \"\"\"\n        Extract all doctest examples from the given string, and\n        collect them into a `DocTest` object.\n\n        `globs`, `name`, `filename`, and `lineno` are attributes for\n        the new `DocTest` object.  See the documentation for `DocTest`\n        for more information.\n        \"\"\"\n        return DocTest(self.get_examples(string, name), globs,\n                       name, filename, lineno, string)\n\n    def get_examples(self, string, name='<string>'):\n        \"\"\"\n        Extract all doctest examples from the given string, and return\n        them as a list of `Example` objects.  Line numbers are\n        0-based, because it's most common in doctests that nothing\n        interesting appears on the same line as opening triple-quote,\n        and so the first interesting line is called \\\"line 1\\\" then.\n\n        The optional argument `name` is a name identifying this\n        string, and is only used for error messages.\n        \"\"\"\n        return [x for x in self.parse(string, name)\n                if isinstance(x, Example)]\n\n    def _parse_example(self, m, name, lineno):\n        \"\"\"\n        Given a regular expression match from `_EXAMPLE_RE` (`m`),\n        return a pair `(source, want)`, where `source` is the matched\n        example's source code (with prompts and indentation stripped);\n        and `want` is the example's expected output (with indentation\n        stripped).\n\n        `name` is the string's name, and `lineno` is the line number\n        where the example starts; both are used for error messages.\n        \"\"\"\n        # Get the example's indentation level.\n        indent = len(m.group('indent'))\n\n        # Divide source into lines; check that they're properly\n        # indented; and then strip their indentation & prompts.\n        source_lines = m.group('source').split('\\n')\n        self._check_prompt_blank(source_lines, indent, name, lineno)\n        self._check_prefix(source_lines[1:], ' '*indent + '.', name, lineno)\n        source = '\\n'.join([sl[indent+4:] for sl in source_lines])\n\n        # Divide want into lines; check that it's properly indented; and\n        # then strip the indentation.  Spaces before the last newline should\n        # be preserved, so plain rstrip() isn't good enough.\n        want = m.group('want')\n        want_lines = want.split('\\n')\n        if len(want_lines) > 1 and re.match(r' *$', want_lines[-1]):\n            del want_lines[-1]  # forget final newline & spaces after it\n        self._check_prefix(want_lines, ' '*indent, name,\n                           lineno + len(source_lines))\n        want = '\\n'.join([wl[indent:] for wl in want_lines])\n\n        # If `want` contains a traceback message, then extract it.\n        m = self._EXCEPTION_RE.match(want)\n        if m:\n            exc_msg = m.group('msg')\n        else:\n            exc_msg = None\n\n        # Extract options from the source.\n        options = self._find_options(source, name, lineno)\n\n        return source, options, want, exc_msg\n\n    # This regular expression looks for option directives in the\n    # source code of an example.  Option directives are comments\n    # starting with \"doctest:\".  Warning: this may give false\n    # positives for string-literals that contain the string\n    # \"#doctest:\".  Eliminating these false positives would require\n    # actually parsing the string; but we limit them by ignoring any\n    # line containing \"#doctest:\" that is *followed* by a quote mark.\n    _OPTION_DIRECTIVE_RE = re.compile(r'#\\s*doctest:\\s*([^\\n\\'\"]*)$',\n                                      re.MULTILINE)\n\n    def _find_options(self, source, name, lineno):\n        \"\"\"\n        Return a dictionary containing option overrides extracted from\n        option directives in the given source string.\n\n        `name` is the string's name, and `lineno` is the line number\n        where the example starts; both are used for error messages.\n        \"\"\"\n        options = {}\n        # (note: with the current regexp, this will match at most once:)\n        for m in self._OPTION_DIRECTIVE_RE.finditer(source):\n            option_strings = m.group(1).replace(',', ' ').split()\n            for option in option_strings:\n                if (option[0] not in '+-' or\n                    option[1:] not in OPTIONFLAGS_BY_NAME):\n                    raise ValueError('line %r of the doctest for %s '\n                                     'has an invalid option: %r' %\n                                     (lineno+1, name, option))\n                flag = OPTIONFLAGS_BY_NAME[option[1:]]\n                options[flag] = (option[0] == '+')\n        if options and self._IS_BLANK_OR_COMMENT(source):\n            raise ValueError('line %r of the doctest for %s has an option '\n                             'directive on a line with no example: %r' %\n                             (lineno, name, source))\n        return options\n\n    # This regular expression finds the indentation of every non-blank\n    # line in a string.\n    _INDENT_RE = re.compile(r'^([ ]*)(?=\\S)', re.MULTILINE)\n\n    def _min_indent(self, s):\n        \"Return the minimum indentation of any non-blank line in `s`\"\n        indents = [len(indent) for indent in self._INDENT_RE.findall(s)]\n        if len(indents) > 0:\n            return min(indents)\n        else:\n            return 0\n\n    def _check_prompt_blank(self, lines, indent, name, lineno):\n        \"\"\"\n        Given the lines of a source string (including prompts and\n        leading indentation), check to make sure that every prompt is\n        followed by a space character.  If any line is not followed by\n        a space character, then raise ValueError.\n        \"\"\"\n        for i, line in enumerate(lines):\n            if len(line) >= indent+4 and line[indent+3] != ' ':\n                raise ValueError('line %r of the docstring for %s '\n                                 'lacks blank after %s: %r' %\n                                 (lineno+i+1, name,\n                                  line[indent:indent+3], line))\n\n    def _check_prefix(self, lines, prefix, name, lineno):\n        \"\"\"\n        Check that every line in the given list starts with the given\n        prefix; if any line does not, then raise a ValueError.\n        \"\"\"\n        for i, line in enumerate(lines):\n            if line and not line.startswith(prefix):\n                raise ValueError('line %r of the docstring for %s has '\n                                 'inconsistent leading whitespace: %r' %\n                                 (lineno+i+1, name, line))\n\n\n######################################################################\n## 4. DocTest Finder\n######################################################################\n\nclass DocTestFinder:\n    \"\"\"\n    A class used to extract the DocTests that are relevant to a given\n    object, from its docstring and the docstrings of its contained\n    objects.  Doctests can currently be extracted from the following\n    object types: modules, functions, classes, methods, staticmethods,\n    classmethods, and properties.\n    \"\"\"\n\n    def __init__(self, verbose=False, parser=DocTestParser(),\n                 recurse=True, exclude_empty=True):\n        \"\"\"\n        Create a new doctest finder.\n\n        The optional argument `parser` specifies a class or\n        function that should be used to create new DocTest objects (or\n        objects that implement the same interface as DocTest).  The\n        signature for this factory function should match the signature\n        of the DocTest constructor.\n\n        If the optional argument `recurse` is false, then `find` will\n        only examine the given object, and not any contained objects.\n\n        If the optional argument `exclude_empty` is false, then `find`\n        will include tests for objects with empty docstrings.\n        \"\"\"\n        self._parser = parser\n        self._verbose = verbose\n        self._recurse = recurse\n        self._exclude_empty = exclude_empty\n\n    def find(self, obj, name=None, module=None, globs=None, extraglobs=None):\n        \"\"\"\n        Return a list of the DocTests that are defined by the given\n        object's docstring, or by any of its contained objects'\n        docstrings.\n\n        The optional parameter `module` is the module that contains\n        the given object.  If the module is not specified or is None, then\n        the test finder will attempt to automatically determine the\n        correct module.  The object's module is used:\n\n            - As a default namespace, if `globs` is not specified.\n            - To prevent the DocTestFinder from extracting DocTests\n              from objects that are imported from other modules.\n            - To find the name of the file containing the object.\n            - To help find the line number of the object within its\n              file.\n\n        Contained objects whose module does not match `module` are ignored.\n\n        If `module` is False, no attempt to find the module will be made.\n        This is obscure, of use mostly in tests:  if `module` is False, or\n        is None but cannot be found automatically, then all objects are\n        considered to belong to the (non-existent) module, so all contained\n        objects will (recursively) be searched for doctests.\n\n        The globals for each DocTest is formed by combining `globs`\n        and `extraglobs` (bindings in `extraglobs` override bindings\n        in `globs`).  A new copy of the globals dictionary is created\n        for each DocTest.  If `globs` is not specified, then it\n        defaults to the module's `__dict__`, if specified, or {}\n        otherwise.  If `extraglobs` is not specified, then it defaults\n        to {}.\n\n        \"\"\"\n        # If name was not specified, then extract it from the object.\n        if name is None:\n            name = getattr(obj, '__name__', None)\n            if name is None:\n                raise ValueError(\"DocTestFinder.find: name must be given \"\n                        \"when obj.__name__ doesn't exist: %r\" %\n                                 (type(obj),))\n\n        # Find the module that contains the given object (if obj is\n        # a module, then module=obj.).  Note: this may fail, in which\n        # case module will be None.\n        if module is False:\n            module = None\n        elif module is None:\n            module = inspect.getmodule(obj)\n\n        # Read the module's source code.  This is used by\n        # DocTestFinder._find_lineno to find the line number for a\n        # given object's docstring.\n        try:\n            file = inspect.getsourcefile(obj)\n        except TypeError:\n            source_lines = None\n        else:\n            if not file:\n                # Check to see if it's one of our special internal \"files\"\n                # (see __patched_linecache_getlines).\n                file = inspect.getfile(obj)\n                if not file[0]+file[-2:] == '<]>': file = None\n            if file is None:\n                source_lines = None\n            else:\n                if module is not None:\n                    # Supply the module globals in case the module was\n                    # originally loaded via a PEP 302 loader and\n                    # file is not a valid filesystem path\n                    source_lines = linecache.getlines(file, module.__dict__)\n                else:\n                    # No access to a loader, so assume it's a normal\n                    # filesystem path\n                    source_lines = linecache.getlines(file)\n                if not source_lines:\n                    source_lines = None\n\n        # Initialize globals, and merge in extraglobs.\n        if globs is None:\n            if module is None:\n                globs = {}\n            else:\n                globs = module.__dict__.copy()\n        else:\n            globs = globs.copy()\n        if extraglobs is not None:\n            globs.update(extraglobs)\n        if '__name__' not in globs:\n            globs['__name__'] = '__main__'  # provide a default module name\n\n        # Recursively explore `obj`, extracting DocTests.\n        tests = []\n        self._find(tests, obj, name, module, source_lines, globs, {})\n        # Sort the tests by alpha order of names, for consistency in\n        # verbose-mode output.  This was a feature of doctest in Pythons\n        # <= 2.3 that got lost by accident in 2.4.  It was repaired in\n        # 2.4.4 and 2.5.\n        tests.sort()\n        return tests\n\n    def _from_module(self, module, object):\n        \"\"\"\n        Return true if the given object is defined in the given\n        module.\n        \"\"\"\n        if module is None:\n            return True\n        elif inspect.getmodule(object) is not None:\n            return module is inspect.getmodule(object)\n        elif inspect.isfunction(object):\n            return module.__dict__ is object.__globals__\n        elif (inspect.ismethoddescriptor(object) or\n              inspect.ismethodwrapper(object)):\n            if hasattr(object, '__objclass__'):\n                obj_mod = object.__objclass__.__module__\n            elif hasattr(object, '__module__'):\n                obj_mod = object.__module__\n            else:\n                return True # [XX] no easy way to tell otherwise\n            return module.__name__ == obj_mod\n        elif inspect.isclass(object):\n            return module.__name__ == object.__module__\n        elif hasattr(object, '__module__'):\n            return module.__name__ == object.__module__\n        elif isinstance(object, property):\n            return True # [XX] no way not be sure.\n        else:\n            raise ValueError(\"object must be a class or function\")\n\n    def _is_routine(self, obj):\n        \"\"\"\n        Safely unwrap objects and determine if they are functions.\n        \"\"\"\n        maybe_routine = obj\n        try:\n            maybe_routine = inspect.unwrap(maybe_routine)\n        except ValueError:\n            pass\n        return inspect.isroutine(maybe_routine)\n\n    def _find(self, tests, obj, name, module, source_lines, globs, seen):\n        \"\"\"\n        Find tests for the given object and any contained objects, and\n        add them to `tests`.\n        \"\"\"\n        if self._verbose:\n            print('Finding tests in %s' % name)\n\n        # If we've already processed this object, then ignore it.\n        if id(obj) in seen:\n            return\n        seen[id(obj)] = 1\n\n        # Find a test for this object, and add it to the list of tests.\n        test = self._get_test(obj, name, module, globs, source_lines)\n        if test is not None:\n            tests.append(test)\n\n        # Look for tests in a module's contained objects.\n        if inspect.ismodule(obj) and self._recurse:\n            for valname, val in obj.__dict__.items():\n                valname = '%s.%s' % (name, valname)\n\n                # Recurse to functions & classes.\n                if ((self._is_routine(val) or inspect.isclass(val)) and\n                    self._from_module(module, val)):\n                    self._find(tests, val, valname, module, source_lines,\n                               globs, seen)\n\n        # Look for tests in a module's __test__ dictionary.\n        if inspect.ismodule(obj) and self._recurse:\n            for valname, val in getattr(obj, '__test__', {}).items():\n                if not isinstance(valname, str):\n                    raise ValueError(\"DocTestFinder.find: __test__ keys \"\n                                     \"must be strings: %r\" %\n                                     (type(valname),))\n                if not (inspect.isroutine(val) or inspect.isclass(val) or\n                        inspect.ismodule(val) or isinstance(val, str)):\n                    raise ValueError(\"DocTestFinder.find: __test__ values \"\n                                     \"must be strings, functions, methods, \"\n                                     \"classes, or modules: %r\" %\n                                     (type(val),))\n                valname = '%s.__test__.%s' % (name, valname)\n                self._find(tests, val, valname, module, source_lines,\n                           globs, seen)\n\n        # Look for tests in a class's contained objects.\n        if inspect.isclass(obj) and self._recurse:\n            for valname, val in obj.__dict__.items():\n                # Special handling for staticmethod/classmethod.\n                if isinstance(val, (staticmethod, classmethod)):\n                    val = val.__func__\n\n                # Recurse to methods, properties, and nested classes.\n                if ((inspect.isroutine(val) or inspect.isclass(val) or\n                      isinstance(val, property)) and\n                      self._from_module(module, val)):\n                    valname = '%s.%s' % (name, valname)\n                    self._find(tests, val, valname, module, source_lines,\n                               globs, seen)\n\n    def _get_test(self, obj, name, module, globs, source_lines):\n        \"\"\"\n        Return a DocTest for the given object, if it defines a docstring;\n        otherwise, return None.\n        \"\"\"\n        # Extract the object's docstring.  If it doesn't have one,\n        # then return None (no test for this object).\n        if isinstance(obj, str):\n            docstring = obj\n        else:\n            try:\n                if obj.__doc__ is None:\n                    docstring = ''\n                else:\n                    docstring = obj.__doc__\n                    if not isinstance(docstring, str):\n                        docstring = str(docstring)\n            except (TypeError, AttributeError):\n                docstring = ''\n\n        # Find the docstring's location in the file.\n        lineno = self._find_lineno(obj, source_lines)\n\n        # Don't bother if the docstring is empty.\n        if self._exclude_empty and not docstring:\n            return None\n\n        # Return a DocTest for this object.\n        if module is None:\n            filename = None\n        else:\n            # __file__ can be None for namespace packages.\n            filename = getattr(module, '__file__', None) or module.__name__\n            if filename[-4:] == \".pyc\":\n                filename = filename[:-1]\n        return self._parser.get_doctest(docstring, globs, name,\n                                        filename, lineno)\n\n    def _find_lineno(self, obj, source_lines):\n        \"\"\"\n        Return a line number of the given object's docstring.\n\n        Returns `None` if the given object does not have a docstring.\n        \"\"\"\n        lineno = None\n        docstring = getattr(obj, '__doc__', None)\n\n        # Find the line number for modules.\n        if inspect.ismodule(obj) and docstring is not None:\n            lineno = 0\n\n        # Find the line number for classes.\n        # Note: this could be fooled if a class is defined multiple\n        # times in a single file.\n        if inspect.isclass(obj) and docstring is not None:\n            if source_lines is None:\n                return None\n            pat = re.compile(r'^\\s*class\\s*%s\\b' %\n                             re.escape(getattr(obj, '__name__', '-')))\n            for i, line in enumerate(source_lines):\n                if pat.match(line):\n                    lineno = i\n                    break\n\n        # Find the line number for functions & methods.\n        if inspect.ismethod(obj): obj = obj.__func__\n        if isinstance(obj, property):\n            obj = obj.fget\n        if inspect.isfunction(obj) and getattr(obj, '__doc__', None):\n            # We don't use `docstring` var here, because `obj` can be changed.\n            obj = inspect.unwrap(obj)\n            try:\n                obj = obj.__code__\n            except AttributeError:\n                # Functions implemented in C don't necessarily\n                # have a __code__ attribute.\n                # If there's no code, there's no lineno\n                return None\n        if inspect.istraceback(obj): obj = obj.tb_frame\n        if inspect.isframe(obj): obj = obj.f_code\n        if inspect.iscode(obj):\n            lineno = obj.co_firstlineno - 1\n\n        # Find the line number where the docstring starts.  Assume\n        # that it's the first line that begins with a quote mark.\n        # Note: this could be fooled by a multiline function\n        # signature, where a continuation line begins with a quote\n        # mark.\n        if lineno is not None:\n            if source_lines is None:\n                return lineno+1\n            pat = re.compile(r'(^|.*:)\\s*\\w*(\"|\\')')\n            for lineno in range(lineno, len(source_lines)):\n                if pat.match(source_lines[lineno]):\n                    return lineno\n\n        # We couldn't find the line number.\n        return None\n\n######################################################################\n## 5. DocTest Runner\n######################################################################\n\nclass DocTestRunner:\n    \"\"\"\n    A class used to run DocTest test cases, and accumulate statistics.\n    The `run` method is used to process a single DocTest case.  It\n    returns a TestResults instance.\n\n        >>> save_colorize = _colorize.COLORIZE\n        >>> _colorize.COLORIZE = False\n\n        >>> tests = DocTestFinder().find(_TestClass)\n        >>> runner = DocTestRunner(verbose=False)\n        >>> tests.sort(key = lambda test: test.name)\n        >>> for test in tests:\n        ...     print(test.name, '->', runner.run(test))\n        _TestClass -> TestResults(failed=0, attempted=2)\n        _TestClass.__init__ -> TestResults(failed=0, attempted=2)\n        _TestClass.get -> TestResults(failed=0, attempted=2)\n        _TestClass.square -> TestResults(failed=0, attempted=1)\n\n    The `summarize` method prints a summary of all the test cases that\n    have been run by the runner, and returns an aggregated TestResults\n    instance:\n\n        >>> runner.summarize(verbose=1)\n        4 items passed all tests:\n           2 tests in _TestClass\n           2 tests in _TestClass.__init__\n           2 tests in _TestClass.get\n           1 test in _TestClass.square\n        7 tests in 4 items.\n        7 passed.\n        Test passed.\n        TestResults(failed=0, attempted=7)\n\n    The aggregated number of tried examples and failed examples is also\n    available via the `tries`, `failures` and `skips` attributes:\n\n        >>> runner.tries\n        7\n        >>> runner.failures\n        0\n        >>> runner.skips\n        0\n\n    The comparison between expected outputs and actual outputs is done\n    by an `OutputChecker`.  This comparison may be customized with a\n    number of option flags; see the documentation for `testmod` for\n    more information.  If the option flags are insufficient, then the\n    comparison may also be customized by passing a subclass of\n    `OutputChecker` to the constructor.\n\n    The test runner's display output can be controlled in two ways.\n    First, an output function (`out`) can be passed to\n    `TestRunner.run`; this function will be called with strings that\n    should be displayed.  It defaults to `sys.stdout.write`.  If\n    capturing the output is not sufficient, then the display output\n    can be also customized by subclassing DocTestRunner, and\n    overriding the methods `report_start`, `report_success`,\n    `report_unexpected_exception`, and `report_failure`.\n\n        >>> _colorize.COLORIZE = save_colorize\n    \"\"\"\n    # This divider string is used to separate failure messages, and to\n    # separate sections of the summary.\n    DIVIDER = \"*\" * 70\n\n    def __init__(self, checker=None, verbose=None, optionflags=0):\n        \"\"\"\n        Create a new test runner.\n\n        Optional keyword arg `checker` is the `OutputChecker` that\n        should be used to compare the expected outputs and actual\n        outputs of doctest examples.\n\n        Optional keyword arg 'verbose' prints lots of stuff if true,\n        only failures if false; by default, it's true iff '-v' is in\n        sys.argv.\n\n        Optional argument `optionflags` can be used to control how the\n        test runner compares expected output to actual output, and how\n        it displays failures.  See the documentation for `testmod` for\n        more information.\n        \"\"\"\n        self._checker = checker or OutputChecker()\n        if verbose is None:\n            verbose = '-v' in sys.argv\n        self._verbose = verbose\n        self.optionflags = optionflags\n        self.original_optionflags = optionflags\n\n        # Keep track of the examples we've run.\n        self.tries = 0\n        self.failures = 0\n        self.skips = 0\n        self._stats = {}\n\n        # Create a fake output target for capturing doctest output.\n        self._fakeout = _SpoofOut()\n\n    #/////////////////////////////////////////////////////////////////\n    # Reporting methods\n    #/////////////////////////////////////////////////////////////////\n\n    def report_start(self, out, test, example):\n        \"\"\"\n        Report that the test runner is about to process the given\n        example.  (Only displays a message if verbose=True)\n        \"\"\"\n        if self._verbose:\n            if example.want:\n                out('Trying:\\n' + _indent(example.source) +\n                    'Expecting:\\n' + _indent(example.want))\n            else:\n                out('Trying:\\n' + _indent(example.source) +\n                    'Expecting nothing\\n')\n\n    def report_success(self, out, test, example, got):\n        \"\"\"\n        Report that the given example ran successfully.  (Only\n        displays a message if verbose=True)\n        \"\"\"\n        if self._verbose:\n            out(\"ok\\n\")\n\n    def report_failure(self, out, test, example, got):\n        \"\"\"\n        Report that the given example failed.\n        \"\"\"\n        out(self._failure_header(test, example) +\n            self._checker.output_difference(example, got, self.optionflags))\n\n    def report_unexpected_exception(self, out, test, example, exc_info):\n        \"\"\"\n        Report that the given example raised an unexpected exception.\n        \"\"\"\n        out(self._failure_header(test, example) +\n            'Exception raised:\\n' + _indent(_exception_traceback(exc_info)))\n\n    def _failure_header(self, test, example):\n        red, reset = (\n            (ANSIColors.RED, ANSIColors.RESET) if can_colorize() else (\"\", \"\")\n        )\n        out = [f\"{red}{self.DIVIDER}{reset}\"]\n        if test.filename:\n            if test.lineno is not None and example.lineno is not None:\n                lineno = test.lineno + example.lineno + 1\n            else:\n                lineno = '?'\n            out.append('File \"%s\", line %s, in %s' %\n                       (test.filename, lineno, test.name))\n        else:\n            out.append('Line %s, in %s' % (example.lineno+1, test.name))\n        out.append('Failed example:')\n        source = example.source\n        out.append(_indent(source))\n        return '\\n'.join(out)\n\n    #/////////////////////////////////////////////////////////////////\n    # DocTest Running\n    #/////////////////////////////////////////////////////////////////\n\n    def __run(self, test, compileflags, out):\n        \"\"\"\n        Run the examples in `test`.  Write the outcome of each example\n        with one of the `DocTestRunner.report_*` methods, using the\n        writer function `out`.  `compileflags` is the set of compiler\n        flags that should be used to execute examples.  Return a TestResults\n        instance.  The examples are run in the namespace `test.globs`.\n        \"\"\"\n        # Keep track of the number of failed, attempted, skipped examples.\n        failures = attempted = skips = 0\n\n        # Save the option flags (since option directives can be used\n        # to modify them).\n        original_optionflags = self.optionflags\n\n        SUCCESS, FAILURE, BOOM = range(3) # `outcome` state\n\n        check = self._checker.check_output\n\n        # Process each example.\n        for examplenum, example in enumerate(test.examples):\n            attempted += 1\n\n            # If REPORT_ONLY_FIRST_FAILURE is set, then suppress\n            # reporting after the first failure.\n            quiet = (self.optionflags & REPORT_ONLY_FIRST_FAILURE and\n                     failures > 0)\n\n            # Merge in the example's options.\n            self.optionflags = original_optionflags\n            if example.options:\n                for (optionflag, val) in example.options.items():\n                    if val:\n                        self.optionflags |= optionflag\n                    else:\n                        self.optionflags &= ~optionflag\n\n            # If 'SKIP' is set, then skip this example.\n            if self.optionflags & SKIP:\n                skips += 1\n                continue\n\n            # Record that we started this example.\n            if not quiet:\n                self.report_start(out, test, example)\n\n            # Use a special filename for compile(), so we can retrieve\n            # the source code during interactive debugging (see\n            # __patched_linecache_getlines).\n            filename = '<doctest %s[%d]>' % (test.name, examplenum)\n\n            # Run the example in the given context (globs), and record\n            # any exception that gets raised.  (But don't intercept\n            # keyboard interrupts.)\n            try:\n                # Don't blink!  This is where the user's code gets run.\n                exec(compile(example.source, filename, \"single\",\n                             compileflags, True), test.globs)\n                self.debugger.set_continue() # ==== Example Finished ====\n                exception = None\n            except KeyboardInterrupt:\n                raise\n            except:\n                exception = sys.exc_info()\n                self.debugger.set_continue() # ==== Example Finished ====\n\n            got = self._fakeout.getvalue()  # the actual output\n            self._fakeout.truncate(0)\n            outcome = FAILURE   # guilty until proved innocent or insane\n\n            # If the example executed without raising any exceptions,\n            # verify its output.\n            if exception is None:\n                if check(example.want, got, self.optionflags):\n                    outcome = SUCCESS\n\n            # The example raised an exception:  check if it was expected.\n            else:\n                formatted_ex = traceback.format_exception_only(*exception[:2])\n                if issubclass(exception[0], SyntaxError):\n                    # SyntaxError / IndentationError is special:\n                    # we don't care about the carets / suggestions / etc\n                    # We only care about the error message and notes.\n                    # They start with `SyntaxError:` (or any other class name)\n                    exception_line_prefixes = (\n                        f\"{exception[0].__qualname__}:\",\n                        f\"{exception[0].__module__}.{exception[0].__qualname__}:\",\n                    )\n                    exc_msg_index = next(\n                        index\n                        for index, line in enumerate(formatted_ex)\n                        if line.startswith(exception_line_prefixes)\n                    )\n                    formatted_ex = formatted_ex[exc_msg_index:]\n\n                exc_msg = \"\".join(formatted_ex)\n                if not quiet:\n                    got += _exception_traceback(exception)\n\n                # If `example.exc_msg` is None, then we weren't expecting\n                # an exception.\n                if example.exc_msg is None:\n                    outcome = BOOM\n\n                # We expected an exception:  see whether it matches.\n                elif check(example.exc_msg, exc_msg, self.optionflags):\n                    outcome = SUCCESS\n\n                # Another chance if they didn't care about the detail.\n                elif self.optionflags & IGNORE_EXCEPTION_DETAIL:\n                    if check(_strip_exception_details(example.exc_msg),\n                             _strip_exception_details(exc_msg),\n                             self.optionflags):\n                        outcome = SUCCESS\n\n            # Report the outcome.\n            if outcome is SUCCESS:\n                if not quiet:\n                    self.report_success(out, test, example, got)\n            elif outcome is FAILURE:\n                if not quiet:\n                    self.report_failure(out, test, example, got)\n                failures += 1\n            elif outcome is BOOM:\n                if not quiet:\n                    self.report_unexpected_exception(out, test, example,\n                                                     exception)\n                failures += 1\n            else:\n                assert False, (\"unknown outcome\", outcome)\n\n            if failures and self.optionflags & FAIL_FAST:\n                break\n\n        # Restore the option flags (in case they were modified)\n        self.optionflags = original_optionflags\n\n        # Record and return the number of failures and attempted.\n        self.__record_outcome(test, failures, attempted, skips)\n        return TestResults(failures, attempted, skipped=skips)\n\n    def __record_outcome(self, test, failures, tries, skips):\n        \"\"\"\n        Record the fact that the given DocTest (`test`) generated `failures`\n        failures out of `tries` tried examples.\n        \"\"\"\n        failures2, tries2, skips2 = self._stats.get(test.name, (0, 0, 0))\n        self._stats[test.name] = (failures + failures2,\n                                  tries + tries2,\n                                  skips + skips2)\n        self.failures += failures\n        self.tries += tries\n        self.skips += skips\n\n    __LINECACHE_FILENAME_RE = re.compile(r'<doctest '\n                                         r'(?P<name>.+)'\n                                         r'\\[(?P<examplenum>\\d+)\\]>$')\n    def __patched_linecache_getlines(self, filename, module_globals=None):\n        m = self.__LINECACHE_FILENAME_RE.match(filename)\n        if m and m.group('name') == self.test.name:\n            example = self.test.examples[int(m.group('examplenum'))]\n            return example.source.splitlines(keepends=True)\n        else:\n            return self.save_linecache_getlines(filename, module_globals)\n\n    def run(self, test, compileflags=None, out=None, clear_globs=True):\n        \"\"\"\n        Run the examples in `test`, and display the results using the\n        writer function `out`.\n\n        The examples are run in the namespace `test.globs`.  If\n        `clear_globs` is true (the default), then this namespace will\n        be cleared after the test runs, to help with garbage\n        collection.  If you would like to examine the namespace after\n        the test completes, then use `clear_globs=False`.\n\n        `compileflags` gives the set of flags that should be used by\n        the Python compiler when running the examples.  If not\n        specified, then it will default to the set of future-import\n        flags that apply to `globs`.\n\n        The output of each example is checked using\n        `DocTestRunner.check_output`, and the results are formatted by\n        the `DocTestRunner.report_*` methods.\n        \"\"\"\n        self.test = test\n\n        if compileflags is None:\n            compileflags = _extract_future_flags(test.globs)\n\n        save_stdout = sys.stdout\n        if out is None:\n            encoding = save_stdout.encoding\n            if encoding is None or encoding.lower() == 'utf-8':\n                out = save_stdout.write\n            else:\n                # Use backslashreplace error handling on write\n                def out(s):\n                    s = str(s.encode(encoding, 'backslashreplace'), encoding)\n                    save_stdout.write(s)\n        sys.stdout = self._fakeout\n\n        # Patch pdb.set_trace to restore sys.stdout during interactive\n        # debugging (so it's not still redirected to self._fakeout).\n        # Note that the interactive output will go to *our*\n        # save_stdout, even if that's not the real sys.stdout; this\n        # allows us to write test cases for the set_trace behavior.\n        save_trace = sys.gettrace()\n        save_set_trace = pdb.set_trace\n        self.debugger = _OutputRedirectingPdb(save_stdout)\n        self.debugger.reset()\n        pdb.set_trace = self.debugger.set_trace\n\n        # Patch linecache.getlines, so we can see the example's source\n        # when we're inside the debugger.\n        self.save_linecache_getlines = linecache.getlines\n        linecache.getlines = self.__patched_linecache_getlines\n\n        # Make sure sys.displayhook just prints the value to stdout\n        save_displayhook = sys.displayhook\n        sys.displayhook = sys.__displayhook__\n        saved_can_colorize = _colorize.can_colorize\n        _colorize.can_colorize = lambda *args, **kwargs: False\n        color_variables = {\"PYTHON_COLORS\": None, \"FORCE_COLOR\": None}\n        for key in color_variables:\n            color_variables[key] = os.environ.pop(key, None)\n        try:\n            return self.__run(test, compileflags, out)\n        finally:\n            sys.stdout = save_stdout\n            pdb.set_trace = save_set_trace\n            sys.settrace(save_trace)\n            linecache.getlines = self.save_linecache_getlines\n            sys.displayhook = save_displayhook\n            _colorize.can_colorize = saved_can_colorize\n            for key, value in color_variables.items():\n                if value is not None:\n                    os.environ[key] = value\n            if clear_globs:\n                test.globs.clear()\n                import builtins\n                builtins._ = None\n\n    #/////////////////////////////////////////////////////////////////\n    # Summarization\n    #/////////////////////////////////////////////////////////////////\n    def summarize(self, verbose=None):\n        \"\"\"\n        Print a summary of all the test cases that have been run by\n        this DocTestRunner, and return a TestResults instance.\n\n        The optional `verbose` argument controls how detailed the\n        summary is.  If the verbosity is not specified, then the\n        DocTestRunner's verbosity is used.\n        \"\"\"\n        if verbose is None:\n            verbose = self._verbose\n\n        notests, passed, failed = [], [], []\n        total_tries = total_failures = total_skips = 0\n\n        for name, (failures, tries, skips) in self._stats.items():\n            assert failures <= tries\n            total_tries += tries\n            total_failures += failures\n            total_skips += skips\n\n            if tries == 0:\n                notests.append(name)\n            elif failures == 0:\n                passed.append((name, tries))\n            else:\n                failed.append((name, (failures, tries, skips)))\n\n        ansi = _colorize.get_colors()\n        bold_green = ansi.BOLD_GREEN\n        bold_red = ansi.BOLD_RED\n        green = ansi.GREEN\n        red = ansi.RED\n        reset = ansi.RESET\n        yellow = ansi.YELLOW\n\n        if verbose:\n            if notests:\n                print(f\"{_n_items(notests)} had no tests:\")\n                notests.sort()\n                for name in notests:\n                    print(f\"    {name}\")\n\n            if passed:\n                print(f\"{green}{_n_items(passed)} passed all tests:{reset}\")\n                for name, count in sorted(passed):\n                    s = \"\" if count == 1 else \"s\"\n                    print(f\" {green}{count:3d} test{s} in {name}{reset}\")\n\n        if failed:\n            print(f\"{red}{self.DIVIDER}{reset}\")\n            print(f\"{_n_items(failed)} had failures:\")\n            for name, (failures, tries, skips) in sorted(failed):\n                print(f\" {failures:3d} of {tries:3d} in {name}\")\n\n        if verbose:\n            s = \"\" if total_tries == 1 else \"s\"\n            print(f\"{total_tries} test{s} in {_n_items(self._stats)}.\")\n\n            and_f = (\n                f\" and {red}{total_failures} failed{reset}\"\n                if total_failures else \"\"\n            )\n            print(f\"{green}{total_tries - total_failures} passed{reset}{and_f}.\")\n\n        if total_failures:\n            s = \"\" if total_failures == 1 else \"s\"\n            msg = f\"{bold_red}***Test Failed*** {total_failures} failure{s}{reset}\"\n            if total_skips:\n                s = \"\" if total_skips == 1 else \"s\"\n                msg = f\"{msg} and {yellow}{total_skips} skipped test{s}{reset}\"\n            print(f\"{msg}.\")\n        elif verbose:\n            print(f\"{bold_green}Test passed.{reset}\")\n\n        return TestResults(total_failures, total_tries, skipped=total_skips)\n\n    #/////////////////////////////////////////////////////////////////\n    # Backward compatibility cruft to maintain doctest.master.\n    #/////////////////////////////////////////////////////////////////\n    def merge(self, other):\n        d = self._stats\n        for name, (failures, tries, skips) in other._stats.items():\n            if name in d:\n                failures2, tries2, skips2 = d[name]\n                failures = failures + failures2\n                tries = tries + tries2\n                skips = skips + skips2\n            d[name] = (failures, tries, skips)\n\n\ndef _n_items(items: list | dict) -> str:\n    \"\"\"\n    Helper to pluralise the number of items in a list.\n    \"\"\"\n    n = len(items)\n    s = \"\" if n == 1 else \"s\"\n    return f\"{n} item{s}\"\n\n\nclass OutputChecker:\n    \"\"\"\n    A class used to check whether the actual output from a doctest\n    example matches the expected output.  `OutputChecker` defines two\n    methods: `check_output`, which compares a given pair of outputs,\n    and returns true if they match; and `output_difference`, which\n    returns a string describing the differences between two outputs.\n    \"\"\"\n    def _toAscii(self, s):\n        \"\"\"\n        Convert string to hex-escaped ASCII string.\n        \"\"\"\n        return str(s.encode('ASCII', 'backslashreplace'), \"ASCII\")\n\n    def check_output(self, want, got, optionflags):\n        \"\"\"\n        Return True iff the actual output from an example (`got`)\n        matches the expected output (`want`).  These strings are\n        always considered to match if they are identical; but\n        depending on what option flags the test runner is using,\n        several non-exact match types are also possible.  See the\n        documentation for `TestRunner` for more information about\n        option flags.\n        \"\"\"\n\n        # If `want` contains hex-escaped character such as \"\\u1234\",\n        # then `want` is a string of six characters(e.g. [\\,u,1,2,3,4]).\n        # On the other hand, `got` could be another sequence of\n        # characters such as [\\u1234], so `want` and `got` should\n        # be folded to hex-escaped ASCII string to compare.\n        got = self._toAscii(got)\n        want = self._toAscii(want)\n\n        # Handle the common case first, for efficiency:\n        # if they're string-identical, always return true.\n        if got == want:\n            return True\n\n        # The values True and False replaced 1 and 0 as the return\n        # value for boolean comparisons in Python 2.3.\n        if not (optionflags & DONT_ACCEPT_TRUE_FOR_1):\n            if (got,want) == (\"True\\n\", \"1\\n\"):\n                return True\n            if (got,want) == (\"False\\n\", \"0\\n\"):\n                return True\n\n        # <BLANKLINE> can be used as a special sequence to signify a\n        # blank line, unless the DONT_ACCEPT_BLANKLINE flag is used.\n        if not (optionflags & DONT_ACCEPT_BLANKLINE):\n            # Replace <BLANKLINE> in want with a blank line.\n            want = re.sub(r'(?m)^%s\\s*?$' % re.escape(BLANKLINE_MARKER),\n                          '', want)\n            # If a line in got contains only spaces, then remove the\n            # spaces.\n            got = re.sub(r'(?m)^[^\\S\\n]+$', '', got)\n            if got == want:\n                return True\n\n        # This flag causes doctest to ignore any differences in the\n        # contents of whitespace strings.  Note that this can be used\n        # in conjunction with the ELLIPSIS flag.\n        if optionflags & NORMALIZE_WHITESPACE:\n            got = ' '.join(got.split())\n            want = ' '.join(want.split())\n            if got == want:\n                return True\n\n        # The ELLIPSIS flag says to let the sequence \"...\" in `want`\n        # match any substring in `got`.\n        if optionflags & ELLIPSIS:\n            if _ellipsis_match(want, got):\n                return True\n\n        # We didn't find any match; return false.\n        return False\n\n    # Should we do a fancy diff?\n    def _do_a_fancy_diff(self, want, got, optionflags):\n        # Not unless they asked for a fancy diff.\n        if not optionflags & (REPORT_UDIFF |\n                              REPORT_CDIFF |\n                              REPORT_NDIFF):\n            return False\n\n        # If expected output uses ellipsis, a meaningful fancy diff is\n        # too hard ... or maybe not.  In two real-life failures Tim saw,\n        # a diff was a major help anyway, so this is commented out.\n        # [todo] _ellipsis_match() knows which pieces do and don't match,\n        # and could be the basis for a kick-ass diff in this case.\n        ##if optionflags & ELLIPSIS and ELLIPSIS_MARKER in want:\n        ##    return False\n\n        # ndiff does intraline difference marking, so can be useful even\n        # for 1-line differences.\n        if optionflags & REPORT_NDIFF:\n            return True\n\n        # The other diff types need at least a few lines to be helpful.\n        return want.count('\\n') > 2 and got.count('\\n') > 2\n\n    def output_difference(self, example, got, optionflags):\n        \"\"\"\n        Return a string describing the differences between the\n        expected output for a given example (`example`) and the actual\n        output (`got`).  `optionflags` is the set of option flags used\n        to compare `want` and `got`.\n        \"\"\"\n        want = example.want\n        # If <BLANKLINE>s are being used, then replace blank lines\n        # with <BLANKLINE> in the actual output string.\n        if not (optionflags & DONT_ACCEPT_BLANKLINE):\n            got = re.sub('(?m)^[ ]*(?=\\n)', BLANKLINE_MARKER, got)\n\n        # Check if we should use diff.\n        if self._do_a_fancy_diff(want, got, optionflags):\n            # Split want & got into lines.\n            want_lines = want.splitlines(keepends=True)\n            got_lines = got.splitlines(keepends=True)\n            # Use difflib to find their differences.\n            if optionflags & REPORT_UDIFF:\n                diff = difflib.unified_diff(want_lines, got_lines, n=2)\n                diff = list(diff)[2:] # strip the diff header\n                kind = 'unified diff with -expected +actual'\n            elif optionflags & REPORT_CDIFF:\n                diff = difflib.context_diff(want_lines, got_lines, n=2)\n                diff = list(diff)[2:] # strip the diff header\n                kind = 'context diff with expected followed by actual'\n            elif optionflags & REPORT_NDIFF:\n                engine = difflib.Differ(charjunk=difflib.IS_CHARACTER_JUNK)\n                diff = list(engine.compare(want_lines, got_lines))\n                kind = 'ndiff with -expected +actual'\n            else:\n                assert 0, 'Bad diff option'\n            return 'Differences (%s):\\n' % kind + _indent(''.join(diff))\n\n        # If we're not using diff, then simply list the expected\n        # output followed by the actual output.\n        if want and got:\n            return 'Expected:\\n%sGot:\\n%s' % (_indent(want), _indent(got))\n        elif want:\n            return 'Expected:\\n%sGot nothing\\n' % _indent(want)\n        elif got:\n            return 'Expected nothing\\nGot:\\n%s' % _indent(got)\n        else:\n            return 'Expected nothing\\nGot nothing\\n'\n\nclass DocTestFailure(Exception):\n    \"\"\"A DocTest example has failed in debugging mode.\n\n    The exception instance has variables:\n\n    - test: the DocTest object being run\n\n    - example: the Example object that failed\n\n    - got: the actual output\n    \"\"\"\n    def __init__(self, test, example, got):\n        self.test = test\n        self.example = example\n        self.got = got\n\n    def __str__(self):\n        return str(self.test)\n\nclass UnexpectedException(Exception):\n    \"\"\"A DocTest example has encountered an unexpected exception\n\n    The exception instance has variables:\n\n    - test: the DocTest object being run\n\n    - example: the Example object that failed\n\n    - exc_info: the exception info\n    \"\"\"\n    def __init__(self, test, example, exc_info):\n        self.test = test\n        self.example = example\n        self.exc_info = exc_info\n\n    def __str__(self):\n        return str(self.test)\n\nclass DebugRunner(DocTestRunner):\n    r\"\"\"Run doc tests but raise an exception as soon as there is a failure.\n\n       If an unexpected exception occurs, an UnexpectedException is raised.\n       It contains the test, the example, and the original exception:\n\n         >>> runner = DebugRunner(verbose=False)\n         >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n         ...                                    {}, 'foo', 'foo.py', 0)\n         >>> try:\n         ...     runner.run(test)\n         ... except UnexpectedException as f:\n         ...     failure = f\n\n         >>> failure.test is test\n         True\n\n         >>> failure.example.want\n         '42\\n'\n\n         >>> exc_info = failure.exc_info\n         >>> raise exc_info[1] # Already has the traceback\n         Traceback (most recent call last):\n         ...\n         KeyError\n\n       We wrap the original exception to give the calling application\n       access to the test and example information.\n\n       If the output doesn't match, then a DocTestFailure is raised:\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 1\n         ...      >>> x\n         ...      2\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> try:\n         ...    runner.run(test)\n         ... except DocTestFailure as f:\n         ...    failure = f\n\n       DocTestFailure objects provide access to the test:\n\n         >>> failure.test is test\n         True\n\n       As well as to the example:\n\n         >>> failure.example.want\n         '2\\n'\n\n       and the actual output:\n\n         >>> failure.got\n         '1\\n'\n\n       If a failure or error occurs, the globals are left intact:\n\n         >>> del test.globs['__builtins__']\n         >>> test.globs\n         {'x': 1}\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 2\n         ...      >>> raise KeyError\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> runner.run(test)\n         Traceback (most recent call last):\n         ...\n         doctest.UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>\n\n         >>> del test.globs['__builtins__']\n         >>> test.globs\n         {'x': 2}\n\n       But the globals are cleared if there is no error:\n\n         >>> test = DocTestParser().get_doctest('''\n         ...      >>> x = 2\n         ...      ''', {}, 'foo', 'foo.py', 0)\n\n         >>> runner.run(test)\n         TestResults(failed=0, attempted=1)\n\n         >>> test.globs\n         {}\n\n       \"\"\"\n\n    def run(self, test, compileflags=None, out=None, clear_globs=True):\n        r = DocTestRunner.run(self, test, compileflags, out, False)\n        if clear_globs:\n            test.globs.clear()\n        return r\n\n    def report_unexpected_exception(self, out, test, example, exc_info):\n        raise UnexpectedException(test, example, exc_info)\n\n    def report_failure(self, out, test, example, got):\n        raise DocTestFailure(test, example, got)\n\n######################################################################\n## 6. Test Functions\n######################################################################\n# These should be backwards compatible.\n\n# For backward compatibility, a global instance of a DocTestRunner\n# class, updated by testmod.\nmaster = None\n\ndef testmod(m=None, name=None, globs=None, verbose=None,\n            report=True, optionflags=0, extraglobs=None,\n            raise_on_error=False, exclude_empty=False):\n    \"\"\"m=None, name=None, globs=None, verbose=None, report=True,\n       optionflags=0, extraglobs=None, raise_on_error=False,\n       exclude_empty=False\n\n    Test examples in docstrings in functions and classes reachable\n    from module m (or the current module if m is not supplied), starting\n    with m.__doc__.\n\n    Also test examples reachable from dict m.__test__ if it exists and is\n    not None.  m.__test__ maps names to functions, classes and strings;\n    function and class docstrings are tested even if the name is private;\n    strings are tested directly, as if they were docstrings.\n\n    Return (#failures, #tests).\n\n    See help(doctest) for an overview.\n\n    Optional keyword arg \"name\" gives the name of the module; by default\n    use m.__name__.\n\n    Optional keyword arg \"globs\" gives a dict to be used as the globals\n    when executing examples; by default, use m.__dict__.  A copy of this\n    dict is actually used for each docstring, so that each docstring's\n    examples start with a clean slate.\n\n    Optional keyword arg \"extraglobs\" gives a dictionary that should be\n    merged into the globals that are used to execute examples.  By\n    default, no extra globals are used.  This is new in 2.4.\n\n    Optional keyword arg \"verbose\" prints lots of stuff if true, prints\n    only failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\n    Optional keyword arg \"report\" prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Optional keyword arg \"optionflags\" or's together module constants,\n    and defaults to 0.  This is new in 2.3.  Possible values (see the\n    docs for details):\n\n        DONT_ACCEPT_TRUE_FOR_1\n        DONT_ACCEPT_BLANKLINE\n        NORMALIZE_WHITESPACE\n        ELLIPSIS\n        SKIP\n        IGNORE_EXCEPTION_DETAIL\n        REPORT_UDIFF\n        REPORT_CDIFF\n        REPORT_NDIFF\n        REPORT_ONLY_FIRST_FAILURE\n\n    Optional keyword arg \"raise_on_error\" raises an exception on the\n    first unexpected exception or failure. This allows failures to be\n    post-mortem debugged.\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you're done fiddling.\n    \"\"\"\n    global master\n\n    # If no module was given, then use __main__.\n    if m is None:\n        # DWA - m will still be None if this wasn't invoked from the command\n        # line, in which case the following TypeError is about as good an error\n        # as we should expect\n        m = sys.modules.get('__main__')\n\n    # Check that we were actually given a module.\n    if not inspect.ismodule(m):\n        raise TypeError(\"testmod: module required; %r\" % (m,))\n\n    # If no name was given, then use the module's name.\n    if name is None:\n        name = m.__name__\n\n    # Find, parse, and run all tests in the given module.\n    finder = DocTestFinder(exclude_empty=exclude_empty)\n\n    if raise_on_error:\n        runner = DebugRunner(verbose=verbose, optionflags=optionflags)\n    else:\n        runner = DocTestRunner(verbose=verbose, optionflags=optionflags)\n\n    for test in finder.find(m, name, globs=globs, extraglobs=extraglobs):\n        runner.run(test)\n\n    if report:\n        runner.summarize()\n\n    if master is None:\n        master = runner\n    else:\n        master.merge(runner)\n\n    return TestResults(runner.failures, runner.tries, skipped=runner.skips)\n\n\ndef testfile(filename, module_relative=True, name=None, package=None,\n             globs=None, verbose=None, report=True, optionflags=0,\n             extraglobs=None, raise_on_error=False, parser=DocTestParser(),\n             encoding=None):\n    \"\"\"\n    Test examples in the given file.  Return (#failures, #tests).\n\n    Optional keyword arg \"module_relative\" specifies how filenames\n    should be interpreted:\n\n      - If \"module_relative\" is True (the default), then \"filename\"\n         specifies a module-relative path.  By default, this path is\n         relative to the calling module's directory; but if the\n         \"package\" argument is specified, then it is relative to that\n         package.  To ensure os-independence, \"filename\" should use\n         \"/\" characters to separate path segments, and should not\n         be an absolute path (i.e., it may not begin with \"/\").\n\n      - If \"module_relative\" is False, then \"filename\" specifies an\n        os-specific path.  The path may be absolute or relative (to\n        the current working directory).\n\n    Optional keyword arg \"name\" gives the name of the test; by default\n    use the file's basename.\n\n    Optional keyword argument \"package\" is a Python package or the\n    name of a Python package whose directory should be used as the\n    base directory for a module relative filename.  If no package is\n    specified, then the calling module's directory is used as the base\n    directory for module relative filenames.  It is an error to\n    specify \"package\" if \"module_relative\" is False.\n\n    Optional keyword arg \"globs\" gives a dict to be used as the globals\n    when executing examples; by default, use {}.  A copy of this dict\n    is actually used for each docstring, so that each docstring's\n    examples start with a clean slate.\n\n    Optional keyword arg \"extraglobs\" gives a dictionary that should be\n    merged into the globals that are used to execute examples.  By\n    default, no extra globals are used.\n\n    Optional keyword arg \"verbose\" prints lots of stuff if true, prints\n    only failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\n    Optional keyword arg \"report\" prints a summary at the end when true,\n    else prints nothing at the end.  In verbose mode, the summary is\n    detailed, else very brief (in fact, empty if all tests passed).\n\n    Optional keyword arg \"optionflags\" or's together module constants,\n    and defaults to 0.  Possible values (see the docs for details):\n\n        DONT_ACCEPT_TRUE_FOR_1\n        DONT_ACCEPT_BLANKLINE\n        NORMALIZE_WHITESPACE\n        ELLIPSIS\n        SKIP\n        IGNORE_EXCEPTION_DETAIL\n        REPORT_UDIFF\n        REPORT_CDIFF\n        REPORT_NDIFF\n        REPORT_ONLY_FIRST_FAILURE\n\n    Optional keyword arg \"raise_on_error\" raises an exception on the\n    first unexpected exception or failure. This allows failures to be\n    post-mortem debugged.\n\n    Optional keyword arg \"parser\" specifies a DocTestParser (or\n    subclass) that should be used to extract tests from the files.\n\n    Optional keyword arg \"encoding\" specifies an encoding that should\n    be used to convert the file to unicode.\n\n    Advanced tomfoolery:  testmod runs methods of a local instance of\n    class doctest.Tester, then merges the results into (or creates)\n    global Tester instance doctest.master.  Methods of doctest.master\n    can be called directly too, if you want to do something unusual.\n    Passing report=0 to testmod is especially useful then, to delay\n    displaying a summary.  Invoke doctest.master.summarize(verbose)\n    when you're done fiddling.\n    \"\"\"\n    global master\n\n    if package and not module_relative:\n        raise ValueError(\"Package may only be specified for module-\"\n                         \"relative paths.\")\n\n    # Relativize the path\n    text, filename = _load_testfile(filename, package, module_relative,\n                                    encoding or \"utf-8\")\n\n    # If no name was given, then use the file's name.\n    if name is None:\n        name = os.path.basename(filename)\n\n    # Assemble the globals.\n    if globs is None:\n        globs = {}\n    else:\n        globs = globs.copy()\n    if extraglobs is not None:\n        globs.update(extraglobs)\n    if '__name__' not in globs:\n        globs['__name__'] = '__main__'\n\n    if raise_on_error:\n        runner = DebugRunner(verbose=verbose, optionflags=optionflags)\n    else:\n        runner = DocTestRunner(verbose=verbose, optionflags=optionflags)\n\n    # Read the file, convert it to a test, and run it.\n    test = parser.get_doctest(text, globs, name, filename, 0)\n    runner.run(test)\n\n    if report:\n        runner.summarize()\n\n    if master is None:\n        master = runner\n    else:\n        master.merge(runner)\n\n    return TestResults(runner.failures, runner.tries, skipped=runner.skips)\n\n\ndef run_docstring_examples(f, globs, verbose=False, name=\"NoName\",\n                           compileflags=None, optionflags=0):\n    \"\"\"\n    Test examples in the given object's docstring (`f`), using `globs`\n    as globals.  Optional argument `name` is used in failure messages.\n    If the optional argument `verbose` is true, then generate output\n    even if there are no failures.\n\n    `compileflags` gives the set of flags that should be used by the\n    Python compiler when running the examples.  If not specified, then\n    it will default to the set of future-import flags that apply to\n    `globs`.\n\n    Optional keyword arg `optionflags` specifies options for the\n    testing and output.  See the documentation for `testmod` for more\n    information.\n    \"\"\"\n    # Find, parse, and run all tests in the given module.\n    finder = DocTestFinder(verbose=verbose, recurse=False)\n    runner = DocTestRunner(verbose=verbose, optionflags=optionflags)\n    for test in finder.find(f, name, globs=globs):\n        runner.run(test, compileflags=compileflags)\n\n######################################################################\n## 7. Unittest Support\n######################################################################\n\n_unittest_reportflags = 0\n\ndef set_unittest_reportflags(flags):\n    \"\"\"Sets the unittest option flags.\n\n    The old flag is returned so that a runner could restore the old\n    value if it wished to:\n\n      >>> import doctest\n      >>> old = doctest._unittest_reportflags\n      >>> doctest.set_unittest_reportflags(REPORT_NDIFF |\n      ...                          REPORT_ONLY_FIRST_FAILURE) == old\n      True\n\n      >>> doctest._unittest_reportflags == (REPORT_NDIFF |\n      ...                                   REPORT_ONLY_FIRST_FAILURE)\n      True\n\n    Only reporting flags can be set:\n\n      >>> doctest.set_unittest_reportflags(ELLIPSIS)\n      Traceback (most recent call last):\n      ...\n      ValueError: ('Only reporting flags allowed', 8)\n\n      >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |\n      ...                                   REPORT_ONLY_FIRST_FAILURE)\n      True\n    \"\"\"\n    global _unittest_reportflags\n\n    if (flags & REPORTING_FLAGS) != flags:\n        raise ValueError(\"Only reporting flags allowed\", flags)\n    old = _unittest_reportflags\n    _unittest_reportflags = flags\n    return old\n\n\nclass DocTestCase(unittest.TestCase):\n\n    def __init__(self, test, optionflags=0, setUp=None, tearDown=None,\n                 checker=None):\n\n        unittest.TestCase.__init__(self)\n        self._dt_optionflags = optionflags\n        self._dt_checker = checker\n        self._dt_test = test\n        self._dt_setUp = setUp\n        self._dt_tearDown = tearDown\n\n    def setUp(self):\n        test = self._dt_test\n        self._dt_globs = test.globs.copy()\n\n        if self._dt_setUp is not None:\n            self._dt_setUp(test)\n\n    def tearDown(self):\n        test = self._dt_test\n\n        if self._dt_tearDown is not None:\n            self._dt_tearDown(test)\n\n        # restore the original globs\n        test.globs.clear()\n        test.globs.update(self._dt_globs)\n\n    def runTest(self):\n        test = self._dt_test\n        old = sys.stdout\n        new = StringIO()\n        optionflags = self._dt_optionflags\n\n        if not (optionflags & REPORTING_FLAGS):\n            # The option flags don't include any reporting flags,\n            # so add the default reporting flags\n            optionflags |= _unittest_reportflags\n\n        runner = DocTestRunner(optionflags=optionflags,\n                               checker=self._dt_checker, verbose=False)\n\n        try:\n            runner.DIVIDER = \"-\"*70\n            results = runner.run(test, out=new.write, clear_globs=False)\n            if results.skipped == results.attempted:\n                raise unittest.SkipTest(\"all examples were skipped\")\n        finally:\n            sys.stdout = old\n\n        if results.failed:\n            raise self.failureException(self.format_failure(new.getvalue()))\n\n    def format_failure(self, err):\n        test = self._dt_test\n        if test.lineno is None:\n            lineno = 'unknown line number'\n        else:\n            lineno = '%s' % test.lineno\n        lname = '.'.join(test.name.split('.')[-1:])\n        return ('Failed doctest test for %s\\n'\n                '  File \"%s\", line %s, in %s\\n\\n%s'\n                % (test.name, test.filename, lineno, lname, err)\n                )\n\n    def debug(self):\n        r\"\"\"Run the test case without results and without catching exceptions\n\n           The unit test framework includes a debug method on test cases\n           and test suites to support post-mortem debugging.  The test code\n           is run in such a way that errors are not caught.  This way a\n           caller can catch the errors and initiate post-mortem debugging.\n\n           The DocTestCase provides a debug method that raises\n           UnexpectedException errors if there is an unexpected\n           exception:\n\n             >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n             ...                {}, 'foo', 'foo.py', 0)\n             >>> case = DocTestCase(test)\n             >>> try:\n             ...     case.debug()\n             ... except UnexpectedException as f:\n             ...     failure = f\n\n           The UnexpectedException contains the test, the example, and\n           the original exception:\n\n             >>> failure.test is test\n             True\n\n             >>> failure.example.want\n             '42\\n'\n\n             >>> exc_info = failure.exc_info\n             >>> raise exc_info[1] # Already has the traceback\n             Traceback (most recent call last):\n             ...\n             KeyError\n\n           If the output doesn't match, then a DocTestFailure is raised:\n\n             >>> test = DocTestParser().get_doctest('''\n             ...      >>> x = 1\n             ...      >>> x\n             ...      2\n             ...      ''', {}, 'foo', 'foo.py', 0)\n             >>> case = DocTestCase(test)\n\n             >>> try:\n             ...    case.debug()\n             ... except DocTestFailure as f:\n             ...    failure = f\n\n           DocTestFailure objects provide access to the test:\n\n             >>> failure.test is test\n             True\n\n           As well as to the example:\n\n             >>> failure.example.want\n             '2\\n'\n\n           and the actual output:\n\n             >>> failure.got\n             '1\\n'\n\n           \"\"\"\n\n        self.setUp()\n        runner = DebugRunner(optionflags=self._dt_optionflags,\n                             checker=self._dt_checker, verbose=False)\n        runner.run(self._dt_test, clear_globs=False)\n        self.tearDown()\n\n    def id(self):\n        return self._dt_test.name\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return NotImplemented\n\n        return self._dt_test == other._dt_test and \\\n               self._dt_optionflags == other._dt_optionflags and \\\n               self._dt_setUp == other._dt_setUp and \\\n               self._dt_tearDown == other._dt_tearDown and \\\n               self._dt_checker == other._dt_checker\n\n    def __hash__(self):\n        return hash((self._dt_optionflags, self._dt_setUp, self._dt_tearDown,\n                     self._dt_checker))\n\n    def __repr__(self):\n        name = self._dt_test.name.split('.')\n        return \"%s (%s)\" % (name[-1], '.'.join(name[:-1]))\n\n    __str__ = object.__str__\n\n    def shortDescription(self):\n        return \"Doctest: \" + self._dt_test.name\n\nclass SkipDocTestCase(DocTestCase):\n    def __init__(self, module):\n        self.module = module\n        DocTestCase.__init__(self, None)\n\n    def setUp(self):\n        self.skipTest(\"DocTestSuite will not work with -O2 and above\")\n\n    def test_skip(self):\n        pass\n\n    def shortDescription(self):\n        return \"Skipping tests from %s\" % self.module.__name__\n\n    __str__ = shortDescription\n\n\nclass _DocTestSuite(unittest.TestSuite):\n\n    def _removeTestAtIndex(self, index):\n        pass\n\n\ndef DocTestSuite(module=None, globs=None, extraglobs=None, test_finder=None,\n                 **options):\n    \"\"\"\n    Convert doctest tests for a module to a unittest test suite.\n\n    This converts each documentation string in a module that\n    contains doctest tests to a unittest test case.  If any of the\n    tests in a doc string fail, then the test case fails.  An exception\n    is raised showing the name of the file containing the test and a\n    (sometimes approximate) line number.\n\n    The `module` argument provides the module to be tested.  The argument\n    can be either a module or a module name.\n\n    If no argument is given, the calling module is used.\n\n    A number of options may be provided as keyword arguments:\n\n    setUp\n      A set-up function.  This is called before running the\n      tests in each file. The setUp function will be passed a DocTest\n      object.  The setUp function can access the test globals as the\n      globs attribute of the test passed.\n\n    tearDown\n      A tear-down function.  This is called after running the\n      tests in each file.  The tearDown function will be passed a DocTest\n      object.  The tearDown function can access the test globals as the\n      globs attribute of the test passed.\n\n    globs\n      A dictionary containing initial global variables for the tests.\n\n    optionflags\n       A set of doctest option flags expressed as an integer.\n    \"\"\"\n\n    if test_finder is None:\n        test_finder = DocTestFinder()\n\n    module = _normalize_module(module)\n    tests = test_finder.find(module, globs=globs, extraglobs=extraglobs)\n\n    if not tests and sys.flags.optimize >=2:\n        # Skip doctests when running with -O2\n        suite = _DocTestSuite()\n        suite.addTest(SkipDocTestCase(module))\n        return suite\n\n    tests.sort()\n    suite = _DocTestSuite()\n\n    for test in tests:\n        if len(test.examples) == 0:\n            continue\n        if not test.filename:\n            filename = module.__file__\n            if filename[-4:] == \".pyc\":\n                filename = filename[:-1]\n            test.filename = filename\n        suite.addTest(DocTestCase(test, **options))\n\n    return suite\n\nclass DocFileCase(DocTestCase):\n\n    def id(self):\n        return '_'.join(self._dt_test.name.split('.'))\n\n    def __repr__(self):\n        return self._dt_test.filename\n\n    def format_failure(self, err):\n        return ('Failed doctest test for %s\\n  File \"%s\", line 0\\n\\n%s'\n                % (self._dt_test.name, self._dt_test.filename, err)\n                )\n\ndef DocFileTest(path, module_relative=True, package=None,\n                globs=None, parser=DocTestParser(),\n                encoding=None, **options):\n    if globs is None:\n        globs = {}\n    else:\n        globs = globs.copy()\n\n    if package and not module_relative:\n        raise ValueError(\"Package may only be specified for module-\"\n                         \"relative paths.\")\n\n    # Relativize the path.\n    doc, path = _load_testfile(path, package, module_relative,\n                               encoding or \"utf-8\")\n\n    if \"__file__\" not in globs:\n        globs[\"__file__\"] = path\n\n    # Find the file and read it.\n    name = os.path.basename(path)\n\n    # Convert it to a test, and wrap it in a DocFileCase.\n    test = parser.get_doctest(doc, globs, name, path, 0)\n    return DocFileCase(test, **options)\n\ndef DocFileSuite(*paths, **kw):\n    \"\"\"A unittest suite for one or more doctest files.\n\n    The path to each doctest file is given as a string; the\n    interpretation of that string depends on the keyword argument\n    \"module_relative\".\n\n    A number of options may be provided as keyword arguments:\n\n    module_relative\n      If \"module_relative\" is True, then the given file paths are\n      interpreted as os-independent module-relative paths.  By\n      default, these paths are relative to the calling module's\n      directory; but if the \"package\" argument is specified, then\n      they are relative to that package.  To ensure os-independence,\n      \"filename\" should use \"/\" characters to separate path\n      segments, and may not be an absolute path (i.e., it may not\n      begin with \"/\").\n\n      If \"module_relative\" is False, then the given file paths are\n      interpreted as os-specific paths.  These paths may be absolute\n      or relative (to the current working directory).\n\n    package\n      A Python package or the name of a Python package whose directory\n      should be used as the base directory for module relative paths.\n      If \"package\" is not specified, then the calling module's\n      directory is used as the base directory for module relative\n      filenames.  It is an error to specify \"package\" if\n      \"module_relative\" is False.\n\n    setUp\n      A set-up function.  This is called before running the\n      tests in each file. The setUp function will be passed a DocTest\n      object.  The setUp function can access the test globals as the\n      globs attribute of the test passed.\n\n    tearDown\n      A tear-down function.  This is called after running the\n      tests in each file.  The tearDown function will be passed a DocTest\n      object.  The tearDown function can access the test globals as the\n      globs attribute of the test passed.\n\n    globs\n      A dictionary containing initial global variables for the tests.\n\n    optionflags\n      A set of doctest option flags expressed as an integer.\n\n    parser\n      A DocTestParser (or subclass) that should be used to extract\n      tests from the files.\n\n    encoding\n      An encoding that will be used to convert the files to unicode.\n    \"\"\"\n    suite = _DocTestSuite()\n\n    # We do this here so that _normalize_module is called at the right\n    # level.  If it were called in DocFileTest, then this function\n    # would be the caller and we might guess the package incorrectly.\n    if kw.get('module_relative', True):\n        kw['package'] = _normalize_module(kw.get('package'))\n\n    for path in paths:\n        suite.addTest(DocFileTest(path, **kw))\n\n    return suite\n\n######################################################################\n## 8. Debugging Support\n######################################################################\n\ndef script_from_examples(s):\n    r\"\"\"Extract script from text with examples.\n\n       Converts text with examples to a Python script.  Example input is\n       converted to regular code.  Example output and all other words\n       are converted to comments:\n\n       >>> text = '''\n       ...       Here are examples of simple math.\n       ...\n       ...           Python has super accurate integer addition\n       ...\n       ...           >>> 2 + 2\n       ...           5\n       ...\n       ...           And very friendly error messages:\n       ...\n       ...           >>> 1/0\n       ...           To Infinity\n       ...           And\n       ...           Beyond\n       ...\n       ...           You can use logic if you want:\n       ...\n       ...           >>> if 0:\n       ...           ...    blah\n       ...           ...    blah\n       ...           ...\n       ...\n       ...           Ho hum\n       ...           '''\n\n       >>> print(script_from_examples(text))\n       # Here are examples of simple math.\n       #\n       #     Python has super accurate integer addition\n       #\n       2 + 2\n       # Expected:\n       ## 5\n       #\n       #     And very friendly error messages:\n       #\n       1/0\n       # Expected:\n       ## To Infinity\n       ## And\n       ## Beyond\n       #\n       #     You can use logic if you want:\n       #\n       if 0:\n          blah\n          blah\n       #\n       #     Ho hum\n       <BLANKLINE>\n       \"\"\"\n    output = []\n    for piece in DocTestParser().parse(s):\n        if isinstance(piece, Example):\n            # Add the example's source code (strip trailing NL)\n            output.append(piece.source[:-1])\n            # Add the expected output:\n            want = piece.want\n            if want:\n                output.append('# Expected:')\n                output += ['## '+l for l in want.split('\\n')[:-1]]\n        else:\n            # Add non-example text.\n            output += [_comment_line(l)\n                       for l in piece.split('\\n')[:-1]]\n\n    # Trim junk on both ends.\n    while output and output[-1] == '#':\n        output.pop()\n    while output and output[0] == '#':\n        output.pop(0)\n    # Combine the output, and return it.\n    # Add a courtesy newline to prevent exec from choking (see bug #1172785)\n    return '\\n'.join(output) + '\\n'\n\ndef testsource(module, name):\n    \"\"\"Extract the test sources from a doctest docstring as a script.\n\n    Provide the module (or dotted name of the module) containing the\n    test to be debugged and the name (within the module) of the object\n    with the doc string with tests to be debugged.\n    \"\"\"\n    module = _normalize_module(module)\n    tests = DocTestFinder().find(module)\n    test = [t for t in tests if t.name == name]\n    if not test:\n        raise ValueError(name, \"not found in tests\")\n    test = test[0]\n    testsrc = script_from_examples(test.docstring)\n    return testsrc\n\ndef debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)\n\ndef debug_script(src, pm=False, globs=None):\n    \"Debug a test script.  `src` is the script, as a string.\"\n    import pdb\n\n    if globs:\n        globs = globs.copy()\n    else:\n        globs = {}\n\n    if pm:\n        try:\n            exec(src, globs, globs)\n        except:\n            print(sys.exc_info()[1])\n            p = pdb.Pdb(nosigint=True)\n            p.reset()\n            p.interaction(None, sys.exc_info()[2])\n    else:\n        pdb.Pdb(nosigint=True).run(\"exec(%r)\" % src, globs, globs)\n\ndef debug(module, name, pm=False):\n    \"\"\"Debug a single doctest docstring.\n\n    Provide the module (or dotted name of the module) containing the\n    test to be debugged and the name (within the module) of the object\n    with the docstring with tests to be debugged.\n    \"\"\"\n    module = _normalize_module(module)\n    testsrc = testsource(module, name)\n    debug_script(testsrc, pm, module.__dict__)\n\n######################################################################\n## 9. Example Usage\n######################################################################\nclass _TestClass:\n    \"\"\"\n    A pointless class, for sanity-checking of docstring testing.\n\n    Methods:\n        square()\n        get()\n\n    >>> _TestClass(13).get() + _TestClass(-12).get()\n    1\n    >>> hex(_TestClass(13).square().get())\n    '0xa9'\n    \"\"\"\n\n    def __init__(self, val):\n        \"\"\"val -> _TestClass object with associated value val.\n\n        >>> t = _TestClass(123)\n        >>> print(t.get())\n        123\n        \"\"\"\n\n        self.val = val\n\n    def square(self):\n        \"\"\"square() -> square TestClass's associated value\n\n        >>> _TestClass(13).square().get()\n        169\n        \"\"\"\n\n        self.val = self.val ** 2\n        return self\n\n    def get(self):\n        \"\"\"get() -> return TestClass's associated value.\n\n        >>> x = _TestClass(-42)\n        >>> print(x.get())\n        -42\n        \"\"\"\n\n        return self.val\n\n__test__ = {\"_TestClass\": _TestClass,\n            \"string\": r\"\"\"\n                      Example of a string object, searched as-is.\n                      >>> x = 1; y = 2\n                      >>> x + y, x * y\n                      (3, 2)\n                      \"\"\",\n\n            \"bool-int equivalence\": r\"\"\"\n                                    In 2.2, boolean expressions displayed\n                                    0 or 1.  By default, we still accept\n                                    them.  This can be disabled by passing\n                                    DONT_ACCEPT_TRUE_FOR_1 to the new\n                                    optionflags argument.\n                                    >>> 4 == 4\n                                    1\n                                    >>> 4 == 4\n                                    True\n                                    >>> 4 > 4\n                                    0\n                                    >>> 4 > 4\n                                    False\n                                    \"\"\",\n\n            \"blank lines\": r\"\"\"\n                Blank lines can be marked with <BLANKLINE>:\n                    >>> print('foo\\n\\nbar\\n')\n                    foo\n                    <BLANKLINE>\n                    bar\n                    <BLANKLINE>\n            \"\"\",\n\n            \"ellipsis\": r\"\"\"\n                If the ellipsis flag is used, then '...' can be used to\n                elide substrings in the desired output:\n                    >>> print(list(range(1000))) #doctest: +ELLIPSIS\n                    [0, 1, 2, ..., 999]\n            \"\"\",\n\n            \"whitespace normalization\": r\"\"\"\n                If the whitespace normalization flag is used, then\n                differences in whitespace are ignored.\n                    >>> print(list(range(30))) #doctest: +NORMALIZE_WHITESPACE\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n                     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n                     27, 28, 29]\n            \"\"\",\n           }\n\n\ndef _test():\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"doctest runner\")\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='print very verbose output for all tests')\n    parser.add_argument('-o', '--option', action='append',\n                        choices=OPTIONFLAGS_BY_NAME.keys(), default=[],\n                        help=('specify a doctest option flag to apply'\n                              ' to the test run; may be specified more'\n                              ' than once to apply multiple options'))\n    parser.add_argument('-f', '--fail-fast', action='store_true',\n                        help=('stop running tests after first failure (this'\n                              ' is a shorthand for -o FAIL_FAST, and is'\n                              ' in addition to any other -o options)'))\n    parser.add_argument('file', nargs='+',\n                        help='file containing the tests to run')\n    args = parser.parse_args()\n    testfiles = args.file\n    # Verbose used to be handled by the \"inspect argv\" magic in DocTestRunner,\n    # but since we are using argparse we are passing it manually now.\n    verbose = args.verbose\n    options = 0\n    for option in args.option:\n        options |= OPTIONFLAGS_BY_NAME[option]\n    if args.fail_fast:\n        options |= FAIL_FAST\n    for filename in testfiles:\n        if filename.endswith(\".py\"):\n            # It is a module -- insert its dir into sys.path and try to\n            # import it. If it is part of a package, that possibly\n            # won't work because of package imports.\n            dirname, filename = os.path.split(filename)\n            sys.path.insert(0, dirname)\n            m = __import__(filename[:-3])\n            del sys.path[0]\n            failures, _ = testmod(m, verbose=verbose, optionflags=options)\n        else:\n            failures, _ = testfile(filename, module_relative=False,\n                                     verbose=verbose, optionflags=options)\n        if failures:\n            return 1\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(_test())\n",
    "Lib/idlelib/idle_test/__init__.py": "\"\"\"idlelib.idle_test implements test.test_idle, which tests the IDLE\napplication as part of the stdlib test suite.\nRun IDLE tests alone with \"python -m test.test_idle (-v)\".\n\nThis package and its contained modules are subject to change and\nany direct use is at your own risk.\n\"\"\"\nfrom os.path import dirname\n\n# test_idle imports load_tests for test discovery (default all).\n# To run subsets of idlelib module tests, insert '[<chars>]' after '_'.\n# Example: insert '[ac]' for modules beginning with 'a' or 'c'.\n# Additional .discover/.addTest pairs with separate inserts work.\n# Example: pairs with 'c' and 'g' test c* files and grep.\n\ndef load_tests(loader, standard_tests, pattern):\n    this_dir = dirname(__file__)\n    top_dir = dirname(dirname(this_dir))\n    module_tests = loader.discover(start_dir=this_dir,\n                                    pattern='test_*.py',  # Insert here.\n                                    top_level_dir=top_dir)\n    standard_tests.addTests(module_tests)\n##    module_tests = loader.discover(start_dir=this_dir,\n##                                    pattern='test_*.py',  # Insert here.\n##                                    top_level_dir=top_dir)\n##    standard_tests.addTests(module_tests)\n    return standard_tests\n",
    "Lib/idlelib/idle_test/htest.py": "\"\"\"Run human tests of Idle's window, dialog, and popup widgets.\n\nrun(*tests) Create a master Tk() htest window.  Within that, run each\ncallable in tests after finding the matching test spec in this file.  If\ntests is empty, run an htest for each spec dict in this file after\nfinding the matching callable in the module named in the spec.  Close\nthe master window to end testing.\n\nIn a tested module, let X be a global name bound to a callable (class or\nfunction) whose .__name__ attribute is also X (the usual situation). The\nfirst parameter of X must be 'parent' or 'master'.  When called, the\nfirst argument will be the root window.  X must create a child\nToplevel(parent/master) (or subclass thereof).  The Toplevel may be a\ntest widget or dialog, in which case the callable is the corresponding\nclass.  Or the Toplevel may contain the widget to be tested or set up a\ncontext in which a test widget is invoked.  In this latter case, the\ncallable is a wrapper function that sets up the Toplevel and other\nobjects.  Wrapper function names, such as _editor_window', should start\nwith '_' and be lowercase.\n\n\nEnd the module with\n\nif __name__ == '__main__':\n    <run unittest.main with 'exit=False'>\n    from idlelib.idle_test.htest import run\n    run(callable)  # There could be multiple comma-separated callables.\n\nTo have wrapper functions ignored by coverage reports, tag the def\nheader like so: \"def _wrapper(parent):  # htest #\".  Use the same tag\nfor htest lines in widget code.  Make sure that the 'if __name__' line\nmatches the above.  Then have make sure that .coveragerc includes the\nfollowing:\n\n[report]\nexclude_lines =\n    .*# htest #\n    if __name__ == .__main__.:\n\n(The \".\" instead of \"'\" is intentional and necessary.)\n\n\nTo run any X, this file must contain a matching instance of the\nfollowing template, with X.__name__ prepended to '_spec'.\nWhen all tests are run, the prefix is use to get X.\n\ncallable_spec = {\n    'file': '',\n    'kwds': {'title': ''},\n    'msg': \"\"\n    }\n\nfile (no .py): run() imports file.py.\nkwds: augmented with {'parent':root} and passed to X as **kwds.\ntitle: an example kwd; some widgets need this, delete line if not.\nmsg: master window hints about testing the widget.\n\n\nTODO test these modules and classes:\n  autocomplete_w.AutoCompleteWindow\n  debugger.Debugger\n  outwin.OutputWindow (indirectly being tested with grep test)\n  pyshell.PyShellEditorWindow\n\"\"\"\n\nimport idlelib.pyshell  # Set Windows DPI awareness before Tk().\nfrom importlib import import_module\nimport textwrap\nimport tkinter as tk\nfrom tkinter.ttk import Scrollbar\ntk.NoDefaultRoot()\n\nAboutDialog_spec = {\n    'file': 'help_about',\n    'kwds': {'title': 'help_about test',\n             '_htest': True,\n             },\n    'msg': \"Click on URL to open in default browser.\\n\"\n           \"Verify x.y.z versions and test each button, including Close.\\n \"\n    }\n\n# TODO implement ^\\; adding '<Control-Key-\\\\>' to function does not work.\n_calltip_window_spec = {\n    'file': 'calltip_w',\n    'kwds': {},\n    'msg': \"Typing '(' should display a calltip.\\n\"\n           \"Typing ') should hide the calltip.\\n\"\n           \"So should moving cursor out of argument area.\\n\"\n           \"Force-open-calltip does not work here.\\n\"\n    }\n\n_color_delegator_spec = {\n    'file': 'colorizer',\n    'kwds': {},\n    'msg': \"The text is sample Python code.\\n\"\n           \"Ensure components like comments, keywords, builtins,\\n\"\n           \"string, definitions, and break are correctly colored.\\n\"\n           \"The default color scheme is in idlelib/config-highlight.def\"\n    }\n\nConfigDialog_spec = {\n    'file': 'configdialog',\n    'kwds': {'title': 'ConfigDialogTest',\n             '_htest': True,},\n    'msg': \"IDLE preferences dialog.\\n\"\n           \"In the 'Fonts/Tabs' tab, changing font face, should update the \"\n           \"font face of the text in the area below it.\\nIn the \"\n           \"'Highlighting' tab, try different color schemes. Clicking \"\n           \"items in the sample program should update the choices above it.\"\n           \"\\nIn the 'Keys', 'General' and 'Extensions' tabs, test settings \"\n           \"of interest.\"\n           \"\\n[Ok] to close the dialog.[Apply] to apply the settings and \"\n           \"and [Cancel] to revert all changes.\\nRe-run the test to ensure \"\n           \"changes made have persisted.\"\n    }\n\nCustomRun_spec = {\n    'file': 'query',\n    'kwds': {'title': 'Customize query.py Run',\n             '_htest': True},\n    'msg': \"Enter with <Return> or [OK].  Print valid entry to Shell\\n\"\n           \"Arguments are parsed into a list\\n\"\n           \"Mode is currently restart True or False\\n\"\n           \"Close dialog with valid entry, <Escape>, [Cancel], [X]\"\n    }\n\n_debug_object_browser_spec = {\n    'file': 'debugobj',\n    'kwds': {},\n    'msg': \"Double click on items up to the lowest level.\\n\"\n           \"Attributes of the objects and related information \"\n           \"will be displayed side-by-side at each level.\"\n    }\n\n# TODO Improve message\n_dyn_option_menu_spec = {\n    'file': 'dynoption',\n    'kwds': {},\n    'msg': \"Select one of the many options in the 'old option set'.\\n\"\n           \"Click the button to change the option set.\\n\"\n           \"Select one of the many options in the 'new option set'.\"\n    }\n\n# TODO edit wrapper\n_editor_window_spec = {\n   'file': 'editor',\n    'kwds': {},\n    'msg': \"Test editor functions of interest.\\n\"\n           \"Best to close editor first.\"\n    }\n\nGetKeysWindow_spec = {\n    'file': 'config_key',\n    'kwds': {'title': 'Test keybindings',\n             'action': 'find-again',\n             'current_key_sequences': [['<Control-Key-g>', '<Key-F3>', '<Control-Key-G>']],\n             '_htest': True,\n             },\n    'msg': \"Test for different key modifier sequences.\\n\"\n           \"<nothing> is invalid.\\n\"\n           \"No modifier key is invalid.\\n\"\n           \"Shift key with [a-z],[0-9], function key, move key, tab, space \"\n           \"is invalid.\\nNo validity checking if advanced key binding \"\n           \"entry is used.\"\n    }\n\n_grep_dialog_spec = {\n    'file': 'grep',\n    'kwds': {},\n    'msg': \"Click the 'Show GrepDialog' button.\\n\"\n           \"Test the various 'Find-in-files' functions.\\n\"\n           \"The results should be displayed in a new '*Output*' window.\\n\"\n           \"'Right-click'->'Go to file/line' in the search results\\n \"\n           \"should open that file in a new EditorWindow.\"\n    }\n\nHelpSource_spec = {\n    'file': 'query',\n    'kwds': {'title': 'Help name and source',\n             'menuitem': 'test',\n             'filepath': __file__,\n             'used_names': {'abc'},\n             '_htest': True},\n    'msg': \"Enter menu item name and help file path\\n\"\n           \"'', > than 30 chars, and 'abc' are invalid menu item names.\\n\"\n           \"'' and file does not exist are invalid path items.\\n\"\n           \"Any url ('www...', 'http...') is accepted.\\n\"\n           \"Test Browse with and without path, as cannot unittest.\\n\"\n           \"[Ok] or <Return> prints valid entry to shell\\n\"\n           \"<Escape>, [Cancel], or [X] prints None to shell\"\n    }\n\n_io_binding_spec = {\n    'file': 'iomenu',\n    'kwds': {},\n    'msg': \"Test the following bindings.\\n\"\n           \"<Control-o> to open file from dialog.\\n\"\n           \"Edit the file.\\n\"\n           \"<Control-p> to print the file.\\n\"\n           \"<Control-s> to save the file.\\n\"\n           \"<Alt-s> to save-as another file.\\n\"\n           \"<Control-c> to save-copy-as another file.\\n\"\n           \"Check that changes were saved by opening the file elsewhere.\"\n    }\n\n_multi_call_spec = {\n    'file': 'multicall',\n    'kwds': {},\n    'msg': \"The following should trigger a print to console or IDLE Shell.\\n\"\n           \"Entering and leaving the text area, key entry, <Control-Key>,\\n\"\n           \"<Alt-Key-a>, <Control-Key-a>, <Alt-Control-Key-a>, \\n\"\n           \"<Control-Button-1>, <Alt-Button-1> and focusing elsewhere.\"\n    }\n\n_module_browser_spec = {\n    'file': 'browser',\n    'kwds': {},\n    'msg': textwrap.dedent(\"\"\"\n        \"Inspect names of module, class(with superclass if applicable),\n        \"methods and functions.  Toggle nested items.  Double clicking\n        \"on items prints a traceback for an exception that is ignored.\"\"\")\n    }\n\n_multistatus_bar_spec = {\n    'file': 'statusbar',\n    'kwds': {},\n    'msg': \"Ensure presence of multi-status bar below text area.\\n\"\n           \"Click 'Update Status' to change the status text\"\n    }\n\nPathBrowser_spec = {\n    'file': 'pathbrowser',\n    'kwds': {'_htest': True},\n    'msg': \"Test for correct display of all paths in sys.path.\\n\"\n           \"Toggle nested items out to the lowest level.\\n\"\n           \"Double clicking on an item prints a traceback\\n\"\n           \"for an exception that is ignored.\"\n    }\n\n_percolator_spec = {\n    'file': 'percolator',\n    'kwds': {},\n    'msg': \"There are two tracers which can be toggled using a checkbox.\\n\"\n           \"Toggling a tracer 'on' by checking it should print tracer \"\n           \"output to the console or to the IDLE shell.\\n\"\n           \"If both the tracers are 'on', the output from the tracer which \"\n           \"was switched 'on' later, should be printed first\\n\"\n           \"Test for actions like text entry, and removal.\"\n    }\n\nQuery_spec = {\n    'file': 'query',\n    'kwds': {'title': 'Query',\n             'message': 'Enter something',\n             'text0': 'Go',\n             '_htest': True},\n    'msg': \"Enter with <Return> or [Ok].  Print valid entry to Shell\\n\"\n           \"Blank line, after stripping, is ignored\\n\"\n           \"Close dialog with valid entry, <Escape>, [Cancel], [X]\"\n    }\n\n\n_replace_dialog_spec = {\n    'file': 'replace',\n    'kwds': {},\n    'msg': \"Click the 'Replace' button.\\n\"\n           \"Test various replace options in the 'Replace dialog'.\\n\"\n           \"Click [Close] or [X] to close the 'Replace Dialog'.\"\n    }\n\n_scrolled_list_spec = {\n    'file': 'scrolledlist',\n    'kwds': {},\n    'msg': \"You should see a scrollable list of items\\n\"\n           \"Selecting (clicking) or double clicking an item \"\n           \"prints the name to the console or Idle shell.\\n\"\n           \"Right clicking an item will display a popup.\"\n    }\n\n_search_dialog_spec = {\n    'file': 'search',\n    'kwds': {},\n    'msg': \"Click the 'Search' button.\\n\"\n           \"Test various search options in the 'Search dialog'.\\n\"\n           \"Click [Close] or [X] to close the 'Search Dialog'.\"\n    }\n\n_searchbase_spec = {\n    'file': 'searchbase',\n    'kwds': {},\n    'msg': \"Check the appearance of the base search dialog\\n\"\n           \"Its only action is to close.\"\n    }\n\nshow_idlehelp_spec = {\n    'file': 'help',\n    'kwds': {},\n    'msg': \"If the help text displays, this works.\\n\"\n           \"Text is selectable. Window is scrollable.\"\n    }\n\n_sidebar_number_scrolling_spec = {\n    'file': 'sidebar',\n    'kwds': {},\n    'msg': textwrap.dedent(\"\"\"\\\n        1. Click on the line numbers and drag down below the edge of the\n        window, moving the mouse a bit and then leaving it there for a\n        while. The text and line numbers should gradually scroll down,\n        with the selection updated continuously.\n\n        2. With the lines still selected, click on a line number above\n        or below the selected lines. Only the line whose number was\n        clicked should be selected.\n\n        3. Repeat step #1, dragging to above the window. The text and\n        line numbers should gradually scroll up, with the selection\n        updated continuously.\n\n        4. Repeat step #2, clicking a line number below the selection.\"\"\"),\n    }\n\n_stackbrowser_spec = {\n    'file': 'stackviewer',\n    'kwds': {},\n    'msg': \"A stacktrace for a NameError exception.\\n\"\n           \"Should have NameError and 1 traceback line.\"\n    }\n\n_tooltip_spec = {\n    'file': 'tooltip',\n    'kwds': {},\n    'msg': \"Place mouse cursor over both the buttons\\n\"\n           \"A tooltip should appear with some text.\"\n    }\n\n_tree_widget_spec = {\n    'file': 'tree',\n    'kwds': {},\n    'msg': \"The canvas is scrollable.\\n\"\n           \"Click on folders up to to the lowest level.\"\n    }\n\n_undo_delegator_spec = {\n    'file': 'undo',\n    'kwds': {},\n    'msg': \"Click [Undo] to undo any action.\\n\"\n           \"Click [Redo] to redo any action.\\n\"\n           \"Click [Dump] to dump the current state \"\n           \"by printing to the console or the IDLE shell.\\n\"\n    }\n\nViewWindow_spec = {\n    'file': 'textview',\n    'kwds': {'title': 'Test textview',\n             'contents': 'The quick brown fox jumps over the lazy dog.\\n'*35,\n             '_htest': True},\n    'msg': \"Test for read-only property of text.\\n\"\n           \"Select text, scroll window, close\"\n     }\n\n_widget_redirector_spec = {\n    'file': 'redirector',\n    'kwds': {},\n    'msg': \"Every text insert should be printed to the console \"\n           \"or the IDLE shell.\"\n    }\n\ndef run(*tests):\n    \"Run callables in tests.\"\n    root = tk.Tk()\n    root.title('IDLE htest')\n    root.resizable(0, 0)\n\n    # A scrollable Label-like constant width text widget.\n    frameLabel = tk.Frame(root, padx=10)\n    frameLabel.pack()\n    text = tk.Text(frameLabel, wrap='word')\n    text.configure(bg=root.cget('bg'), relief='flat', height=4, width=70)\n    scrollbar = Scrollbar(frameLabel, command=text.yview)\n    text.config(yscrollcommand=scrollbar.set)\n    scrollbar.pack(side='right', fill='y', expand=False)\n    text.pack(side='left', fill='both', expand=True)\n\n    test_list = [] # Make list of (spec, callable) tuples.\n    if tests:\n        for test in tests:\n            test_spec = globals()[test.__name__ + '_spec']\n            test_spec['name'] = test.__name__\n            test_list.append((test_spec,  test))\n    else:\n        for key, dic in globals().items():\n            if key.endswith('_spec'):\n                test_name = key[:-5]\n                test_spec = dic\n                test_spec['name'] = test_name\n                mod = import_module('idlelib.' + test_spec['file'])\n                test = getattr(mod, test_name)\n                test_list.append((test_spec, test))\n    test_list.reverse()  # So can pop in proper order in next_test.\n\n    test_name = tk.StringVar(root)\n    callable_object = None\n    test_kwds = None\n\n    def next_test():\n        nonlocal test_name, callable_object, test_kwds\n        if len(test_list) == 1:\n            next_button.pack_forget()\n        test_spec, callable_object = test_list.pop()\n        test_kwds = test_spec['kwds']\n        test_name.set('Test ' + test_spec['name'])\n\n        text['state'] = 'normal'  # Enable text replacement.\n        text.delete('1.0', 'end')\n        text.insert(\"1.0\", test_spec['msg'])\n        text['state'] = 'disabled'  # Restore read-only property.\n\n    def run_test(_=None):\n        widget = callable_object(root, **test_kwds)\n        try:\n            print(widget.result)  # Only true for query classes(?).\n        except AttributeError:\n            pass\n\n    def close(_=None):\n        root.destroy()\n\n    button = tk.Button(root, textvariable=test_name,\n                       default='active', command=run_test)\n    next_button = tk.Button(root, text=\"Next\", command=next_test)\n    button.pack()\n    next_button.pack()\n    next_button.focus_set()\n    root.bind('<Key-Return>', run_test)\n    root.bind('<Key-Escape>', close)\n\n    next_test()\n    root.mainloop()\n\n\nif __name__ == '__main__':\n    run()\n",
    "Lib/idlelib/idle_test/mock_idle.py": "'''Mock classes that imitate idlelib modules or classes.\n\nAttributes and methods will be added as needed for tests.\n'''\n\nfrom idlelib.idle_test.mock_tk import Text\n\nclass Func:\n    '''Record call, capture args, return/raise result set by test.\n\n    When mock function is called, set or use attributes:\n    self.called - increment call number even if no args, kwds passed.\n    self.args - capture positional arguments.\n    self.kwds - capture keyword arguments.\n    self.result - return or raise value set in __init__.\n    self.return_self - return self instead, to mock query class return.\n\n    Most common use will probably be to mock instance methods.\n    Given class instance, can set and delete as instance attribute.\n    Mock_tk.Var and Mbox_func are special variants of this.\n    '''\n    def __init__(self, result=None, return_self=False):\n        self.called = 0\n        self.result = result\n        self.return_self = return_self\n        self.args = None\n        self.kwds = None\n    def __call__(self, *args, **kwds):\n        self.called += 1\n        self.args = args\n        self.kwds = kwds\n        if isinstance(self.result, BaseException):\n            raise self.result\n        elif self.return_self:\n            return self\n        else:\n            return self.result\n\n\nclass Editor:\n    '''Minimally imitate editor.EditorWindow class.\n    '''\n    def __init__(self, flist=None, filename=None, key=None, root=None,\n                 text=None):  # Allow real Text with mock Editor.\n        self.text = text or Text()\n        self.undo = UndoDelegator()\n\n    def get_selection_indices(self):\n        first = self.text.index('1.0')\n        last = self.text.index('end')\n        return first, last\n\n\nclass UndoDelegator:\n    '''Minimally imitate undo.UndoDelegator class.\n    '''\n    # A real undo block is only needed for user interaction.\n    def undo_block_start(*args):\n        pass\n    def undo_block_stop(*args):\n        pass\n",
    "Lib/idlelib/idle_test/mock_tk.py": "\"\"\"Classes that replace tkinter gui objects used by an object being tested.\n\nA gui object is anything with a master or parent parameter, which is\ntypically required in spite of what the doc strings say.\n\"\"\"\nimport re\nfrom _tkinter import TclError\n\n\nclass Event:\n    '''Minimal mock with attributes for testing event handlers.\n\n    This is not a gui object, but is used as an argument for callbacks\n    that access attributes of the event passed. If a callback ignores\n    the event, other than the fact that is happened, pass 'event'.\n\n    Keyboard, mouse, window, and other sources generate Event instances.\n    Event instances have the following attributes: serial (number of\n    event), time (of event), type (of event as number), widget (in which\n    event occurred), and x,y (position of mouse). There are other\n    attributes for specific events, such as keycode for key events.\n    tkinter.Event.__doc__ has more but is still not complete.\n    '''\n    def __init__(self, **kwds):\n        \"Create event with attributes needed for test\"\n        self.__dict__.update(kwds)\n\n\nclass Var:\n    \"Use for String/Int/BooleanVar: incomplete\"\n    def __init__(self, master=None, value=None, name=None):\n        self.master = master\n        self.value = value\n        self.name = name\n    def set(self, value):\n        self.value = value\n    def get(self):\n        return self.value\n\n\nclass Mbox_func:\n    \"\"\"Generic mock for messagebox functions, which all have the same signature.\n\n    Instead of displaying a message box, the mock's call method saves the\n    arguments as instance attributes, which test functions can then examine.\n    The test can set the result returned to ask function\n    \"\"\"\n    def __init__(self, result=None):\n        self.result = result  # Return None for all show funcs\n    def __call__(self, title, message, *args, **kwds):\n        # Save all args for possible examination by tester\n        self.title = title\n        self.message = message\n        self.args = args\n        self.kwds = kwds\n        return self.result  # Set by tester for ask functions\n\n\nclass Mbox:\n    \"\"\"Mock for tkinter.messagebox with an Mbox_func for each function.\n\n    Example usage in test_module.py for testing functions in module.py:\n    ---\nfrom idlelib.idle_test.mock_tk import Mbox\nimport module\n\norig_mbox = module.messagebox\nshowerror = Mbox.showerror  # example, for attribute access in test methods\n\nclass Test(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        module.messagebox = Mbox\n\n    @classmethod\n    def tearDownClass(cls):\n        module.messagebox = orig_mbox\n    ---\n    For 'ask' functions, set func.result return value before calling the method\n    that uses the message function. When messagebox functions are the\n    only GUI calls in a method, this replacement makes the method GUI-free,\n    \"\"\"\n    askokcancel = Mbox_func()     # True or False\n    askquestion = Mbox_func()     # 'yes' or 'no'\n    askretrycancel = Mbox_func()  # True or False\n    askyesno = Mbox_func()        # True or False\n    askyesnocancel = Mbox_func()  # True, False, or None\n    showerror = Mbox_func()    # None\n    showinfo = Mbox_func()     # None\n    showwarning = Mbox_func()  # None\n\n\nclass Text:\n    \"\"\"A semi-functional non-gui replacement for tkinter.Text text editors.\n\n    The mock's data model is that a text is a list of \\n-terminated lines.\n    The mock adds an empty string at  the beginning of the list so that the\n    index of actual lines start at 1, as with Tk. The methods never see this.\n    Tk initializes files with a terminal \\n that cannot be deleted. It is\n    invisible in the sense that one cannot move the cursor beyond it.\n\n    This class is only tested (and valid) with strings of ascii chars.\n    For testing, we are not concerned with Tk Text's treatment of,\n    for instance, 0-width characters or character + accent.\n   \"\"\"\n    def __init__(self, master=None, cnf={}, **kw):\n        '''Initialize mock, non-gui, text-only Text widget.\n\n        At present, all args are ignored. Almost all affect visual behavior.\n        There are just a few Text-only options that affect text behavior.\n        '''\n        self.data = ['', '\\n']\n\n    def index(self, index):\n        \"Return string version of index decoded according to current text.\"\n        return \"%s.%s\" % self._decode(index, endflag=1)\n\n    def _decode(self, index, endflag=0):\n        \"\"\"Return a (line, char) tuple of int indexes into self.data.\n\n        This implements .index without converting the result back to a string.\n        The result is constrained by the number of lines and linelengths of\n        self.data. For many indexes, the result is initially (1, 0).\n\n        The input index may have any of several possible forms:\n        * line.char float: converted to 'line.char' string;\n        * 'line.char' string, where line and char are decimal integers;\n        * 'line.char lineend', where lineend='lineend' (and char is ignored);\n        * 'line.end', where end='end' (same as above);\n        * 'insert', the positions before terminal \\n;\n        * 'end', whose meaning depends on the endflag passed to ._endex.\n        * 'sel.first' or 'sel.last', where sel is a tag -- not implemented.\n        \"\"\"\n        if isinstance(index, (float, bytes)):\n            index = str(index)\n        try:\n            index=index.lower()\n        except AttributeError:\n            raise TclError('bad text index \"%s\"' % index) from None\n\n        lastline =  len(self.data) - 1  # same as number of text lines\n        if index == 'insert':\n            return lastline, len(self.data[lastline]) - 1\n        elif index == 'end':\n            return self._endex(endflag)\n\n        line, char = index.split('.')\n        line = int(line)\n\n        # Out of bounds line becomes first or last ('end') index\n        if line < 1:\n            return 1, 0\n        elif line > lastline:\n            return self._endex(endflag)\n\n        linelength = len(self.data[line])  -1  # position before/at \\n\n        if char.endswith(' lineend') or char == 'end':\n            return line, linelength\n            # Tk requires that ignored chars before ' lineend' be valid int\n        if m := re.fullmatch(r'end-(\\d*)c', char, re.A):  # Used by hyperparser.\n            return line, linelength - int(m.group(1))\n\n        # Out of bounds char becomes first or last index of line\n        char = int(char)\n        if char < 0:\n            char = 0\n        elif char > linelength:\n            char = linelength\n        return line, char\n\n    def _endex(self, endflag):\n        '''Return position for 'end' or line overflow corresponding to endflag.\n\n       -1: position before terminal \\n; for .insert(), .delete\n       0: position after terminal \\n; for .get, .delete index 1\n       1: same viewed as beginning of non-existent next line (for .index)\n       '''\n        n = len(self.data)\n        if endflag == 1:\n            return n, 0\n        else:\n            n -= 1\n            return n, len(self.data[n]) + endflag\n\n    def insert(self, index, chars):\n        \"Insert chars before the character at index.\"\n\n        if not chars:  # ''.splitlines() is [], not ['']\n            return\n        chars = chars.splitlines(True)\n        if chars[-1][-1] == '\\n':\n            chars.append('')\n        line, char = self._decode(index, -1)\n        before = self.data[line][:char]\n        after = self.data[line][char:]\n        self.data[line] = before + chars[0]\n        self.data[line+1:line+1] = chars[1:]\n        self.data[line+len(chars)-1] += after\n\n    def get(self, index1, index2=None):\n        \"Return slice from index1 to index2 (default is 'index1+1').\"\n\n        startline, startchar = self._decode(index1)\n        if index2 is None:\n            endline, endchar = startline, startchar+1\n        else:\n            endline, endchar = self._decode(index2)\n\n        if startline == endline:\n            return self.data[startline][startchar:endchar]\n        else:\n            lines = [self.data[startline][startchar:]]\n            for i in range(startline+1, endline):\n                lines.append(self.data[i])\n            lines.append(self.data[endline][:endchar])\n            return ''.join(lines)\n\n    def delete(self, index1, index2=None):\n        '''Delete slice from index1 to index2 (default is 'index1+1').\n\n        Adjust default index2 ('index+1) for line ends.\n        Do not delete the terminal \\n at the very end of self.data ([-1][-1]).\n        '''\n        startline, startchar = self._decode(index1, -1)\n        if index2 is None:\n            if startchar < len(self.data[startline])-1:\n                # not deleting \\n\n                endline, endchar = startline, startchar+1\n            elif startline < len(self.data) - 1:\n                # deleting non-terminal \\n, convert 'index1+1 to start of next line\n                endline, endchar = startline+1, 0\n            else:\n                # do not delete terminal \\n if index1 == 'insert'\n                return\n        else:\n            endline, endchar = self._decode(index2, -1)\n            # restricting end position to insert position excludes terminal \\n\n\n        if startline == endline and startchar < endchar:\n            self.data[startline] = self.data[startline][:startchar] + \\\n                                             self.data[startline][endchar:]\n        elif startline < endline:\n            self.data[startline] = self.data[startline][:startchar] + \\\n                                   self.data[endline][endchar:]\n            startline += 1\n            for i in range(startline, endline+1):\n                del self.data[startline]\n\n    def compare(self, index1, op, index2):\n        line1, char1 = self._decode(index1)\n        line2, char2 = self._decode(index2)\n        if op == '<':\n            return line1 < line2 or line1 == line2 and char1 < char2\n        elif op == '<=':\n            return line1 < line2 or line1 == line2 and char1 <= char2\n        elif op == '>':\n            return line1 > line2 or line1 == line2 and char1 > char2\n        elif op == '>=':\n            return line1 > line2 or line1 == line2 and char1 >= char2\n        elif op == '==':\n            return line1 == line2 and char1 == char2\n        elif op == '!=':\n            return line1 != line2 or  char1 != char2\n        else:\n            raise TclError('''bad comparison operator \"%s\": '''\n                                  '''must be <, <=, ==, >=, >, or !=''' % op)\n\n    # The following Text methods normally do something and return None.\n    # Whether doing nothing is sufficient for a test will depend on the test.\n\n    def mark_set(self, name, index):\n        \"Set mark *name* before the character at index.\"\n        pass\n\n    def mark_unset(self, *markNames):\n        \"Delete all marks in markNames.\"\n\n    def tag_remove(self, tagName, index1, index2=None):\n        \"Remove tag tagName from all characters between index1 and index2.\"\n        pass\n\n    # The following Text methods affect the graphics screen and return None.\n    # Doing nothing should always be sufficient for tests.\n\n    def scan_dragto(self, x, y):\n        \"Adjust the view of the text according to scan_mark\"\n\n    def scan_mark(self, x, y):\n        \"Remember the current X, Y coordinates.\"\n\n    def see(self, index):\n        \"Scroll screen to make the character at INDEX is visible.\"\n        pass\n\n    #  The following is a Misc method inherited by Text.\n    # It should properly go in a Misc mock, but is included here for now.\n\n    def bind(sequence=None, func=None, add=None):\n        \"Bind to this widget at event sequence a call to function func.\"\n        pass\n\n\nclass Entry:\n    \"Mock for tkinter.Entry.\"\n    def focus_set(self):\n        pass\n",
    "Lib/idlelib/idle_test/template.py": "\"Test , coverage %.\"\n\nfrom idlelib import zzdummy\nimport unittest\nfrom test.support import requires\nfrom tkinter import Tk\n\n\nclass Test(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        requires('gui')\n        cls.root = Tk()\n        cls.root.withdraw()\n\n    @classmethod\n    def tearDownClass(cls):\n        cls.root.update_idletasks()\n##        for id in cls.root.tk.call('after', 'info'):\n##            cls.root.after_cancel(id)  # Need for EditorWindow.\n        cls.root.destroy()\n        del cls.root\n\n    def test_init(self):\n        self.assertTrue(True)\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n",
    "Lib/idlelib/idle_test/test_autocomplete.py": "\"Test autocomplete, coverage 93%.\"\n\nimport unittest\nfrom unittest.mock import Mock, patch\nfrom test.support import requires\nfrom tkinter import Tk, Text\nimport os\nimport __main__\n\nimport idlelib.autocomplete as ac\nimport idlelib.autocomplete_w as acw\nfrom idlelib.idle_test.mock_idle import Func\nfrom idlelib.idle_test.mock_tk import Event\n\n\nclass DummyEditwin:\n    def __init__(self, root, text):\n        self.root = root\n        self.text = text\n        self.indentwidth = 8\n        self.tabwidth = 8\n        self.prompt_last_line = '>>>'  # Currently not used by autocomplete.\n\n\nclass AutoCompleteTest(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        requires('gui')\n        cls.root = Tk()\n        cls.root.withdraw()\n        cls.text = Text(cls.root)\n        cls.editor = DummyEditwin(cls.root, cls.text)\n\n    @classmethod\n    def tearDownClass(cls):\n        del cls.editor, cls.text\n        cls.root.update_idletasks()\n        cls.root.destroy()\n        del cls.root\n\n    def setUp(self):\n        self.text.delete('1.0', 'end')\n        self.autocomplete = ac.AutoComplete(self.editor)\n\n    def test_init(self):\n        self.assertEqual(self.autocomplete.editwin, self.editor)\n        self.assertEqual(self.autocomplete.text, self.text)\n\n    def test_make_autocomplete_window(self):\n        testwin = self.autocomplete._make_autocomplete_window()\n        self.assertIsInstance(testwin, acw.AutoCompleteWindow)\n\n    def test_remove_autocomplete_window(self):\n        acp = self.autocomplete\n        acp.autocompletewindow = m = Mock()\n        acp._remove_autocomplete_window()\n        m.hide_window.assert_called_once()\n        self.assertIsNone(acp.autocompletewindow)\n\n    def test_force_open_completions_event(self):\n        # Call _open_completions and break.\n        acp = self.autocomplete\n        open_c = Func()\n        acp.open_completions = open_c\n        self.assertEqual(acp.force_open_completions_event('event'), 'break')\n        self.assertEqual(open_c.args[0], ac.FORCE)\n\n    def test_autocomplete_event(self):\n        Equal = self.assertEqual\n        acp = self.autocomplete\n\n        # Result of autocomplete event: If modified tab, None.\n        ev = Event(mc_state=True)\n        self.assertIsNone(acp.autocomplete_event(ev))\n        del ev.mc_state\n\n        # If tab after whitespace, None.\n        self.text.insert('1.0', '        \"\"\"Docstring.\\n    ')\n        self.assertIsNone(acp.autocomplete_event(ev))\n        self.text.delete('1.0', 'end')\n\n        # If active autocomplete window, complete() and 'break'.\n        self.text.insert('1.0', 're.')\n        acp.autocompletewindow = mock = Mock()\n        mock.is_active = Mock(return_value=True)\n        Equal(acp.autocomplete_event(ev), 'break')\n        mock.complete.assert_called_once()\n        acp.autocompletewindow = None\n\n        # If no active autocomplete window, open_completions(), None/break.\n        open_c = Func(result=False)\n        acp.open_completions = open_c\n        Equal(acp.autocomplete_event(ev), None)\n        Equal(open_c.args[0], ac.TAB)\n        open_c.result = True\n        Equal(acp.autocomplete_event(ev), 'break')\n        Equal(open_c.args[0], ac.TAB)\n\n    def test_try_open_completions_event(self):\n        Equal = self.assertEqual\n        text = self.text\n        acp = self.autocomplete\n        trycompletions = acp.try_open_completions_event\n        after = Func(result='after1')\n        acp.text.after = after\n\n        # If no text or trigger, after not called.\n        trycompletions()\n        Equal(after.called, 0)\n        text.insert('1.0', 're')\n        trycompletions()\n        Equal(after.called, 0)\n\n        # Attribute needed, no existing callback.\n        text.insert('insert', ' re.')\n        acp._delayed_completion_id = None\n        trycompletions()\n        Equal(acp._delayed_completion_index, text.index('insert'))\n        Equal(after.args,\n              (acp.popupwait, acp._delayed_open_completions, ac.TRY_A))\n        cb1 = acp._delayed_completion_id\n        Equal(cb1, 'after1')\n\n        # File needed, existing callback cancelled.\n        text.insert('insert', ' \"./Lib/')\n        after.result = 'after2'\n        cancel = Func()\n        acp.text.after_cancel = cancel\n        trycompletions()\n        Equal(acp._delayed_completion_index, text.index('insert'))\n        Equal(cancel.args, (cb1,))\n        Equal(after.args,\n              (acp.popupwait, acp._delayed_open_completions, ac.TRY_F))\n        Equal(acp._delayed_completion_id, 'after2')\n\n    def test_delayed_open_completions(self):\n        Equal = self.assertEqual\n        acp = self.autocomplete\n        open_c = Func()\n        acp.open_completions = open_c\n        self.text.insert('1.0', '\"dict.')\n\n        # Set autocomplete._delayed_completion_id to None.\n        # Text index changed, don't call open_completions.\n        acp._delayed_completion_id = 'after'\n        acp._delayed_completion_index = self.text.index('insert+1c')\n        acp._delayed_open_completions('dummy')\n        self.assertIsNone(acp._delayed_completion_id)\n        Equal(open_c.called, 0)\n\n        # Text index unchanged, call open_completions.\n        acp._delayed_completion_index = self.text.index('insert')\n        acp._delayed_open_completions((1, 2, 3, ac.FILES))\n        self.assertEqual(open_c.args[0], (1, 2, 3, ac.FILES))\n\n    def test_oc_cancel_comment(self):\n        none = self.assertIsNone\n        acp = self.autocomplete\n\n        # Comment is in neither code or string.\n        acp._delayed_completion_id = 'after'\n        after = Func(result='after')\n        acp.text.after_cancel = after\n        self.text.insert(1.0, '# comment')\n        none(acp.open_completions(ac.TAB))  # From 'else' after 'elif'.\n        none(acp._delayed_completion_id)\n\n    def test_oc_no_list(self):\n        acp = self.autocomplete\n        fetch = Func(result=([],[]))\n        acp.fetch_completions = fetch\n        self.text.insert('1.0', 'object')\n        self.assertIsNone(acp.open_completions(ac.TAB))\n        self.text.insert('insert', '.')\n        self.assertIsNone(acp.open_completions(ac.TAB))\n        self.assertEqual(fetch.called, 2)\n\n\n    def test_open_completions_none(self):\n        # Test other two None returns.\n        none = self.assertIsNone\n        acp = self.autocomplete\n\n        # No object for attributes or need call not allowed.\n        self.text.insert(1.0, '.')\n        none(acp.open_completions(ac.TAB))\n        self.text.insert('insert', ' int().')\n        none(acp.open_completions(ac.TAB))\n\n        # Blank or quote trigger 'if complete ...'.\n        self.text.delete(1.0, 'end')\n        self.assertFalse(acp.open_completions(ac.TAB))\n        self.text.insert('1.0', '\"')\n        self.assertFalse(acp.open_completions(ac.TAB))\n        self.text.delete('1.0', 'end')\n\n    class dummy_acw:\n        __init__ = Func()\n        show_window = Func(result=False)\n        hide_window = Func()\n\n    def test_open_completions(self):\n        # Test completions of files and attributes.\n        acp = self.autocomplete\n        fetch = Func(result=(['tem'],['tem', '_tem']))\n        acp.fetch_completions = fetch\n        def make_acw(): return self.dummy_acw()\n        acp._make_autocomplete_window = make_acw\n\n        self.text.insert('1.0', 'int.')\n        acp.open_completions(ac.TAB)\n        self.assertIsInstance(acp.autocompletewindow, self.dummy_acw)\n        self.text.delete('1.0', 'end')\n\n        # Test files.\n        self.text.insert('1.0', '\"t')\n        self.assertTrue(acp.open_completions(ac.TAB))\n        self.text.delete('1.0', 'end')\n\n    def test_completion_kwds(self):\n        self.assertIn('and', ac.completion_kwds)\n        self.assertIn('case', ac.completion_kwds)\n        self.assertNotIn('None', ac.completion_kwds)\n\n    def test_fetch_completions(self):\n        # Test that fetch_completions returns 2 lists:\n        # For attribute completion, a large list containing all variables, and\n        # a small list containing non-private variables.\n        # For file completion, a large list containing all files in the path,\n        # and a small list containing files that do not start with '.'.\n        acp = self.autocomplete\n        small, large = acp.fetch_completions(\n                '', ac.ATTRS)\n        if hasattr(__main__, '__file__') and __main__.__file__ != ac.__file__:\n            self.assertNotIn('AutoComplete', small)  # See issue 36405.\n\n        # Test attributes\n        s, b = acp.fetch_completions('', ac.ATTRS)\n        self.assertLess(len(small), len(large))\n        self.assertTrue(all(filter(lambda x: x.startswith('_'), s)))\n        self.assertTrue(any(filter(lambda x: x.startswith('_'), b)))\n\n        # Test smalll should respect to __all__.\n        with patch.dict('__main__.__dict__', {'__all__': ['a', 'b']}):\n            s, b = acp.fetch_completions('', ac.ATTRS)\n            self.assertEqual(s, ['a', 'b'])\n            self.assertIn('__name__', b)  # From __main__.__dict__.\n            self.assertIn('sum', b)       # From __main__.__builtins__.__dict__.\n            self.assertIn('nonlocal', b)  # From keyword.kwlist.\n            pos = b.index('False')        # Test False not included twice.\n            self.assertNotEqual(b[pos+1], 'False')\n\n        # Test attributes with name entity.\n        mock = Mock()\n        mock._private = Mock()\n        with patch.dict('__main__.__dict__', {'foo': mock}):\n            s, b = acp.fetch_completions('foo', ac.ATTRS)\n            self.assertNotIn('_private', s)\n            self.assertIn('_private', b)\n            self.assertEqual(s, [i for i in sorted(dir(mock)) if i[:1] != '_'])\n            self.assertEqual(b, sorted(dir(mock)))\n\n        # Test files\n        def _listdir(path):\n            # This will be patch and used in fetch_completions.\n            if path == '.':\n                return ['foo', 'bar', '.hidden']\n            return ['monty', 'python', '.hidden']\n\n        with patch.object(os, 'listdir', _listdir):\n            s, b = acp.fetch_completions('', ac.FILES)\n            self.assertEqual(s, ['bar', 'foo'])\n            self.assertEqual(b, ['.hidden', 'bar', 'foo'])\n\n            s, b = acp.fetch_completions('~', ac.FILES)\n            self.assertEqual(s, ['monty', 'python'])\n            self.assertEqual(b, ['.hidden', 'monty', 'python'])\n\n    def test_get_entity(self):\n        # Test that a name is in the namespace of sys.modules and\n        # __main__.__dict__.\n        acp = self.autocomplete\n        Equal = self.assertEqual\n\n        Equal(acp.get_entity('int'), int)\n\n        # Test name from sys.modules.\n        mock = Mock()\n        with patch.dict('sys.modules', {'tempfile': mock}):\n            Equal(acp.get_entity('tempfile'), mock)\n\n        # Test name from __main__.__dict__.\n        di = {'foo': 10, 'bar': 20}\n        with patch.dict('__main__.__dict__', {'d': di}):\n            Equal(acp.get_entity('d'), di)\n\n        # Test name not in namespace.\n        with patch.dict('__main__.__dict__', {}):\n            with self.assertRaises(NameError):\n                acp.get_entity('not_exist')\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n",
    "Lib/idlelib/idle_test/test_autocomplete_w.py": "\"Test autocomplete_w, coverage 11%.\"\n\nimport unittest\nfrom test.support import requires\nfrom tkinter import Tk, Text\n\nimport idlelib.autocomplete_w as acw\n\n\nclass AutoCompleteWindowTest(unittest.TestCase):\n\n    @classmethod\n    def setUpClass(cls):\n        requires('gui')\n        cls.root = Tk()\n        cls.root.withdraw()\n        cls.text = Text(cls.root)\n        cls.acw = acw.AutoCompleteWindow(cls.text, tags=None)\n\n    @classmethod\n    def tearDownClass(cls):\n        del cls.text, cls.acw\n        cls.root.update_idletasks()\n        cls.root.destroy()\n        del cls.root\n\n    def test_init(self):\n        self.assertEqual(self.acw.widget, self.text)\n\n\nif __name__ == '__main__':\n    unittest.main(verbosity=2)\n"
  },
  "requirements": null
}