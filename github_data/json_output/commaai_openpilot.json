{
  "repo_name": "commaai/openpilot",
  "repo_url": "https://github.com/commaai/openpilot",
  "description": "openpilot is an operating system for robotics. Currently, it upgrades the driver assistance system on 300+ supported cars.",
  "stars": 52912,
  "language": "Python",
  "created_at": "2016-11-24T01:33:30Z",
  "updated_at": "2025-03-19T05:59:19Z",
  "files": {
    "cereal/messaging/tests/test_messaging.py": "import os\nimport capnp\nimport multiprocessing\nimport numbers\nimport random\nimport threading\nimport time\nfrom parameterized import parameterized\nimport pytest\n\nfrom cereal import log, car\nimport cereal.messaging as messaging\nfrom cereal.services import SERVICE_LIST\n\nevents = [evt for evt in log.Event.schema.union_fields if evt in SERVICE_LIST.keys()]\n\ndef random_sock():\n  return random.choice(events)\n\ndef random_socks(num_socks=10):\n  return list({random_sock() for _ in range(num_socks)})\n\ndef random_bytes(length=1000):\n  return bytes([random.randrange(0xFF) for _ in range(length)])\n\ndef zmq_sleep(t=1):\n  if \"ZMQ\" in os.environ:\n    time.sleep(t)\n\n\n# TODO: this should take any capnp struct and returrn a msg with random populated data\ndef random_carstate():\n  fields = [\"vEgo\", \"aEgo\", \"gas\", \"steeringAngleDeg\"]\n  msg = messaging.new_message(\"carState\")\n  cs = msg.carState\n  for f in fields:\n    setattr(cs, f, random.random() * 10)\n  return msg\n\n# TODO: this should compare any capnp structs\ndef assert_carstate(cs1, cs2):\n  for f in car.CarState.schema.non_union_fields:\n    # TODO: check all types\n    val1, val2 = getattr(cs1, f), getattr(cs2, f)\n    if isinstance(val1, numbers.Number):\n      assert val1 == val2, f\"{f}: sent '{val1}' vs recvd '{val2}'\"\n\ndef delayed_send(delay, sock, dat):\n  def send_func():\n    sock.send(dat)\n  threading.Timer(delay, send_func).start()\n\n\nclass TestMessaging:\n  def setUp(self):\n    # TODO: ZMQ tests are too slow; all sleeps will need to be\n    # replaced with logic to block on the necessary condition\n    if \"ZMQ\" in os.environ:\n      pytest.skip()\n\n    # ZMQ pub socket takes too long to die\n    # sleep to prevent multiple publishers error between tests\n    zmq_sleep()\n\n  @parameterized.expand(events)\n  def test_new_message(self, evt):\n    try:\n      msg = messaging.new_message(evt)\n    except capnp.lib.capnp.KjException:\n      msg = messaging.new_message(evt, random.randrange(200))\n    assert (time.monotonic() - msg.logMonoTime) < 0.1\n    assert not msg.valid\n    assert evt == msg.which()\n\n  @parameterized.expand(events)\n  def test_pub_sock(self, evt):\n    messaging.pub_sock(evt)\n\n  @parameterized.expand(events)\n  def test_sub_sock(self, evt):\n    messaging.sub_sock(evt)\n\n  @parameterized.expand([\n    (messaging.drain_sock, capnp._DynamicStructReader),\n    (messaging.drain_sock_raw, bytes),\n  ])\n  def test_drain_sock(self, func, expected_type):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sub_sock = messaging.sub_sock(sock, timeout=1000)\n    zmq_sleep()\n\n    # no wait and no msgs in queue\n    msgs = func(sub_sock)\n    assert isinstance(msgs, list)\n    assert len(msgs) == 0\n\n    # no wait but msgs are queued up\n    num_msgs = random.randrange(3, 10)\n    for _ in range(num_msgs):\n      pub_sock.send(messaging.new_message(sock).to_bytes())\n    time.sleep(0.1)\n    msgs = func(sub_sock)\n    assert isinstance(msgs, list)\n    assert all(isinstance(msg, expected_type) for msg in msgs)\n    assert len(msgs) == num_msgs\n\n  def test_recv_sock(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sub_sock = messaging.sub_sock(sock, timeout=100)\n    zmq_sleep()\n\n    # no wait and no msg in queue, socket should timeout\n    recvd = messaging.recv_sock(sub_sock)\n    assert recvd is None\n\n    # no wait and one msg in queue\n    msg = random_carstate()\n    pub_sock.send(msg.to_bytes())\n    time.sleep(0.01)\n    recvd = messaging.recv_sock(sub_sock)\n    assert isinstance(recvd, capnp._DynamicStructReader)\n    # https://github.com/python/mypy/issues/13038\n    assert_carstate(msg.carState, recvd.carState)\n\n  def test_recv_one(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sub_sock = messaging.sub_sock(sock, timeout=1000)\n    zmq_sleep()\n\n    # no msg in queue, socket should timeout\n    recvd = messaging.recv_one(sub_sock)\n    assert recvd is None\n\n    # one msg in queue\n    msg = random_carstate()\n    pub_sock.send(msg.to_bytes())\n    recvd = messaging.recv_one(sub_sock)\n    assert isinstance(recvd, capnp._DynamicStructReader)\n    assert_carstate(msg.carState, recvd.carState)\n\n  @pytest.mark.xfail(condition=\"ZMQ\" in os.environ, reason='ZMQ detected')\n  def test_recv_one_or_none(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sub_sock = messaging.sub_sock(sock)\n    zmq_sleep()\n\n    # no msg in queue, socket shouldn't block\n    recvd = messaging.recv_one_or_none(sub_sock)\n    assert recvd is None\n\n    # one msg in queue\n    msg = random_carstate()\n    pub_sock.send(msg.to_bytes())\n    recvd = messaging.recv_one_or_none(sub_sock)\n    assert isinstance(recvd, capnp._DynamicStructReader)\n    assert_carstate(msg.carState, recvd.carState)\n\n  def test_recv_one_retry(self):\n    sock = \"carState\"\n    sock_timeout = 0.1\n    pub_sock = messaging.pub_sock(sock)\n    sub_sock = messaging.sub_sock(sock, timeout=round(sock_timeout*1000))\n    zmq_sleep()\n\n    # this test doesn't work with ZMQ since multiprocessing interrupts it\n    if \"ZMQ\" not in os.environ:\n      # wait 5 socket timeouts and make sure it's still retrying\n      p = multiprocessing.Process(target=messaging.recv_one_retry, args=(sub_sock,))\n      p.start()\n      time.sleep(sock_timeout*5)\n      assert p.is_alive()\n      p.terminate()\n\n    # wait 5 socket timeouts before sending\n    msg = random_carstate()\n    delayed_send(sock_timeout*5, pub_sock, msg.to_bytes())\n    start_time = time.monotonic()\n    recvd = messaging.recv_one_retry(sub_sock)\n    assert (time.monotonic() - start_time) >= sock_timeout*5\n    assert isinstance(recvd, capnp._DynamicStructReader)\n    assert_carstate(msg.carState, recvd.carState)\n",
    "cereal/messaging/tests/test_pub_sub_master.py": "import random\nimport time\nfrom typing import Sized, cast\n\nimport cereal.messaging as messaging\nfrom cereal.messaging.tests.test_messaging import events, random_sock, random_socks, \\\n                                                  random_bytes, random_carstate, assert_carstate, \\\n                                                  zmq_sleep\n\n\nclass TestSubMaster:\n\n  def setup_method(self):\n    # ZMQ pub socket takes too long to die\n    # sleep to prevent multiple publishers error between tests\n    zmq_sleep(3)\n\n  def test_init(self):\n    sm = messaging.SubMaster(events)\n    for p in [sm.updated, sm.recv_time, sm.recv_frame, sm.alive,\n              sm.sock, sm.data, sm.logMonoTime, sm.valid]:\n      assert len(cast(Sized, p)) == len(events)\n\n  def test_init_state(self):\n    socks = random_socks()\n    sm = messaging.SubMaster(socks)\n    assert sm.frame == -1\n    assert not any(sm.updated.values())\n    assert not any(sm.alive.values())\n    assert all(t == 0. for t in sm.recv_time.values())\n    assert all(f == 0 for f in sm.recv_frame.values())\n    assert all(t == 0 for t in sm.logMonoTime.values())\n\n    for p in [sm.updated, sm.recv_time, sm.recv_frame, sm.alive,\n              sm.sock, sm.data, sm.logMonoTime, sm.valid]:\n      assert len(cast(Sized, p)) == len(socks)\n\n  def test_getitem(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n    zmq_sleep()\n\n    msg = random_carstate()\n    pub_sock.send(msg.to_bytes())\n    sm.update(1000)\n    assert_carstate(msg.carState, sm[sock])\n\n  # TODO: break this test up to individually test SubMaster.update and SubMaster.update_msgs\n  def test_update(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n    zmq_sleep()\n\n    for i in range(10):\n      msg = messaging.new_message(sock)\n      pub_sock.send(msg.to_bytes())\n      sm.update(1000)\n      assert sm.frame == i\n      assert all(sm.updated.values())\n\n  def test_update_timeout(self):\n    sock = random_sock()\n    sm = messaging.SubMaster([sock,])\n    timeout = random.randrange(1000, 3000)\n    start_time = time.monotonic()\n    sm.update(timeout)\n    t = time.monotonic() - start_time\n    assert t >= timeout/1000.\n    assert t < 3\n    assert not any(sm.updated.values())\n\n  def test_avg_frequency_checks(self):\n    for poll in (True, False):\n      sm = messaging.SubMaster([\"modelV2\", \"carParams\", \"carState\", \"cameraOdometry\", \"liveCalibration\"],\n                               poll=(\"modelV2\" if poll else None),\n                               frequency=(20. if not poll else None))\n\n      checks = {\n        \"carState\": (20, 20),\n        \"modelV2\": (20, 20 if poll else 10),\n        \"cameraOdometry\": (20, 10),\n        \"liveCalibration\": (4, 4),\n        \"carParams\": (None, None),\n      }\n\n      for service, (max_freq, min_freq) in checks.items():\n        if max_freq is not None:\n          assert sm._check_avg_freq(service)\n          assert sm.freq_tracker[service].max_freq == max_freq*1.2\n          assert sm.freq_tracker[service].min_freq == min_freq*0.8\n        else:\n          assert not sm._check_avg_freq(service)\n\n  def test_alive(self):\n    pass\n\n  def test_ignore_alive(self):\n    pass\n\n  def test_valid(self):\n    pass\n\n  # SubMaster should always conflate\n  def test_conflate(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n\n    n = 10\n    for i in range(n+1):\n      msg = messaging.new_message(sock)\n      msg.carState.vEgo = i\n      pub_sock.send(msg.to_bytes())\n      time.sleep(0.01)\n    sm.update(1000)\n    assert sm[sock].vEgo == n\n\n\nclass TestPubMaster:\n\n  def setup_method(self):\n    # ZMQ pub socket takes too long to die\n    # sleep to prevent multiple publishers error between tests\n    zmq_sleep(3)\n\n  def test_init(self):\n    messaging.PubMaster(events)\n\n  def test_send(self):\n    socks = random_socks()\n    pm = messaging.PubMaster(socks)\n    sub_socks = {s: messaging.sub_sock(s, conflate=True, timeout=1000) for s in socks}\n    zmq_sleep()\n\n    # PubMaster accepts either a capnp msg builder or bytes\n    for capnp in [True, False]:\n      for i in range(100):\n        sock = socks[i % len(socks)]\n\n        if capnp:\n          try:\n            msg = messaging.new_message(sock)\n          except Exception:\n            msg = messaging.new_message(sock, random.randrange(50))\n        else:\n          msg = random_bytes()\n\n        pm.send(sock, msg)\n        recvd = sub_socks[sock].receive()\n\n        if capnp:\n          msg.clear_write_flag()\n          msg = msg.to_bytes()\n        assert msg == recvd, i\n",
    "cereal/messaging/tests/test_services.py": "import os\nimport tempfile\nfrom typing import Dict\nfrom parameterized import parameterized\n\nimport cereal.services as services\nfrom cereal.services import SERVICE_LIST\n\n\nclass TestServices:\n\n  @parameterized.expand(SERVICE_LIST.keys())\n  def test_services(self, s):\n    service = SERVICE_LIST[s]\n    assert service.frequency <= 104\n    assert service.decimation != 0\n\n  def test_generated_header(self):\n    with tempfile.NamedTemporaryFile(suffix=\".h\") as f:\n      ret = os.system(f\"python3 {services.__file__} > {f.name} && clang++ {f.name} -std=c++11\")\n      assert ret == 0, \"generated services header is not valid C\"\n",
    "common/tests/test_file_helpers.py": "import os\nfrom uuid import uuid4\n\nfrom openpilot.common.file_helpers import atomic_write_in_dir\n\n\nclass TestFileHelpers:\n  def run_atomic_write_func(self, atomic_write_func):\n    path = f\"/tmp/tmp{uuid4()}\"\n    with atomic_write_func(path) as f:\n      f.write(\"test\")\n      assert not os.path.exists(path)\n\n    with open(path) as f:\n      assert f.read() == \"test\"\n    os.remove(path)\n\n  def test_atomic_write_in_dir(self):\n    self.run_atomic_write_func(atomic_write_in_dir)\n",
    "common/tests/test_markdown.py": "import os\n\nfrom openpilot.common.basedir import BASEDIR\nfrom openpilot.common.markdown import parse_markdown\n\n\nclass TestMarkdown:\n  def test_all_release_notes(self):\n    with open(os.path.join(BASEDIR, \"RELEASES.md\")) as f:\n      release_notes = f.read().split(\"\\n\\n\")\n      assert len(release_notes) > 10\n\n      for rn in release_notes:\n        md = parse_markdown(rn)\n        assert len(md) > 0\n",
    "common/tests/test_params.py": "import pytest\nimport os\nimport threading\nimport time\nimport uuid\n\nfrom openpilot.common.params import Params, ParamKeyType, UnknownKeyName\n\nclass TestParams:\n  def setup_method(self):\n    self.params = Params()\n\n  def test_params_put_and_get(self):\n    self.params.put(\"DongleId\", \"cb38263377b873ee\")\n    assert self.params.get(\"DongleId\") == b\"cb38263377b873ee\"\n\n  def test_params_non_ascii(self):\n    st = b\"\\xe1\\x90\\xff\"\n    self.params.put(\"CarParams\", st)\n    assert self.params.get(\"CarParams\") == st\n\n  def test_params_get_cleared_manager_start(self):\n    self.params.put(\"CarParams\", \"test\")\n    self.params.put(\"DongleId\", \"cb38263377b873ee\")\n    assert self.params.get(\"CarParams\") == b\"test\"\n\n    undefined_param = self.params.get_param_path(uuid.uuid4().hex)\n    with open(undefined_param, \"w\") as f:\n      f.write(\"test\")\n    assert os.path.isfile(undefined_param)\n\n    self.params.clear_all(ParamKeyType.CLEAR_ON_MANAGER_START)\n    assert self.params.get(\"CarParams\") is None\n    assert self.params.get(\"DongleId\") is not None\n    assert not os.path.isfile(undefined_param)\n\n  def test_params_two_things(self):\n    self.params.put(\"DongleId\", \"bob\")\n    self.params.put(\"AthenadPid\", \"123\")\n    assert self.params.get(\"DongleId\") == b\"bob\"\n    assert self.params.get(\"AthenadPid\") == b\"123\"\n\n  def test_params_get_block(self):\n    def _delayed_writer():\n      time.sleep(0.1)\n      self.params.put(\"CarParams\", \"test\")\n    threading.Thread(target=_delayed_writer).start()\n    assert self.params.get(\"CarParams\") is None\n    assert self.params.get(\"CarParams\", True) == b\"test\"\n\n  def test_params_unknown_key_fails(self):\n    with pytest.raises(UnknownKeyName):\n      self.params.get(\"swag\")\n\n    with pytest.raises(UnknownKeyName):\n      self.params.get_bool(\"swag\")\n\n    with pytest.raises(UnknownKeyName):\n      self.params.put(\"swag\", \"abc\")\n\n    with pytest.raises(UnknownKeyName):\n      self.params.put_bool(\"swag\", True)\n\n  def test_remove_not_there(self):\n    assert self.params.get(\"CarParams\") is None\n    self.params.remove(\"CarParams\")\n    assert self.params.get(\"CarParams\") is None\n\n  def test_get_bool(self):\n    self.params.remove(\"IsMetric\")\n    assert not self.params.get_bool(\"IsMetric\")\n\n    self.params.put_bool(\"IsMetric\", True)\n    assert self.params.get_bool(\"IsMetric\")\n\n    self.params.put_bool(\"IsMetric\", False)\n    assert not self.params.get_bool(\"IsMetric\")\n\n    self.params.put(\"IsMetric\", \"1\")\n    assert self.params.get_bool(\"IsMetric\")\n\n    self.params.put(\"IsMetric\", \"0\")\n    assert not self.params.get_bool(\"IsMetric\")\n\n  def test_put_non_blocking_with_get_block(self):\n    q = Params()\n    def _delayed_writer():\n      time.sleep(0.1)\n      Params().put_nonblocking(\"CarParams\", \"test\")\n    threading.Thread(target=_delayed_writer).start()\n    assert q.get(\"CarParams\") is None\n    assert q.get(\"CarParams\", True) == b\"test\"\n\n  def test_put_bool_non_blocking_with_get_block(self):\n    q = Params()\n    def _delayed_writer():\n      time.sleep(0.1)\n      Params().put_bool_nonblocking(\"CarParams\", True)\n    threading.Thread(target=_delayed_writer).start()\n    assert q.get(\"CarParams\") is None\n    assert q.get(\"CarParams\", True) == b\"1\"\n\n  def test_params_all_keys(self):\n    keys = Params().all_keys()\n\n    # sanity checks\n    assert len(keys) > 20\n    assert len(keys) == len(set(keys))\n    assert b\"CarParams\" in keys\n",
    "common/tests/test_simple_kalman.py": "from openpilot.common.simple_kalman import KF1D\n\n\nclass TestSimpleKalman:\n  def setup_method(self):\n    dt = 0.01\n    x0_0 = 0.0\n    x1_0 = 0.0\n    A0_0 = 1.0\n    A0_1 = dt\n    A1_0 = 0.0\n    A1_1 = 1.0\n    C0_0 = 1.0\n    C0_1 = 0.0\n    K0_0 = 0.12287673\n    K1_0 = 0.29666309\n\n    self.kf = KF1D(x0=[[x0_0], [x1_0]],\n                   A=[[A0_0, A0_1], [A1_0, A1_1]],\n                   C=[C0_0, C0_1],\n                   K=[[K0_0], [K1_0]])\n\n  def test_getter_setter(self):\n    self.kf.set_x([[1.0], [1.0]])\n    assert self.kf.x == [[1.0], [1.0]]\n\n  def update_returns_state(self):\n    x = self.kf.update(100)\n    assert x == self.kf.x\n"
  },
  "requirements": null
}