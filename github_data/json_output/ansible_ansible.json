{
  "repo_name": "ansible/ansible",
  "repo_url": "https://github.com/ansible/ansible",
  "description": "Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. https://docs.ansible.com.",
  "stars": 64343,
  "language": "Python",
  "created_at": "2012-03-06T14:58:02Z",
  "updated_at": "2025-03-19T06:53:00Z",
  "files": {
    "hacking/test-module.py": "#!/usr/bin/env python\n\n# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# this script is for testing modules without running through the\n# entire guts of ansible, and is very helpful for when developing\n# modules\n#\n# example:\n#    ./hacking/test-module.py -m lib/ansible/modules/command.py -a \"/bin/sleep 3\"\n#    ./hacking/test-module.py -m lib/ansible/modules/command.py -a \"/bin/sleep 3\" --debugger /usr/bin/pdb\n#    ./hacking/test-module.py -m lib/ansible/modules/lineinfile.py -a \"dest=/etc/exports line='/srv/home hostname1(rw,sync)'\" --check\n#    ./hacking/test-module.py -m lib/ansible/modules/command.py -a \"echo hello\" -n -o \"test_hello\"\n\nfrom __future__ import annotations\n\nimport glob\nimport optparse\nimport os\nimport subprocess\nimport sys\nimport traceback\nimport shutil\n\nfrom pathlib import Path\n\nfrom ansible.release import __version__\nimport ansible.utils.vars as utils_vars\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.parsing.utils.jsonify import jsonify\nfrom ansible.parsing.splitter import parse_kv\nfrom ansible.plugins.loader import init_plugin_loader\nfrom ansible.executor import module_common\nimport ansible.constants as C\nfrom ansible.module_utils.common.text.converters import to_native, to_text\nfrom ansible.template import Templar\n\nimport json\n\n\ndef parse():\n    \"\"\"parse command line\n\n    :return : (options, args)\"\"\"\n    parser = optparse.OptionParser()\n\n    parser.usage = \"%prog -[options] (-h for help)\"\n\n    parser.add_option('-m', '--module-path', dest='module_path',\n                      help=\"REQUIRED: full path of module source to execute\")\n    parser.add_option('-a', '--args', dest='module_args', default=\"\",\n                      help=\"module argument string\")\n    parser.add_option('-D', '--debugger', dest='debugger',\n                      help=\"path to python debugger (e.g. /usr/bin/pdb)\")\n    parser.add_option('-I', '--interpreter', dest='interpreter',\n                      help=\"path to interpreter to use for this module\"\n                      \" (e.g. ansible_python_interpreter=/usr/bin/python)\",\n                      metavar='INTERPRETER_TYPE=INTERPRETER_PATH',\n                      default=\"ansible_python_interpreter=%s\" %\n                      (sys.executable if sys.executable else '/usr/bin/python'))\n    parser.add_option('-c', '--check', dest='check', action='store_true',\n                      help=\"run the module in check mode\")\n    parser.add_option('-n', '--noexecute', dest='execute', action='store_false',\n                      default=True, help=\"do not run the resulting module\")\n    parser.add_option('-o', '--output', dest='filename',\n                      help=\"Filename for resulting module\",\n                      default=\"~/.ansible_module_generated\")\n    options, args = parser.parse_args()\n    if not options.module_path:\n        parser.print_help()\n        sys.exit(1)\n    else:\n        return options, args\n\n\ndef write_argsfile(argstring, json=False):\n    \"\"\" Write args to a file for old-style module's use. \"\"\"\n    argspath = Path(\"~/.ansible_test_module_arguments\").expanduser()\n    if json:\n        args = parse_kv(argstring)\n        argstring = jsonify(args)\n    argspath.write_text(argstring)\n    return argspath\n\n\ndef get_interpreters(interpreter):\n    result = dict()\n    if interpreter:\n        if '=' not in interpreter:\n            print(\"interpreter must by in the form of ansible_python_interpreter=/usr/bin/python\")\n            sys.exit(1)\n        interpreter_type, interpreter_path = interpreter.split('=')\n        if not interpreter_type.startswith('ansible_'):\n            interpreter_type = 'ansible_%s' % interpreter_type\n        if not interpreter_type.endswith('_interpreter'):\n            interpreter_type = '%s_interpreter' % interpreter_type\n        result[interpreter_type] = interpreter_path\n    return result\n\n\ndef boilerplate_module(modfile, args, interpreters, check, destfile):\n    \"\"\" simulate what ansible does with new style modules \"\"\"\n\n    # module_fh = open(modfile)\n    # module_data = module_fh.read()\n    # module_fh.close()\n\n    # replacer = module_common.ModuleReplacer()\n    loader = DataLoader()\n\n    # included_boilerplate = module_data.find(module_common.REPLACER) != -1 or module_data.find(\"import ansible.module_utils\") != -1\n\n    complex_args = {}\n\n    # default selinux fs list is pass in as _ansible_selinux_special_fs arg\n    complex_args['_ansible_selinux_special_fs'] = C.DEFAULT_SELINUX_SPECIAL_FS\n    complex_args['_ansible_tmpdir'] = C.DEFAULT_LOCAL_TMP\n    complex_args['_ansible_keep_remote_files'] = C.DEFAULT_KEEP_REMOTE_FILES\n    complex_args['_ansible_version'] = __version__\n\n    if args.startswith(\"@\"):\n        # Argument is a YAML file (JSON is a subset of YAML)\n        complex_args = utils_vars.combine_vars(complex_args, loader.load_from_file(args[1:]))\n        args = ''\n    elif args.startswith(\"{\"):\n        # Argument is a YAML document (not a file)\n        complex_args = utils_vars.combine_vars(complex_args, loader.load(args))\n        args = ''\n\n    if args:\n        parsed_args = parse_kv(args)\n        complex_args = utils_vars.combine_vars(complex_args, parsed_args)\n\n    task_vars = interpreters\n\n    if check:\n        complex_args['_ansible_check_mode'] = True\n\n    modname = os.path.basename(modfile)\n    modname = os.path.splitext(modname)[0]\n    (module_data, module_style, shebang) = module_common.modify_module(\n        modname,\n        modfile,\n        complex_args,\n        Templar(loader=loader),\n        task_vars=task_vars\n    )\n\n    if module_style == 'new' and '_ANSIBALLZ_WRAPPER = True' in to_native(module_data):\n        module_style = 'ansiballz'\n\n    modfile2_path = os.path.expanduser(destfile)\n    print(\"* including generated source, if any, saving to: %s\" % modfile2_path)\n    if module_style not in ('ansiballz', 'old'):\n        print(\"* this may offset any line numbers in tracebacks/debuggers!\")\n    with open(modfile2_path, 'wb') as modfile2:\n        modfile2.write(module_data)\n    modfile = modfile2_path\n\n    return (modfile2_path, modname, module_style)\n\n\ndef ansiballz_setup(modfile, modname, interpreters):\n    os.system(\"chmod +x %s\" % modfile)\n\n    if 'ansible_python_interpreter' in interpreters:\n        command = [interpreters['ansible_python_interpreter']]\n    else:\n        command = []\n    command.extend([modfile, 'explode'])\n\n    cmd = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, err = cmd.communicate()\n    out, err = to_text(out, errors='surrogate_or_strict'), to_text(err)\n    lines = out.splitlines()\n    if len(lines) != 2 or 'Module expanded into' not in lines[0]:\n        print(\"*\" * 35)\n        print(\"INVALID OUTPUT FROM ANSIBALLZ MODULE WRAPPER\")\n        print(out)\n        sys.exit(err)\n    debug_dir = lines[1].strip()\n\n    # All the directories in an AnsiBallZ that modules can live\n    core_dirs = glob.glob(os.path.join(debug_dir, 'ansible/modules'))\n    collection_dirs = glob.glob(os.path.join(debug_dir, 'ansible_collections/*/*/plugins/modules'))\n\n    # There's only one module in an AnsiBallZ payload so look for the first module and then exit\n    for module_dir in core_dirs + collection_dirs:\n        for dirname, directories, filenames in os.walk(module_dir):\n            for filename in filenames:\n                if filename == modname + '.py':\n                    modfile = os.path.join(dirname, filename)\n                    break\n\n    argsfile = os.path.join(debug_dir, 'args')\n\n    print(\"* ansiballz module detected; extracted module source to: %s\" % debug_dir)\n    return modfile, argsfile\n\n\ndef runtest(modfile, argspath, modname, module_style, interpreters):\n    \"\"\"Test run a module, piping it's output for reporting.\"\"\"\n    invoke = \"\"\n    if module_style == 'ansiballz':\n        modfile, argspath = ansiballz_setup(modfile, modname, interpreters)\n        if 'ansible_python_interpreter' in interpreters:\n            invoke = \"%s \" % interpreters['ansible_python_interpreter']\n\n    os.system(\"chmod +x %s\" % modfile)\n\n    invoke = \"%s%s\" % (invoke, modfile)\n    if argspath is not None:\n        invoke = \"%s %s\" % (invoke, argspath)\n\n    cmd = subprocess.Popen(invoke, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    (out, err) = cmd.communicate()\n    out, err = to_text(out), to_text(err)\n\n    try:\n        print(\"*\" * 35)\n        print(\"RAW OUTPUT\")\n        print(out)\n        print(err)\n        results = json.loads(out)\n    except Exception:\n        print(\"*\" * 35)\n        print(\"INVALID OUTPUT FORMAT\")\n        print(out)\n        traceback.print_exc()\n        sys.exit(1)\n\n    print(\"*\" * 35)\n    print(\"PARSED OUTPUT\")\n    print(jsonify(results, format=True))\n\n\ndef rundebug(debugger, modfile, argspath, modname, module_style, interpreters):\n    \"\"\"Run interactively with console debugger.\"\"\"\n\n    if module_style == 'ansiballz':\n        modfile, argspath = ansiballz_setup(modfile, modname, interpreters)\n\n    if argspath is not None:\n        subprocess.call(\"%s %s %s\" % (debugger, modfile, argspath), shell=True)\n    else:\n        subprocess.call(\"%s %s\" % (debugger, modfile), shell=True)\n\n\ndef main():\n\n    options, args = parse()\n    init_plugin_loader()\n    interpreters = get_interpreters(options.interpreter)\n    (modfile, modname, module_style) = boilerplate_module(options.module_path, options.module_args, interpreters, options.check, options.filename)\n\n    argspath = None\n    if module_style not in ('new', 'ansiballz'):\n        if module_style in ('non_native_want_json', 'binary'):\n            argspath = write_argsfile(options.module_args, json=True)\n        elif module_style == 'old':\n            argspath = write_argsfile(options.module_args, json=False)\n        else:\n            raise Exception(\"internal error, unexpected module style: %s\" % module_style)\n\n    if options.execute:\n        if options.debugger:\n            rundebug(options.debugger, modfile, argspath, modname, module_style, interpreters)\n        else:\n            runtest(modfile, argspath, modname, module_style, interpreters)\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    finally:\n        shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)\n",
    "hacking/tests/gen_distribution_version_testcase.py": "#!/usr/bin/env python\n\n\"\"\"\nThis script generated test_cases for test_distribution_version.py.\n\nTo do so it outputs the relevant files from /etc/*release, the output of distro.linux_distribution()\nand the current ansible_facts regarding the distribution version.\n\nThis assumes a working ansible version in the path.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport os.path\nimport platform\nimport subprocess\nimport sys\n\nfrom ansible.module_utils import distro\nfrom ansible.module_utils.common.text.converters import to_text\n\n\nfilelist = [\n    '/etc/oracle-release',\n    '/etc/slackware-version',\n    '/etc/centos-release',\n    '/etc/redhat-release',\n    '/etc/vmware-release',\n    '/etc/openwrt_release',\n    '/etc/system-release',\n    '/etc/alpine-release',\n    '/etc/release',\n    '/etc/arch-release',\n    '/etc/os-release',\n    '/etc/SuSE-release',\n    '/etc/gentoo-release',\n    '/etc/os-release',\n    '/etc/lsb-release',\n    '/etc/altlinux-release',\n    '/etc/os-release',\n    '/etc/coreos/update.conf',\n    '/usr/lib/os-release',\n]\n\nfcont = {}\n\nfor f in filelist:\n    if os.path.exists(f):\n        s = os.path.getsize(f)\n        if s > 0 and s < 10000:\n            with open(f) as fh:\n                fcont[f] = fh.read()\n\ndist = (distro.id(), distro.version(), distro.codename())\n\nfacts = ['distribution', 'distribution_version', 'distribution_release', 'distribution_major_version', 'os_family']\n\ntry:\n    b_ansible_out = subprocess.check_output(\n        ['ansible', 'localhost', '-m', 'setup'])\nexcept subprocess.CalledProcessError as e:\n    print(\"ERROR: ansible run failed, output was: \\n\")\n    print(e.output)\n    sys.exit(e.returncode)\n\nansible_out = to_text(b_ansible_out)\nparsed = json.loads(ansible_out[ansible_out.index('{'):])\nansible_facts = {}\nfor fact in facts:\n    try:\n        ansible_facts[fact] = parsed['ansible_facts']['ansible_' + fact]\n    except Exception:\n        ansible_facts[fact] = \"N/A\"\n\nnicename = ansible_facts['distribution'] + ' ' + ansible_facts['distribution_version']\n\noutput = {\n    'name': nicename,\n    'distro': {\n        'codename': distro.codename(),\n        'id': distro.id(),\n        'name': distro.name(),\n        'version': distro.version(),\n        'version_best': distro.version(best=True),\n        'lsb_release_info': distro.lsb_release_info(),\n        'os_release_info': distro.os_release_info(),\n    },\n    'input': fcont,\n    'platform.dist': dist,\n    'result': ansible_facts,\n}\n\nsystem = platform.system()\nif system != 'Linux':\n    output['platform.system'] = system\n\nrelease = platform.release()\nif release:\n    output['platform.release'] = release\n\nprint(json.dumps(output, indent=4))\n",
    "lib/ansible/plugins/test/__init__.py": "# (c) Ansible Project\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import annotations\n\nfrom ansible.plugins import AnsibleJinja2Plugin\n\n\nclass AnsibleJinja2Test(AnsibleJinja2Plugin):\n\n    def _no_options(self, *args, **kwargs):\n        raise NotImplementedError(\"Jinaj2 test plugins do not support option functions, they use direct arguments instead.\")\n",
    "lib/ansible/plugins/test/core.py": "# (c) 2012, Jeroen Hoekx <jeroen@hoekx.be>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import annotations\n\nimport re\nimport operator as py_operator\n\nfrom collections.abc import MutableMapping, MutableSequence\n\nfrom ansible.module_utils.compat.version import LooseVersion, StrictVersion\n\nfrom ansible import errors\nfrom ansible.module_utils.common.text.converters import to_native, to_text, to_bytes\nfrom ansible.module_utils.parsing.convert_bool import boolean\nfrom ansible.parsing.vault import is_encrypted_file\nfrom ansible.utils.display import Display\nfrom ansible.utils.version import SemanticVersion\n\ntry:\n    from packaging.version import Version as PEP440Version\n    HAS_PACKAGING = True\nexcept ImportError:\n    HAS_PACKAGING = False\n\ndisplay = Display()\n\n\ndef timedout(result):\n    \"\"\" Test if task result yields a time out\"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'timedout' test expects a dictionary\")\n    return result.get('timedout', False) and result['timedout'].get('period', False)\n\n\ndef failed(result):\n    \"\"\" Test if task result yields failed \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'failed' test expects a dictionary\")\n    return result.get('failed', False)\n\n\ndef success(result):\n    \"\"\" Test if task result yields success \"\"\"\n    return not failed(result)\n\n\ndef unreachable(result):\n    \"\"\" Test if task result yields unreachable \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'unreachable' test expects a dictionary\")\n    return result.get('unreachable', False)\n\n\ndef reachable(result):\n    \"\"\" Test if task result yields reachable \"\"\"\n    return not unreachable(result)\n\n\ndef changed(result):\n    \"\"\" Test if task result yields changed \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'changed' test expects a dictionary\")\n    if 'changed' not in result:\n        changed = False\n        if (\n            'results' in result and   # some modules return a 'results' key\n            isinstance(result['results'], MutableSequence) and\n            isinstance(result['results'][0], MutableMapping)\n        ):\n            for res in result['results']:\n                if res.get('changed', False):\n                    changed = True\n                    break\n    else:\n        changed = result.get('changed', False)\n    return changed\n\n\ndef skipped(result):\n    \"\"\" Test if task result yields skipped \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'skipped' test expects a dictionary\")\n    return result.get('skipped', False)\n\n\ndef started(result):\n    \"\"\" Test if async task has started \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'started' test expects a dictionary\")\n    if 'started' in result:\n        # For async tasks, return status\n        # NOTE: The value of started is 0 or 1, not False or True :-/\n        return result.get('started', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if started\n        display.warning(\"The 'started' test expects an async task, but a non-async task was tested\")\n        return True\n\n\ndef finished(result):\n    \"\"\" Test if async task has finished \"\"\"\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'finished' test expects a dictionary\")\n    if 'finished' in result:\n        # For async tasks, return status\n        # NOTE: The value of finished is 0 or 1, not False or True :-/\n        return result.get('finished', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if finished\n        display.warning(\"The 'finished' test expects an async task, but a non-async task was tested\")\n        return True\n\n\ndef regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search'):\n    \"\"\" Expose `re` as a boolean filter using the `search` method by default.\n        This is likely only useful for `search` and `match` which already\n        have their own filters.\n    \"\"\"\n    # In addition to ensuring the correct type, to_text here will ensure\n    # _fail_with_undefined_error happens if the value is Undefined\n    value = to_text(value, errors='surrogate_or_strict')\n    flags = 0\n    if ignorecase:\n        flags |= re.I\n    if multiline:\n        flags |= re.M\n    _re = re.compile(pattern, flags=flags)\n    return bool(getattr(_re, match_type, 'search')(value))\n\n\ndef vault_encrypted(value):\n    \"\"\"Evaluate whether a variable is a single vault encrypted value\n\n    .. versionadded:: 2.10\n    \"\"\"\n    return getattr(value, '__ENCRYPTED__', False) and value.is_encrypted()\n\n\ndef vaulted_file(value):\n    \"\"\"Evaluate whether a file is a vault\n\n    .. versionadded:: 2.18\n    \"\"\"\n    try:\n        with open(to_bytes(value), 'rb') as f:\n            return is_encrypted_file(f)\n    except (OSError, IOError) as e:\n        raise errors.AnsibleFilterError(f\"Cannot test if the file {value} is a vault\", orig_exc=e)\n\n\ndef match(value, pattern='', ignorecase=False, multiline=False):\n    \"\"\" Perform a `re.match` returning a boolean \"\"\"\n    return regex(value, pattern, ignorecase, multiline, 'match')\n\n\ndef search(value, pattern='', ignorecase=False, multiline=False):\n    \"\"\" Perform a `re.search` returning a boolean \"\"\"\n    return regex(value, pattern, ignorecase, multiline, 'search')\n\n\ndef version_compare(value, version, operator='eq', strict=None, version_type=None):\n    \"\"\" Perform a version comparison on a value \"\"\"\n    op_map = {\n        '==': 'eq', '=': 'eq', 'eq': 'eq',\n        '<': 'lt', 'lt': 'lt',\n        '<=': 'le', 'le': 'le',\n        '>': 'gt', 'gt': 'gt',\n        '>=': 'ge', 'ge': 'ge',\n        '!=': 'ne', '<>': 'ne', 'ne': 'ne'\n    }\n\n    type_map = {\n        'loose': LooseVersion,\n        'strict': StrictVersion,\n        'semver': SemanticVersion,\n        'semantic': SemanticVersion,\n        'pep440': PEP440Version,\n    }\n\n    if strict is not None and version_type is not None:\n        raise errors.AnsibleFilterError(\"Cannot specify both 'strict' and 'version_type'\")\n\n    if not value:\n        raise errors.AnsibleFilterError(\"Input version value cannot be empty\")\n\n    if not version:\n        raise errors.AnsibleFilterError(\"Version parameter to compare against cannot be empty\")\n\n    if version_type == 'pep440' and not HAS_PACKAGING:\n        raise errors.AnsibleFilterError(\"The pep440 version_type requires the Python 'packaging' library\")\n\n    Version = LooseVersion\n    if strict:\n        Version = StrictVersion\n    elif version_type:\n        try:\n            Version = type_map[version_type]\n        except KeyError:\n            raise errors.AnsibleFilterError(\n                \"Invalid version type (%s). Must be one of %s\" % (version_type, ', '.join(map(repr, type_map)))\n            )\n\n    if operator in op_map:\n        operator = op_map[operator]\n    else:\n        raise errors.AnsibleFilterError(\n            'Invalid operator type (%s). Must be one of %s' % (operator, ', '.join(map(repr, op_map)))\n        )\n\n    try:\n        method = getattr(py_operator, operator)\n        return method(Version(to_text(value)), Version(to_text(version)))\n    except Exception as e:\n        raise errors.AnsibleFilterError('Version comparison failed: %s' % to_native(e))\n\n\ndef truthy(value, convert_bool=False):\n    \"\"\"Evaluate as value for truthiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    if convert_bool:\n        try:\n            value = boolean(value)\n        except TypeError:\n            pass\n\n    return bool(value)\n\n\ndef falsy(value, convert_bool=False):\n    \"\"\"Evaluate as value for falsiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    return not truthy(value, convert_bool=convert_bool)\n\n\nclass TestModule(object):\n    \"\"\" Ansible core jinja2 tests \"\"\"\n\n    def tests(self):\n        return {\n            # failure testing\n            'failed': failed,\n            'failure': failed,\n            'succeeded': success,\n            'success': success,\n            'successful': success,\n            'reachable': reachable,\n            'unreachable': unreachable,\n            'timedout': timedout,\n\n            # changed testing\n            'changed': changed,\n            'change': changed,\n\n            # skip testing\n            'skipped': skipped,\n            'skip': skipped,\n\n            # async testing\n            'finished': finished,\n            'started': started,\n\n            # regex\n            'match': match,\n            'search': search,\n            'regex': regex,\n\n            # version comparison\n            'version_compare': version_compare,\n            'version': version_compare,\n\n            # lists\n            'any': any,\n            'all': all,\n\n            # truthiness\n            'truthy': truthy,\n            'falsy': falsy,\n\n            # vault\n            'vault_encrypted': vault_encrypted,\n            'vaulted_file': vaulted_file,\n        }\n",
    "lib/ansible/plugins/test/files.py": "# (c) 2015, Ansible, Inc\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import annotations\n\nfrom os.path import isdir, isfile, isabs, exists, lexists, islink, samefile, ismount\n\n\nclass TestModule(object):\n    \"\"\" Ansible file jinja2 tests \"\"\"\n\n    def tests(self):\n        return {\n            # file testing\n            'directory': isdir,\n            'is_dir': isdir,\n            'file': isfile,\n            'is_file': isfile,\n            'link': islink,\n            'is_link': islink,\n            'exists': exists,\n            'link_exists': lexists,\n\n            # path testing\n            'abs': isabs,\n            'is_abs': isabs,\n            'same_file': samefile,\n            'is_same_file': samefile,\n            'mount': ismount,\n            'is_mount': ismount,\n        }\n",
    "lib/ansible/plugins/test/mathstuff.py": "# (c) 2016, Ansible, Inc\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import annotations\n\nimport math\n\n\ndef issubset(a, b):\n    return set(a) <= set(b)\n\n\ndef issuperset(a, b):\n    return set(a) >= set(b)\n\n\ndef isnotanumber(x):\n    try:\n        return math.isnan(x)\n    except TypeError:\n        return False\n\n\ndef contains(seq, value):\n    \"\"\"Opposite of the ``in`` test, allowing use as a test in filters like ``selectattr``\n\n    .. versionadded:: 2.8\n    \"\"\"\n    return value in seq\n\n\nclass TestModule:\n    \"\"\" Ansible math jinja2 tests \"\"\"\n\n    def tests(self):\n        return {\n            # set theory\n            'subset': issubset,\n            'issubset': issubset,\n            'superset': issuperset,\n            'issuperset': issuperset,\n            'contains': contains,\n\n            # numbers\n            'nan': isnotanumber,\n            'isnan': isnotanumber,\n        }\n",
    "lib/ansible/plugins/test/uri.py": "# (c) Ansible Project\n\nfrom __future__ import annotations\n\nfrom urllib.parse import urlparse\n\n\ndef is_uri(value, schemes=None):\n    \"\"\" Will verify that the string passed is a valid 'URI', if given a list of valid schemes it will match those \"\"\"\n    try:\n        x = urlparse(value)\n        isit = all([x.scheme is not None, x.path is not None, not schemes or x.scheme in schemes])\n    except Exception as e:\n        isit = False\n    return isit\n\n\ndef is_url(value, schemes=None):\n    \"\"\" Will verify that the string passed is a valid 'URL' \"\"\"\n\n    isit = is_uri(value, schemes)\n    if isit:\n        try:\n            x = urlparse(value)\n            isit = bool(x.netloc or x.scheme == 'file')\n        except Exception as e:\n            isit = False\n    return isit\n\n\ndef is_urn(value):\n    return is_uri(value, ['urn'])\n\n\nclass TestModule(object):\n    \"\"\" Ansible URI jinja2 test \"\"\"\n\n    def tests(self):\n        return {\n            # file testing\n            'uri': is_uri,\n            'url': is_url,\n            'urn': is_urn,\n        }\n",
    "test/integration/targets/ansiballz_python/library/check_rlimit_and_maxfd.py": "#!/usr/bin/python\n#\n# Copyright 2018 Red Hat | Ansible\n# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)\n\nfrom __future__ import annotations\n\nimport resource\nimport subprocess\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict()\n    )\n\n    rlimit_nofile = resource.getrlimit(resource.RLIMIT_NOFILE)\n\n    try:\n        maxfd = subprocess.MAXFD\n    except AttributeError:\n        maxfd = -1\n\n    module.exit_json(rlimit_nofile=rlimit_nofile, maxfd=maxfd, infinity=resource.RLIM_INFINITY)\n\n\nif __name__ == '__main__':\n    main()\n",
    "test/integration/targets/ansiballz_python/library/custom_module.py": "#!/usr/bin/python\n\nfrom __future__ import annotations\n\nfrom ..module_utils.basic import AnsibleModule  # pylint: disable=relative-beyond-top-level\nfrom ..module_utils.custom_util import forty_two  # pylint: disable=relative-beyond-top-level\n\n\ndef main():\n    module = AnsibleModule(\n        argument_spec=dict()\n    )\n\n    module.exit_json(answer=forty_two())\n\n\nif __name__ == '__main__':\n    main()\n",
    "test/integration/targets/ansiballz_python/library/sys_check.py": "#!/usr/bin/python\n# https://github.com/ansible/ansible/issues/64664\n# https://github.com/ansible/ansible/issues/64479\n\nfrom __future__ import annotations\n\nimport sys\n\nfrom ansible.module_utils.basic import AnsibleModule\n\n\ndef main():\n    module = AnsibleModule({})\n\n    this_module = sys.modules[__name__]\n    module.exit_json(\n        failed=not getattr(this_module, 'AnsibleModule', False)\n    )\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  "requirements": "# Note: this requirements.txt file is used to specify what dependencies are\n# needed to make the package run rather than for deployment of a tested set of\n# packages.  Thus, this should be the loosest set possible (only required\n# packages, not optional ones, and with the widest range of versions that could\n# be suitable)\njinja2 >= 3.0.0\nPyYAML >= 5.1  # PyYAML 5.1 is required for Python 3.8+ support\ncryptography\npackaging\n# NOTE: resolvelib 0.x version bumps should be considered major/breaking\n# NOTE: and we should update the upper cap with care, at least until 1.0\n# NOTE: Ref: https://github.com/sarugaku/resolvelib/issues/69\n# NOTE: When updating the upper bound, also update the latest version used\n# NOTE: in the ansible-galaxy-collection test suite.\nresolvelib >= 0.5.3, < 2.0.0  # dependency resolver used by ansible-galaxy\n"
}