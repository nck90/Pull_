{
  "repo_name": "psf/requests",
  "repo_url": "https://github.com/psf/requests",
  "description": "A simple, yet elegant, HTTP library.",
  "stars": 52618,
  "language": "Python",
  "created_at": "2011-02-13T18:38:17Z",
  "updated_at": "2025-03-19T06:28:52Z",
  "files": {
    "tests/__init__.py": "\"\"\"Requests test package initialisation.\"\"\"\n\nimport warnings\n\ntry:\n    from urllib3.exceptions import SNIMissingWarning\n\n    # urllib3 1.x sets SNIMissingWarning to only go off once,\n    # while this test suite requires it to always fire\n    # so that it occurs during test_requests.test_https_warnings\n    warnings.simplefilter(\"always\", SNIMissingWarning)\nexcept ImportError:\n    # urllib3 2.0 removed that warning and errors out instead\n    SNIMissingWarning = None\n",
    "tests/compat.py": "import warnings\n\ntry:\n    import StringIO\nexcept ImportError:\n    import io as StringIO\n\ntry:\n    from cStringIO import StringIO as cStringIO\nexcept ImportError:\n    cStringIO = None\n\n\ndef u(s):\n    warnings.warn(\n        (\n            \"This helper function is no longer relevant in Python 3. \"\n            \"Usage of this alias should be discontinued as it will be \"\n            \"removed in a future release of Requests.\"\n        ),\n        DeprecationWarning,\n    )\n    return s\n",
    "tests/conftest.py": "try:\n    from http.server import HTTPServer, SimpleHTTPRequestHandler\nexcept ImportError:\n    from BaseHTTPServer import HTTPServer\n    from SimpleHTTPServer import SimpleHTTPRequestHandler\n\nimport ssl\nimport threading\n\nimport pytest\n\nfrom requests.compat import urljoin\n\n\ndef prepare_url(value):\n    # Issue #1483: Make sure the URL always has a trailing slash\n    httpbin_url = value.url.rstrip(\"/\") + \"/\"\n\n    def inner(*suffix):\n        return urljoin(httpbin_url, \"/\".join(suffix))\n\n    return inner\n\n\n@pytest.fixture\ndef httpbin(httpbin):\n    return prepare_url(httpbin)\n\n\n@pytest.fixture\ndef httpbin_secure(httpbin_secure):\n    return prepare_url(httpbin_secure)\n\n\n@pytest.fixture\ndef nosan_server(tmp_path_factory):\n    # delay importing until the fixture in order to make it possible\n    # to deselect the test via command-line when trustme is not available\n    import trustme\n\n    tmpdir = tmp_path_factory.mktemp(\"certs\")\n    ca = trustme.CA()\n    # only commonName, no subjectAltName\n    server_cert = ca.issue_cert(common_name=\"localhost\")\n    ca_bundle = str(tmpdir / \"ca.pem\")\n    ca.cert_pem.write_to_path(ca_bundle)\n\n    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    server_cert.configure_cert(context)\n    server = HTTPServer((\"localhost\", 0), SimpleHTTPRequestHandler)\n    server.socket = context.wrap_socket(server.socket, server_side=True)\n    server_thread = threading.Thread(target=server.serve_forever)\n    server_thread.start()\n\n    yield \"localhost\", server.server_address[1], ca_bundle\n\n    server.shutdown()\n    server_thread.join()\n",
    "tests/test_adapters.py": "import requests.adapters\n\n\ndef test_request_url_trims_leading_path_separators():\n    \"\"\"See also https://github.com/psf/requests/issues/6643.\"\"\"\n    a = requests.adapters.HTTPAdapter()\n    p = requests.Request(method=\"GET\", url=\"http://127.0.0.1:10000//v:h\").prepare()\n    assert \"/v:h\" == a.request_url(p, {})\n",
    "tests/test_help.py": "from unittest import mock\n\nfrom requests.help import info\n\n\ndef test_system_ssl():\n    \"\"\"Verify we're actually setting system_ssl when it should be available.\"\"\"\n    assert info()[\"system_ssl\"][\"version\"] != \"\"\n\n\nclass VersionedPackage:\n    def __init__(self, version):\n        self.__version__ = version\n\n\ndef test_idna_without_version_attribute():\n    \"\"\"Older versions of IDNA don't provide a __version__ attribute, verify\n    that if we have such a package, we don't blow up.\n    \"\"\"\n    with mock.patch(\"requests.help.idna\", new=None):\n        assert info()[\"idna\"] == {\"version\": \"\"}\n\n\ndef test_idna_with_version_attribute():\n    \"\"\"Verify we're actually setting idna version when it should be available.\"\"\"\n    with mock.patch(\"requests.help.idna\", new=VersionedPackage(\"2.6\")):\n        assert info()[\"idna\"] == {\"version\": \"2.6\"}\n",
    "tests/test_hooks.py": "import pytest\n\nfrom requests import hooks\n\n\ndef hook(value):\n    return value[1:]\n\n\n@pytest.mark.parametrize(\n    \"hooks_list, result\",\n    (\n        (hook, \"ata\"),\n        ([hook, lambda x: None, hook], \"ta\"),\n    ),\n)\ndef test_hooks(hooks_list, result):\n    assert hooks.dispatch_hook(\"response\", {\"response\": hooks_list}, \"Data\") == result\n\n\ndef test_default_hooks():\n    assert hooks.default_hooks() == {\"response\": []}\n",
    "tests/test_lowlevel.py": "import threading\n\nimport pytest\nfrom tests.testserver.server import Server, consume_socket_content\n\nimport requests\nfrom requests.compat import JSONDecodeError\n\nfrom .utils import override_environ\n\n\ndef echo_response_handler(sock):\n    \"\"\"Simple handler that will take request and echo it back to requester.\"\"\"\n    request_content = consume_socket_content(sock, timeout=0.5)\n\n    text_200 = (\n        b\"HTTP/1.1 200 OK\\r\\n\"\n        b\"Content-Length: %d\\r\\n\\r\\n\"\n        b\"%s\"\n    ) % (len(request_content), request_content)\n    sock.send(text_200)\n\n\ndef test_chunked_upload():\n    \"\"\"can safely send generators\"\"\"\n    close_server = threading.Event()\n    server = Server.basic_response_server(wait_to_close_event=close_server)\n    data = iter([b\"a\", b\"b\", b\"c\"])\n\n    with server as (host, port):\n        url = f\"http://{host}:{port}/\"\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    assert r.status_code == 200\n    assert r.request.headers[\"Transfer-Encoding\"] == \"chunked\"\n\n\ndef test_chunked_encoding_error():\n    \"\"\"get a ChunkedEncodingError if the server returns a bad response\"\"\"\n\n    def incomplete_chunked_response_handler(sock):\n        request_content = consume_socket_content(sock, timeout=0.5)\n\n        # The server never ends the request and doesn't provide any valid chunks\n        sock.send(\n            b\"HTTP/1.1 200 OK\\r\\n\"\n            b\"Transfer-Encoding: chunked\\r\\n\"\n        )\n\n        return request_content\n\n    close_server = threading.Event()\n    server = Server(incomplete_chunked_response_handler)\n\n    with server as (host, port):\n        url = f\"http://{host}:{port}/\"\n        with pytest.raises(requests.exceptions.ChunkedEncodingError):\n            requests.get(url)\n        close_server.set()  # release server block\n\n\ndef test_chunked_upload_uses_only_specified_host_header():\n    \"\"\"Ensure we use only the specified Host header for chunked requests.\"\"\"\n    close_server = threading.Event()\n    server = Server(echo_response_handler, wait_to_close_event=close_server)\n\n    data = iter([b\"a\", b\"b\", b\"c\"])\n    custom_host = \"sample-host\"\n\n    with server as (host, port):\n        url = f\"http://{host}:{port}/\"\n        r = requests.post(url, data=data, headers={\"Host\": custom_host}, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b\"Host: %s\\r\\n\" % custom_host.encode(\"utf-8\")\n    assert expected_header in r.content\n    assert r.content.count(b\"Host: \") == 1\n\n\ndef test_chunked_upload_doesnt_skip_host_header():\n    \"\"\"Ensure we don't omit all Host headers with chunked requests.\"\"\"\n    close_server = threading.Event()\n    server = Server(echo_response_handler, wait_to_close_event=close_server)\n\n    data = iter([b\"a\", b\"b\", b\"c\"])\n\n    with server as (host, port):\n        expected_host = f\"{host}:{port}\"\n        url = f\"http://{host}:{port}/\"\n        r = requests.post(url, data=data, stream=True)\n        close_server.set()  # release server block\n\n    expected_header = b\"Host: %s\\r\\n\" % expected_host.encode(\"utf-8\")\n    assert expected_header in r.content\n    assert r.content.count(b\"Host: \") == 1\n\n\ndef test_conflicting_content_lengths():\n    \"\"\"Ensure we correctly throw an InvalidHeader error if multiple\n    conflicting Content-Length headers are returned.\n    \"\"\"\n\n    def multiple_content_length_response_handler(sock):\n        request_content = consume_socket_content(sock, timeout=0.5)\n        response = (\n            b\"HTTP/1.1 200 OK\\r\\n\"\n            b\"Content-Type: text/plain\\r\\n\"\n            b\"Content-Length: 16\\r\\n\"\n            b\"Content-Length: 32\\r\\n\\r\\n\"\n            b\"-- Bad Actor -- Original Content\\r\\n\"\n        )\n        sock.send(response)\n\n        return request_content\n\n    close_server = threading.Event()\n    server = Server(multiple_content_length_response_handler)\n\n    with server as (host, port):\n        url = f\"http://{host}:{port}/\"\n        with pytest.raises(requests.exceptions.InvalidHeader):\n            requests.get(url)\n        close_server.set()\n\n\ndef test_digestauth_401_count_reset_on_redirect():\n    \"\"\"Ensure we correctly reset num_401_calls after a successful digest auth,\n    followed by a 302 redirect to another digest auth prompt.\n\n    See https://github.com/psf/requests/issues/1979.\n    \"\"\"\n    text_401 = (b'HTTP/1.1 401 UNAUTHORIZED\\r\\n'\n                b'Content-Length: 0\\r\\n'\n                b'WWW-Authenticate: Digest nonce=\"6bf5d6e4da1ce66918800195d6b9130d\"'\n                b', opaque=\"372825293d1c26955496c80ed6426e9e\", '\n                b'realm=\"me@kennethreitz.com\", qop=auth\\r\\n\\r\\n')\n\n    text_302 = (b'HTTP/1.1 302 FOUND\\r\\n'\n                b'Content-Length: 0\\r\\n'\n                b'Location: /\\r\\n\\r\\n')\n\n    text_200 = (b'HTTP/1.1 200 OK\\r\\n'\n                b'Content-Length: 0\\r\\n\\r\\n')\n\n    expected_digest = (b'Authorization: Digest username=\"user\", '\n                       b'realm=\"me@kennethreitz.com\", '\n                       b'nonce=\"6bf5d6e4da1ce66918800195d6b9130d\", uri=\"/\"')\n\n    auth = requests.auth.HTTPDigestAuth('user', 'pass')\n\n    def digest_response_handler(sock):\n        # Respond to initial GET with a challenge.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert request_content.startswith(b\"GET / HTTP/1.1\")\n        sock.send(text_401)\n\n        # Verify we receive an Authorization header in response, then redirect.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert expected_digest in request_content\n        sock.send(text_302)\n\n        # Verify Authorization isn't sent to the redirected host,\n        # then send another challenge.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert b'Authorization:' not in request_content\n        sock.send(text_401)\n\n        # Verify Authorization is sent correctly again, and return 200 OK.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert expected_digest in request_content\n        sock.send(text_200)\n\n        return request_content\n\n    close_server = threading.Event()\n    server = Server(digest_response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/'\n        r = requests.get(url, auth=auth)\n        # Verify server succeeded in authenticating.\n        assert r.status_code == 200\n        # Verify Authorization was sent in final request.\n        assert 'Authorization' in r.request.headers\n        assert r.request.headers['Authorization'].startswith('Digest ')\n        # Verify redirect happened as we expected.\n        assert r.history[0].status_code == 302\n        close_server.set()\n\n\ndef test_digestauth_401_only_sent_once():\n    \"\"\"Ensure we correctly respond to a 401 challenge once, and then\n    stop responding if challenged again.\n    \"\"\"\n    text_401 = (b'HTTP/1.1 401 UNAUTHORIZED\\r\\n'\n                b'Content-Length: 0\\r\\n'\n                b'WWW-Authenticate: Digest nonce=\"6bf5d6e4da1ce66918800195d6b9130d\"'\n                b', opaque=\"372825293d1c26955496c80ed6426e9e\", '\n                b'realm=\"me@kennethreitz.com\", qop=auth\\r\\n\\r\\n')\n\n    expected_digest = (b'Authorization: Digest username=\"user\", '\n                       b'realm=\"me@kennethreitz.com\", '\n                       b'nonce=\"6bf5d6e4da1ce66918800195d6b9130d\", uri=\"/\"')\n\n    auth = requests.auth.HTTPDigestAuth('user', 'pass')\n\n    def digest_failed_response_handler(sock):\n        # Respond to initial GET with a challenge.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert request_content.startswith(b\"GET / HTTP/1.1\")\n        sock.send(text_401)\n\n        # Verify we receive an Authorization header in response, then\n        # challenge again.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert expected_digest in request_content\n        sock.send(text_401)\n\n        # Verify the client didn't respond to second challenge.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert request_content == b''\n\n        return request_content\n\n    close_server = threading.Event()\n    server = Server(digest_failed_response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/'\n        r = requests.get(url, auth=auth)\n        # Verify server didn't authenticate us.\n        assert r.status_code == 401\n        assert r.history[0].status_code == 401\n        close_server.set()\n\n\ndef test_digestauth_only_on_4xx():\n    \"\"\"Ensure we only send digestauth on 4xx challenges.\n\n    See https://github.com/psf/requests/issues/3772.\n    \"\"\"\n    text_200_chal = (b'HTTP/1.1 200 OK\\r\\n'\n                     b'Content-Length: 0\\r\\n'\n                     b'WWW-Authenticate: Digest nonce=\"6bf5d6e4da1ce66918800195d6b9130d\"'\n                     b', opaque=\"372825293d1c26955496c80ed6426e9e\", '\n                     b'realm=\"me@kennethreitz.com\", qop=auth\\r\\n\\r\\n')\n\n    auth = requests.auth.HTTPDigestAuth('user', 'pass')\n\n    def digest_response_handler(sock):\n        # Respond to GET with a 200 containing www-authenticate header.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert request_content.startswith(b\"GET / HTTP/1.1\")\n        sock.send(text_200_chal)\n\n        # Verify the client didn't respond with auth.\n        request_content = consume_socket_content(sock, timeout=0.5)\n        assert request_content == b''\n\n        return request_content\n\n    close_server = threading.Event()\n    server = Server(digest_response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/'\n        r = requests.get(url, auth=auth)\n        # Verify server didn't receive auth from us.\n        assert r.status_code == 200\n        assert len(r.history) == 0\n        close_server.set()\n\n\n_schemes_by_var_prefix = [\n    ('http', ['http']),\n    ('https', ['https']),\n    ('all', ['http', 'https']),\n]\n\n_proxy_combos = []\nfor prefix, schemes in _schemes_by_var_prefix:\n    for scheme in schemes:\n        _proxy_combos.append((f\"{prefix}_proxy\", scheme))\n\n_proxy_combos += [(var.upper(), scheme) for var, scheme in _proxy_combos]\n\n\n@pytest.mark.parametrize(\"var,scheme\", _proxy_combos)\ndef test_use_proxy_from_environment(httpbin, var, scheme):\n    url = f\"{scheme}://httpbin.org\"\n    fake_proxy = Server()  # do nothing with the requests; just close the socket\n    with fake_proxy as (host, port):\n        proxy_url = f\"socks5://{host}:{port}\"\n        kwargs = {var: proxy_url}\n        with override_environ(**kwargs):\n            # fake proxy's lack of response will cause a ConnectionError\n            with pytest.raises(requests.exceptions.ConnectionError):\n                requests.get(url)\n\n        # the fake proxy received a request\n        assert len(fake_proxy.handler_results) == 1\n\n        # it had actual content (not checking for SOCKS protocol for now)\n        assert len(fake_proxy.handler_results[0]) > 0\n\n\ndef test_redirect_rfc1808_to_non_ascii_location():\n    path = 'š'\n    expected_path = b'%C5%A1'\n    redirect_request = []  # stores the second request to the server\n\n    def redirect_resp_handler(sock):\n        consume_socket_content(sock, timeout=0.5)\n        location = f'//{host}:{port}/{path}'\n        sock.send(\n            (\n                b'HTTP/1.1 301 Moved Permanently\\r\\n'\n                b'Content-Length: 0\\r\\n'\n                b'Location: %s\\r\\n'\n                b'\\r\\n'\n            ) % location.encode('utf8')\n        )\n        redirect_request.append(consume_socket_content(sock, timeout=0.5))\n        sock.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n')\n\n    close_server = threading.Event()\n    server = Server(redirect_resp_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}'\n        r = requests.get(url=url, allow_redirects=True)\n        assert r.status_code == 200\n        assert len(r.history) == 1\n        assert r.history[0].status_code == 301\n        assert redirect_request[0].startswith(b'GET /' + expected_path + b' HTTP/1.1')\n        assert r.url == '{}/{}'.format(url, expected_path.decode('ascii'))\n\n        close_server.set()\n\n\ndef test_fragment_not_sent_with_request():\n    \"\"\"Verify that the fragment portion of a URI isn't sent to the server.\"\"\"\n    close_server = threading.Event()\n    server = Server(echo_response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/path/to/thing/#view=edit&token=hunter2'\n        r = requests.get(url)\n        raw_request = r.content\n\n        assert r.status_code == 200\n        headers, body = raw_request.split(b'\\r\\n\\r\\n', 1)\n        status_line, headers = headers.split(b'\\r\\n', 1)\n\n        assert status_line == b'GET /path/to/thing/ HTTP/1.1'\n        for frag in (b'view', b'edit', b'token', b'hunter2'):\n            assert frag not in headers\n            assert frag not in body\n\n        close_server.set()\n\n\ndef test_fragment_update_on_redirect():\n    \"\"\"Verify we only append previous fragment if one doesn't exist on new\n    location. If a new fragment is encountered in a Location header, it should\n    be added to all subsequent requests.\n    \"\"\"\n\n    def response_handler(sock):\n        consume_socket_content(sock, timeout=0.5)\n        sock.send(\n            b'HTTP/1.1 302 FOUND\\r\\n'\n            b'Content-Length: 0\\r\\n'\n            b'Location: /get#relevant-section\\r\\n\\r\\n'\n        )\n        consume_socket_content(sock, timeout=0.5)\n        sock.send(\n            b'HTTP/1.1 302 FOUND\\r\\n'\n            b'Content-Length: 0\\r\\n'\n            b'Location: /final-url/\\r\\n\\r\\n'\n        )\n        consume_socket_content(sock, timeout=0.5)\n        sock.send(\n            b'HTTP/1.1 200 OK\\r\\n\\r\\n'\n        )\n\n    close_server = threading.Event()\n    server = Server(response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/path/to/thing/#view=edit&token=hunter2'\n        r = requests.get(url)\n\n        assert r.status_code == 200\n        assert len(r.history) == 2\n        assert r.history[0].request.url == url\n\n        # Verify we haven't overwritten the location with our previous fragment.\n        assert r.history[1].request.url == f'http://{host}:{port}/get#relevant-section'\n        # Verify previous fragment is used and not the original.\n        assert r.url == f'http://{host}:{port}/final-url/#relevant-section'\n\n        close_server.set()\n\n\ndef test_json_decode_compatibility_for_alt_utf_encodings():\n\n    def response_handler(sock):\n        consume_socket_content(sock, timeout=0.5)\n        sock.send(\n            b'HTTP/1.1 200 OK\\r\\n'\n            b'Content-Length: 18\\r\\n\\r\\n'\n            b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n        )\n\n    close_server = threading.Event()\n    server = Server(response_handler, wait_to_close_event=close_server)\n\n    with server as (host, port):\n        url = f'http://{host}:{port}/'\n        r = requests.get(url)\n    r.encoding = None\n    with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n        r.json()\n    assert isinstance(excinfo.value, requests.exceptions.RequestException)\n    assert isinstance(excinfo.value, JSONDecodeError)\n    assert r.text not in str(excinfo.value)\n",
    "tests/test_packages.py": "import requests\n\n\ndef test_can_access_urllib3_attribute():\n    requests.packages.urllib3\n\n\ndef test_can_access_idna_attribute():\n    requests.packages.idna\n\n\ndef test_can_access_chardet_attribute():\n    requests.packages.chardet\n",
    "tests/test_requests.py": "\"\"\"Tests for Requests.\"\"\"\n\nimport collections\nimport contextlib\nimport io\nimport json\nimport os\nimport pickle\nimport re\nimport threading\nimport warnings\nfrom unittest import mock\n\nimport pytest\nimport urllib3\nfrom urllib3.util import Timeout as Urllib3Timeout\n\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom requests.auth import HTTPDigestAuth, _basic_auth_str\nfrom requests.compat import (\n    JSONDecodeError,\n    Morsel,\n    MutableMapping,\n    builtin_str,\n    cookielib,\n    getproxies,\n    is_urllib3_1,\n    urlparse,\n)\nfrom requests.cookies import cookiejar_from_dict, morsel_to_cookie\nfrom requests.exceptions import (\n    ChunkedEncodingError,\n    ConnectionError,\n    ConnectTimeout,\n    ContentDecodingError,\n    InvalidHeader,\n    InvalidProxyURL,\n    InvalidSchema,\n    InvalidURL,\n    MissingSchema,\n    ProxyError,\n    ReadTimeout,\n    RequestException,\n    RetryError,\n)\nfrom requests.exceptions import SSLError as RequestsSSLError\nfrom requests.exceptions import Timeout, TooManyRedirects, UnrewindableBodyError\nfrom requests.hooks import default_hooks\nfrom requests.models import PreparedRequest, urlencode\nfrom requests.sessions import SessionRedirectMixin\nfrom requests.structures import CaseInsensitiveDict\n\nfrom . import SNIMissingWarning\nfrom .compat import StringIO\nfrom .testserver.server import TLSServer, consume_socket_content\nfrom .utils import override_environ\n\n# Requests to this URL should always fail with a connection timeout (nothing\n# listening on that port)\nTARPIT = \"http://10.255.255.1\"\n\n# This is to avoid waiting the timeout of using TARPIT\nINVALID_PROXY = \"http://localhost:1\"\n\ntry:\n    from ssl import SSLContext\n\n    del SSLContext\n    HAS_MODERN_SSL = True\nexcept ImportError:\n    HAS_MODERN_SSL = False\n\ntry:\n    requests.pyopenssl\n    HAS_PYOPENSSL = True\nexcept AttributeError:\n    HAS_PYOPENSSL = False\n\n\nclass TestRequests:\n    digest_auth_algo = (\"MD5\", \"SHA-256\", \"SHA-512\")\n\n    def test_entry_points(self):\n        requests.session\n        requests.session().get\n        requests.session().head\n        requests.get\n        requests.head\n        requests.put\n        requests.patch\n        requests.post\n        # Not really an entry point, but people rely on it.\n        from requests.packages.urllib3.poolmanager import PoolManager  # noqa:F401\n\n    @pytest.mark.parametrize(\n        \"exception, url\",\n        (\n            (MissingSchema, \"hiwpefhipowhefopw\"),\n            (InvalidSchema, \"localhost:3128\"),\n            (InvalidSchema, \"localhost.localdomain:3128/\"),\n            (InvalidSchema, \"10.122.1.1:3128/\"),\n            (InvalidURL, \"http://\"),\n            (InvalidURL, \"http://*example.com\"),\n            (InvalidURL, \"http://.example.com\"),\n        ),\n    )\n    def test_invalid_url(self, exception, url):\n        with pytest.raises(exception):\n            requests.get(url)\n\n    def test_basic_building(self):\n        req = requests.Request()\n        req.url = \"http://kennethreitz.org/\"\n        req.data = {\"life\": \"42\"}\n\n        pr = req.prepare()\n        assert pr.url == req.url\n        assert pr.body == \"life=42\"\n\n    @pytest.mark.parametrize(\"method\", (\"GET\", \"HEAD\"))\n    def test_no_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert \"Content-Length\" not in req.headers\n\n    @pytest.mark.parametrize(\"method\", (\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"))\n    def test_no_body_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower())).prepare()\n        assert req.headers[\"Content-Length\"] == \"0\"\n\n    @pytest.mark.parametrize(\"method\", (\"POST\", \"PUT\", \"PATCH\", \"OPTIONS\"))\n    def test_empty_content_length(self, httpbin, method):\n        req = requests.Request(method, httpbin(method.lower()), data=\"\").prepare()\n        assert req.headers[\"Content-Length\"] == \"0\"\n\n    def test_override_content_length(self, httpbin):\n        headers = {\"Content-Length\": \"not zero\"}\n        r = requests.Request(\"POST\", httpbin(\"post\"), headers=headers).prepare()\n        assert \"Content-Length\" in r.headers\n        assert r.headers[\"Content-Length\"] == \"not zero\"\n\n    def test_path_is_not_double_encoded(self):\n        request = requests.Request(\"GET\", \"http://0.0.0.0/get/test case\").prepare()\n\n        assert request.path_url == \"/get/test%20case\"\n\n    @pytest.mark.parametrize(\n        \"url, expected\",\n        (\n            (\n                \"http://example.com/path#fragment\",\n                \"http://example.com/path?a=b#fragment\",\n            ),\n            (\n                \"http://example.com/path?key=value#fragment\",\n                \"http://example.com/path?key=value&a=b#fragment\",\n            ),\n        ),\n    )\n    def test_params_are_added_before_fragment(self, url, expected):\n        request = requests.Request(\"GET\", url, params={\"a\": \"b\"}).prepare()\n        assert request.url == expected\n\n    def test_params_original_order_is_preserved_by_default(self):\n        param_ordered_dict = collections.OrderedDict(\n            ((\"z\", 1), (\"a\", 1), (\"k\", 1), (\"d\", 1))\n        )\n        session = requests.Session()\n        request = requests.Request(\n            \"GET\", \"http://example.com/\", params=param_ordered_dict\n        )\n        prep = session.prepare_request(request)\n        assert prep.url == \"http://example.com/?z=1&a=1&k=1&d=1\"\n\n    def test_params_bytes_are_encoded(self):\n        request = requests.Request(\n            \"GET\", \"http://example.com\", params=b\"test=foo\"\n        ).prepare()\n        assert request.url == \"http://example.com/?test=foo\"\n\n    def test_binary_put(self):\n        request = requests.Request(\n            \"PUT\", \"http://example.com\", data=\"ööö\".encode()\n        ).prepare()\n        assert isinstance(request.body, bytes)\n\n    def test_whitespaces_are_removed_from_url(self):\n        # Test for issue #3696\n        request = requests.Request(\"GET\", \" http://example.com\").prepare()\n        assert request.url == \"http://example.com/\"\n\n    @pytest.mark.parametrize(\"scheme\", (\"http://\", \"HTTP://\", \"hTTp://\", \"HttP://\"))\n    def test_mixed_case_scheme_acceptable(self, httpbin, scheme):\n        s = requests.Session()\n        s.proxies = getproxies()\n        parts = urlparse(httpbin(\"get\"))\n        url = scheme + parts.netloc + parts.path\n        r = requests.Request(\"GET\", url)\n        r = s.send(r.prepare())\n        assert r.status_code == 200, f\"failed for scheme {scheme}\"\n\n    def test_HTTP_200_OK_GET_ALTERNATIVE(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n\n        assert r.status_code == 200\n\n    def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):\n        r = requests.get(httpbin(\"redirect\", \"1\"))\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n\n    def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):\n        r = requests.post(\n            httpbin(\"redirect-to\"),\n            data=\"test\",\n            params={\"url\": \"post\", \"status_code\": 307},\n        )\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n        assert r.json()[\"data\"] == \"test\"\n\n    def test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE(self, httpbin):\n        byte_str = b\"test\"\n        r = requests.post(\n            httpbin(\"redirect-to\"),\n            data=io.BytesIO(byte_str),\n            params={\"url\": \"post\", \"status_code\": 307},\n        )\n        assert r.status_code == 200\n        assert r.history[0].status_code == 307\n        assert r.history[0].is_redirect\n        assert r.json()[\"data\"] == byte_str.decode(\"utf-8\")\n\n    def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):\n        try:\n            requests.get(httpbin(\"relative-redirect\", \"50\"))\n        except TooManyRedirects as e:\n            url = httpbin(\"relative-redirect\", \"20\")\n            assert e.request.url == url\n            assert e.response.url == url\n            assert len(e.response.history) == 30\n        else:\n            pytest.fail(\"Expected redirect to raise TooManyRedirects but it did not\")\n\n    def test_HTTP_302_TOO_MANY_REDIRECTS_WITH_PARAMS(self, httpbin):\n        s = requests.session()\n        s.max_redirects = 5\n        try:\n            s.get(httpbin(\"relative-redirect\", \"50\"))\n        except TooManyRedirects as e:\n            url = httpbin(\"relative-redirect\", \"45\")\n            assert e.request.url == url\n            assert e.response.url == url\n            assert len(e.response.history) == 5\n        else:\n            pytest.fail(\n                \"Expected custom max number of redirects to be respected but was not\"\n            )\n\n    def test_http_301_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"301\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 301\n        assert r.history[0].is_redirect\n\n    def test_http_301_doesnt_change_head_to_get(self, httpbin):\n        r = requests.head(httpbin(\"status\", \"301\"), allow_redirects=True)\n        print(r.content)\n        assert r.status_code == 200\n        assert r.request.method == \"HEAD\"\n        assert r.history[0].status_code == 301\n        assert r.history[0].is_redirect\n\n    def test_http_302_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"302\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n\n    def test_http_302_doesnt_change_head_to_get(self, httpbin):\n        r = requests.head(httpbin(\"status\", \"302\"), allow_redirects=True)\n        assert r.status_code == 200\n        assert r.request.method == \"HEAD\"\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n\n    def test_http_303_changes_post_to_get(self, httpbin):\n        r = requests.post(httpbin(\"status\", \"303\"))\n        assert r.status_code == 200\n        assert r.request.method == \"GET\"\n        assert r.history[0].status_code == 303\n        assert r.history[0].is_redirect\n\n    def test_http_303_doesnt_change_head_to_get(self, httpbin):\n        r = requests.head(httpbin(\"status\", \"303\"), allow_redirects=True)\n        assert r.status_code == 200\n        assert r.request.method == \"HEAD\"\n        assert r.history[0].status_code == 303\n        assert r.history[0].is_redirect\n\n    def test_header_and_body_removal_on_redirect(self, httpbin):\n        purged_headers = (\"Content-Length\", \"Content-Type\")\n        ses = requests.Session()\n        req = requests.Request(\"POST\", httpbin(\"post\"), data={\"test\": \"data\"})\n        prep = ses.prepare_request(req)\n        resp = ses.send(prep)\n\n        # Mimic a redirect response\n        resp.status_code = 302\n        resp.headers[\"location\"] = \"get\"\n\n        # Run request through resolve_redirects\n        next_resp = next(ses.resolve_redirects(resp, prep))\n        assert next_resp.request.body is None\n        for header in purged_headers:\n            assert header not in next_resp.request.headers\n\n    def test_transfer_enc_removal_on_redirect(self, httpbin):\n        purged_headers = (\"Transfer-Encoding\", \"Content-Type\")\n        ses = requests.Session()\n        req = requests.Request(\"POST\", httpbin(\"post\"), data=(b\"x\" for x in range(1)))\n        prep = ses.prepare_request(req)\n        assert \"Transfer-Encoding\" in prep.headers\n\n        # Create Response to avoid https://github.com/kevin1024/pytest-httpbin/issues/33\n        resp = requests.Response()\n        resp.raw = io.BytesIO(b\"the content\")\n        resp.request = prep\n        setattr(resp.raw, \"release_conn\", lambda *args: args)\n\n        # Mimic a redirect response\n        resp.status_code = 302\n        resp.headers[\"location\"] = httpbin(\"get\")\n\n        # Run request through resolve_redirect\n        next_resp = next(ses.resolve_redirects(resp, prep))\n        assert next_resp.request.body is None\n        for header in purged_headers:\n            assert header not in next_resp.request.headers\n\n    def test_fragment_maintained_on_redirect(self, httpbin):\n        fragment = \"#view=edit&token=hunter2\"\n        r = requests.get(httpbin(\"redirect-to?url=get\") + fragment)\n\n        assert len(r.history) > 0\n        assert r.history[0].request.url == httpbin(\"redirect-to?url=get\") + fragment\n        assert r.url == httpbin(\"get\") + fragment\n\n    def test_HTTP_200_OK_GET_WITH_PARAMS(self, httpbin):\n        heads = {\"User-agent\": \"Mozilla/5.0\"}\n\n        r = requests.get(httpbin(\"user-agent\"), headers=heads)\n\n        assert heads[\"User-agent\"] in r.text\n        assert r.status_code == 200\n\n    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self, httpbin):\n        heads = {\"User-agent\": \"Mozilla/5.0\"}\n\n        r = requests.get(\n            httpbin(\"get\") + \"?test=true\", params={\"q\": \"test\"}, headers=heads\n        )\n        assert r.status_code == 200\n\n    def test_set_cookie_on_301(self, httpbin):\n        s = requests.session()\n        url = httpbin(\"cookies/set?foo=bar\")\n        s.get(url)\n        assert s.cookies[\"foo\"] == \"bar\"\n\n    def test_cookie_sent_on_redirect(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies/set?foo=bar\"))\n        r = s.get(httpbin(\"redirect/1\"))  # redirects to httpbin('get')\n        assert \"Cookie\" in r.json()[\"headers\"]\n\n    def test_cookie_removed_on_expire(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies/set?foo=bar\"))\n        assert s.cookies[\"foo\"] == \"bar\"\n        s.get(\n            httpbin(\"response-headers\"),\n            params={\"Set-Cookie\": \"foo=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT\"},\n        )\n        assert \"foo\" not in s.cookies\n\n    def test_cookie_quote_wrapped(self, httpbin):\n        s = requests.session()\n        s.get(httpbin('cookies/set?foo=\"bar:baz\"'))\n        assert s.cookies[\"foo\"] == '\"bar:baz\"'\n\n    def test_cookie_persists_via_api(self, httpbin):\n        s = requests.session()\n        r = s.get(httpbin(\"redirect/1\"), cookies={\"foo\": \"bar\"})\n        assert \"foo\" in r.request.headers[\"Cookie\"]\n        assert \"foo\" in r.history[0].request.headers[\"Cookie\"]\n\n    def test_request_cookie_overrides_session_cookie(self, httpbin):\n        s = requests.session()\n        s.cookies[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        assert r.json()[\"cookies\"][\"foo\"] == \"baz\"\n        # Session cookie should not be modified\n        assert s.cookies[\"foo\"] == \"bar\"\n\n    def test_request_cookies_not_persisted(self, httpbin):\n        s = requests.session()\n        s.get(httpbin(\"cookies\"), cookies={\"foo\": \"baz\"})\n        # Sending a request with cookies should not add cookies to the session\n        assert not s.cookies\n\n    def test_generic_cookiejar_works(self, httpbin):\n        cj = cookielib.CookieJar()\n        cookiejar_from_dict({\"foo\": \"bar\"}, cj)\n        s = requests.session()\n        s.cookies = cj\n        r = s.get(httpbin(\"cookies\"))\n        # Make sure the cookie was sent\n        assert r.json()[\"cookies\"][\"foo\"] == \"bar\"\n        # Make sure the session cj is still the custom one\n        assert s.cookies is cj\n\n    def test_param_cookiejar_works(self, httpbin):\n        cj = cookielib.CookieJar()\n        cookiejar_from_dict({\"foo\": \"bar\"}, cj)\n        s = requests.session()\n        r = s.get(httpbin(\"cookies\"), cookies=cj)\n        # Make sure the cookie was sent\n        assert r.json()[\"cookies\"][\"foo\"] == \"bar\"\n\n    def test_cookielib_cookiejar_on_redirect(self, httpbin):\n        \"\"\"Tests resolve_redirect doesn't fail when merging cookies\n        with non-RequestsCookieJar cookiejar.\n\n        See GH #3579\n        \"\"\"\n        cj = cookiejar_from_dict({\"foo\": \"bar\"}, cookielib.CookieJar())\n        s = requests.Session()\n        s.cookies = cookiejar_from_dict({\"cookie\": \"tasty\"})\n\n        # Prepare request without using Session\n        req = requests.Request(\"GET\", httpbin(\"headers\"), cookies=cj)\n        prep_req = req.prepare()\n\n        # Send request and simulate redirect\n        resp = s.send(prep_req)\n        resp.status_code = 302\n        resp.headers[\"location\"] = httpbin(\"get\")\n        redirects = s.resolve_redirects(resp, prep_req)\n        resp = next(redirects)\n\n        # Verify CookieJar isn't being converted to RequestsCookieJar\n        assert isinstance(prep_req._cookies, cookielib.CookieJar)\n        assert isinstance(resp.request._cookies, cookielib.CookieJar)\n        assert not isinstance(resp.request._cookies, requests.cookies.RequestsCookieJar)\n\n        cookies = {}\n        for c in resp.request._cookies:\n            cookies[c.name] = c.value\n        assert cookies[\"foo\"] == \"bar\"\n        assert cookies[\"cookie\"] == \"tasty\"\n\n    def test_requests_in_history_are_not_overridden(self, httpbin):\n        resp = requests.get(httpbin(\"redirect/3\"))\n        urls = [r.url for r in resp.history]\n        req_urls = [r.request.url for r in resp.history]\n        assert urls == req_urls\n\n    def test_history_is_always_a_list(self, httpbin):\n        \"\"\"Show that even with redirects, Response.history is always a list.\"\"\"\n        resp = requests.get(httpbin(\"get\"))\n        assert isinstance(resp.history, list)\n        resp = requests.get(httpbin(\"redirect/1\"))\n        assert isinstance(resp.history, list)\n        assert not isinstance(resp.history, tuple)\n\n    def test_headers_on_session_with_None_are_not_sent(self, httpbin):\n        \"\"\"Do not send headers in Session.headers with None values.\"\"\"\n        ses = requests.Session()\n        ses.headers[\"Accept-Encoding\"] = None\n        req = requests.Request(\"GET\", httpbin(\"get\"))\n        prep = ses.prepare_request(req)\n        assert \"Accept-Encoding\" not in prep.headers\n\n    def test_headers_preserve_order(self, httpbin):\n        \"\"\"Preserve order when headers provided as OrderedDict.\"\"\"\n        ses = requests.Session()\n        ses.headers = collections.OrderedDict()\n        ses.headers[\"Accept-Encoding\"] = \"identity\"\n        ses.headers[\"First\"] = \"1\"\n        ses.headers[\"Second\"] = \"2\"\n        headers = collections.OrderedDict([(\"Third\", \"3\"), (\"Fourth\", \"4\")])\n        headers[\"Fifth\"] = \"5\"\n        headers[\"Second\"] = \"222\"\n        req = requests.Request(\"GET\", httpbin(\"get\"), headers=headers)\n        prep = ses.prepare_request(req)\n        items = list(prep.headers.items())\n        assert items[0] == (\"Accept-Encoding\", \"identity\")\n        assert items[1] == (\"First\", \"1\")\n        assert items[2] == (\"Second\", \"222\")\n        assert items[3] == (\"Third\", \"3\")\n        assert items[4] == (\"Fourth\", \"4\")\n        assert items[5] == (\"Fifth\", \"5\")\n\n    @pytest.mark.parametrize(\"key\", (\"User-agent\", \"user-agent\"))\n    def test_user_agent_transfers(self, httpbin, key):\n        heads = {key: \"Mozilla/5.0 (github.com/psf/requests)\"}\n\n        r = requests.get(httpbin(\"user-agent\"), headers=heads)\n        assert heads[key] in r.text\n\n    def test_HTTP_200_OK_HEAD(self, httpbin):\n        r = requests.head(httpbin(\"get\"))\n        assert r.status_code == 200\n\n    def test_HTTP_200_OK_PUT(self, httpbin):\n        r = requests.put(httpbin(\"put\"))\n        assert r.status_code == 200\n\n    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self, httpbin):\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        r = requests.get(url, auth=auth)\n        assert r.status_code == 200\n\n        r = requests.get(url)\n        assert r.status_code == 401\n\n        s = requests.session()\n        s.auth = auth\n        r = s.get(url)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        \"username, password\",\n        (\n            (\"user\", \"pass\"),\n            (\"имя\".encode(), \"пароль\".encode()),\n            (42, 42),\n            (None, None),\n        ),\n    )\n    def test_set_basicauth(self, httpbin, username, password):\n        auth = (username, password)\n        url = httpbin(\"get\")\n\n        r = requests.Request(\"GET\", url, auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)\n\n    def test_basicauth_encodes_byte_strings(self):\n        \"\"\"Ensure b'test' formats as the byte string \"test\" rather\n        than the unicode string \"b'test'\" in Python 3.\n        \"\"\"\n        auth = (b\"\\xc5\\xafsername\", b\"test\\xc6\\xb6\")\n        r = requests.Request(\"GET\", \"http://localhost\", auth=auth)\n        p = r.prepare()\n\n        assert p.headers[\"Authorization\"] == \"Basic xa9zZXJuYW1lOnRlc3TGtg==\"\n\n    @pytest.mark.parametrize(\n        \"url, exception\",\n        (\n            # Connecting to an unknown domain should raise a ConnectionError\n            (\"http://doesnotexist.google.com\", ConnectionError),\n            # Connecting to an invalid port should raise a ConnectionError\n            (\"http://localhost:1\", ConnectionError),\n            # Inputing a URL that cannot be parsed should raise an InvalidURL error\n            (\"http://fe80::5054:ff:fe5a:fc0\", InvalidURL),\n        ),\n    )\n    def test_errors(self, url, exception):\n        with pytest.raises(exception):\n            requests.get(url, timeout=1)\n\n    def test_proxy_error(self):\n        # any proxy related error (address resolution, no route to host, etc) should result in a ProxyError\n        with pytest.raises(ProxyError):\n            requests.get(\n                \"http://localhost:1\", proxies={\"http\": \"non-resolvable-address\"}\n            )\n\n    def test_proxy_error_on_bad_url(self, httpbin, httpbin_secure):\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={\"https\": \"http:/badproxyurl:3128\"})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={\"http\": \"http://:8080\"})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin_secure(), proxies={\"https\": \"https://\"})\n\n        with pytest.raises(InvalidProxyURL):\n            requests.get(httpbin(), proxies={\"http\": \"http:///example.com:8080\"})\n\n    def test_respect_proxy_env_on_send_self_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request(\"GET\", httpbin())\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_send_session_prepared_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                request = requests.Request(\"GET\", httpbin())\n                prepared = session.prepare_request(request)\n                session.send(prepared)\n\n    def test_respect_proxy_env_on_send_with_redirects(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                url = httpbin(\"redirect/1\")\n                print(url)\n                request = requests.Request(\"GET\", url)\n                session.send(request.prepare())\n\n    def test_respect_proxy_env_on_get(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.get(httpbin())\n\n    def test_respect_proxy_env_on_request(self, httpbin):\n        with override_environ(http_proxy=INVALID_PROXY):\n            with pytest.raises(ProxyError):\n                session = requests.Session()\n                session.request(method=\"GET\", url=httpbin())\n\n    def test_proxy_authorization_preserved_on_request(self, httpbin):\n        proxy_auth_value = \"Bearer XXX\"\n        session = requests.Session()\n        session.headers.update({\"Proxy-Authorization\": proxy_auth_value})\n        resp = session.request(method=\"GET\", url=httpbin(\"get\"))\n        sent_headers = resp.json().get(\"headers\", {})\n\n        assert sent_headers.get(\"Proxy-Authorization\") == proxy_auth_value\n\n    @pytest.mark.parametrize(\n        \"url,has_proxy_auth\",\n        (\n            (\"http://example.com\", True),\n            (\"https://example.com\", False),\n        ),\n    )\n    def test_proxy_authorization_not_appended_to_https_request(\n        self, url, has_proxy_auth\n    ):\n        session = requests.Session()\n        proxies = {\n            \"http\": \"http://test:pass@localhost:8080\",\n            \"https\": \"http://test:pass@localhost:8090\",\n        }\n        req = requests.Request(\"GET\", url)\n        prep = req.prepare()\n        session.rebuild_proxies(prep, proxies)\n\n        assert (\"Proxy-Authorization\" in prep.headers) is has_proxy_auth\n\n    def test_basicauth_with_netrc(self, httpbin):\n        auth = (\"user\", \"pass\")\n        wrong_auth = (\"wronguser\", \"wrongpass\")\n        url = httpbin(\"basic-auth\", \"user\", \"pass\")\n\n        old_auth = requests.sessions.get_netrc_auth\n\n        try:\n\n            def get_netrc_auth_mock(url):\n                return auth\n\n            requests.sessions.get_netrc_auth = get_netrc_auth_mock\n\n            # Should use netrc and work.\n            r = requests.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            r = requests.get(url, auth=wrong_auth)\n            assert r.status_code == 401\n\n            s = requests.session()\n\n            # Should use netrc and work.\n            r = s.get(url)\n            assert r.status_code == 200\n\n            # Given auth should override and fail.\n            s.auth = wrong_auth\n            r = s.get(url)\n            assert r.status_code == 401\n        finally:\n            requests.sessions.get_netrc_auth = old_auth\n\n    def test_DIGEST_HTTP_200_OK_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n            r = requests.get(url)\n            assert r.status_code == 401\n            print(r.headers[\"WWW-Authenticate\"])\n\n            s = requests.session()\n            s.auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = s.get(url)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            r = requests.get(url)\n            assert r.cookies[\"fake\"] == \"fake_value\"\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 200\n\n    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            s = requests.Session()\n            s.get(url, auth=auth)\n            assert s.cookies[\"fake\"] == \"fake_value\"\n\n    def test_DIGEST_STREAM(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth, stream=True)\n            assert r.raw.read() != b\"\"\n\n            r = requests.get(url, auth=auth, stream=False)\n            assert r.raw.read() == b\"\"\n\n    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"wrongpass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth)\n            assert r.status_code == 401\n\n            r = requests.get(url)\n            assert r.status_code == 401\n\n            s = requests.session()\n            s.auth = auth\n            r = s.get(url)\n            assert r.status_code == 401\n\n    def test_DIGESTAUTH_QUOTES_QOP_VALUE(self, httpbin):\n        for authtype in self.digest_auth_algo:\n            auth = HTTPDigestAuth(\"user\", \"pass\")\n            url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)\n\n            r = requests.get(url, auth=auth)\n            assert '\"auth\"' in r.request.headers[\"Authorization\"]\n\n    def test_POSTBIN_GET_POST_FILES(self, httpbin):\n        url = httpbin(\"post\")\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={\"some\": \"data\"})\n        assert post1.status_code == 200\n\n        with open(\"requirements-dev.txt\") as f:\n            post2 = requests.post(url, files={\"some\": f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=[\"bad file data\"])\n\n    def test_invalid_files_input(self, httpbin):\n        url = httpbin(\"post\")\n        post = requests.post(url, files={\"random-file-1\": None, \"random-file-2\": 1})\n        assert b'name=\"random-file-1\"' not in post.request.body\n        assert b'name=\"random-file-2\"' in post.request.body\n\n    def test_POSTBIN_SEEKED_OBJECT_WITH_NO_ITER(self, httpbin):\n        class TestStream:\n            def __init__(self, data):\n                self.data = data.encode()\n                self.length = len(self.data)\n                self.index = 0\n\n            def __len__(self):\n                return self.length\n\n            def read(self, size=None):\n                if size:\n                    ret = self.data[self.index : self.index + size]\n                    self.index += size\n                else:\n                    ret = self.data[self.index :]\n                    self.index = self.length\n                return ret\n\n            def tell(self):\n                return self.index\n\n            def seek(self, offset, where=0):\n                if where == 0:\n                    self.index = offset\n                elif where == 1:\n                    self.index += offset\n                elif where == 2:\n                    self.index = self.length + offset\n\n        test = TestStream(\"test\")\n        post1 = requests.post(httpbin(\"post\"), data=test)\n        assert post1.status_code == 200\n        assert post1.json()[\"data\"] == \"test\"\n\n        test = TestStream(\"test\")\n        test.seek(2)\n        post2 = requests.post(httpbin(\"post\"), data=test)\n        assert post2.status_code == 200\n        assert post2.json()[\"data\"] == \"st\"\n\n    def test_POSTBIN_GET_POST_FILES_WITH_DATA(self, httpbin):\n        url = httpbin(\"post\")\n        requests.post(url).raise_for_status()\n\n        post1 = requests.post(url, data={\"some\": \"data\"})\n        assert post1.status_code == 200\n\n        with open(\"requirements-dev.txt\") as f:\n            post2 = requests.post(url, data={\"some\": \"data\"}, files={\"some\": f})\n        assert post2.status_code == 200\n\n        post4 = requests.post(url, data='[{\"some\": \"json\"}]')\n        assert post4.status_code == 200\n\n        with pytest.raises(ValueError):\n            requests.post(url, files=[\"bad file data\"])\n\n    def test_post_with_custom_mapping(self, httpbin):\n        class CustomMapping(MutableMapping):\n            def __init__(self, *args, **kwargs):\n                self.data = dict(*args, **kwargs)\n\n            def __delitem__(self, key):\n                del self.data[key]\n\n            def __getitem__(self, key):\n                return self.data[key]\n\n            def __setitem__(self, key, value):\n                self.data[key] = value\n\n            def __iter__(self):\n                return iter(self.data)\n\n            def __len__(self):\n                return len(self.data)\n\n        data = CustomMapping({\"some\": \"data\"})\n        url = httpbin(\"post\")\n        found_json = requests.post(url, data=data).json().get(\"form\")\n        assert found_json == {\"some\": \"data\"}\n\n    def test_conflicting_post_params(self, httpbin):\n        url = httpbin(\"post\")\n        with open(\"requirements-dev.txt\") as f:\n            with pytest.raises(ValueError):\n                requests.post(url, data='[{\"some\": \"data\"}]', files={\"some\": f})\n\n    def test_request_ok_set(self, httpbin):\n        r = requests.get(httpbin(\"status\", \"404\"))\n        assert not r.ok\n\n    def test_status_raising(self, httpbin):\n        r = requests.get(httpbin(\"status\", \"404\"))\n        with pytest.raises(requests.exceptions.HTTPError):\n            r.raise_for_status()\n\n        r = requests.get(httpbin(\"status\", \"500\"))\n        assert not r.ok\n\n    def test_decompress_gzip(self, httpbin):\n        r = requests.get(httpbin(\"gzip\"))\n        r.content.decode(\"ascii\")\n\n    @pytest.mark.parametrize(\n        \"url, params\",\n        (\n            (\"/get\", {\"foo\": \"føø\"}),\n            (\"/get\", {\"føø\": \"føø\"}),\n            (\"/get\", {\"føø\": \"føø\"}),\n            (\"/get\", {\"foo\": \"foo\"}),\n            (\"ø\", {\"foo\": \"foo\"}),\n        ),\n    )\n    def test_unicode_get(self, httpbin, url, params):\n        requests.get(httpbin(url), params=params)\n\n    def test_unicode_header_name(self, httpbin):\n        requests.put(\n            httpbin(\"put\"),\n            headers={\"Content-Type\": \"application/octet-stream\"},\n            data=\"\\xff\",\n        )  # compat.str is unicode.\n\n    def test_pyopenssl_redirect(self, httpbin_secure, httpbin_ca_bundle):\n        requests.get(httpbin_secure(\"status\", \"301\"), verify=httpbin_ca_bundle)\n\n    def test_invalid_ca_certificate_path(self, httpbin_secure):\n        INVALID_PATH = \"/garbage\"\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), verify=INVALID_PATH)\n        assert str(\n            e.value\n        ) == \"Could not find a suitable TLS CA certificate bundle, invalid path: {}\".format(\n            INVALID_PATH\n        )\n\n    def test_invalid_ssl_certificate_files(self, httpbin_secure):\n        INVALID_PATH = \"/garbage\"\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=INVALID_PATH)\n        assert str(\n            e.value\n        ) == \"Could not find the TLS certificate file, invalid path: {}\".format(\n            INVALID_PATH\n        )\n\n        with pytest.raises(IOError) as e:\n            requests.get(httpbin_secure(), cert=(\".\", INVALID_PATH))\n        assert str(e.value) == (\n            f\"Could not find the TLS key file, invalid path: {INVALID_PATH}\"\n        )\n\n    @pytest.mark.parametrize(\n        \"env, expected\",\n        (\n            ({}, True),\n            ({\"REQUESTS_CA_BUNDLE\": \"/some/path\"}, \"/some/path\"),\n            ({\"REQUESTS_CA_BUNDLE\": \"\"}, True),\n            ({\"CURL_CA_BUNDLE\": \"/some/path\"}, \"/some/path\"),\n            ({\"CURL_CA_BUNDLE\": \"\"}, True),\n            ({\"REQUESTS_CA_BUNDLE\": \"\", \"CURL_CA_BUNDLE\": \"\"}, True),\n            (\n                {\n                    \"REQUESTS_CA_BUNDLE\": \"/some/path\",\n                    \"CURL_CA_BUNDLE\": \"/curl/path\",\n                },\n                \"/some/path\",\n            ),\n            (\n                {\n                    \"REQUESTS_CA_BUNDLE\": \"\",\n                    \"CURL_CA_BUNDLE\": \"/curl/path\",\n                },\n                \"/curl/path\",\n            ),\n        ),\n    )\n    def test_env_cert_bundles(self, httpbin, env, expected):\n        s = requests.Session()\n        with mock.patch(\"os.environ\", env):\n            settings = s.merge_environment_settings(\n                url=httpbin(\"get\"), proxies={}, stream=False, verify=True, cert=None\n            )\n        assert settings[\"verify\"] == expected\n\n    def test_http_with_certificate(self, httpbin):\n        r = requests.get(httpbin(), cert=\".\")\n        assert r.status_code == 200\n\n    @pytest.mark.skipif(\n        SNIMissingWarning is None,\n        reason=\"urllib3 2.0 removed that warning and errors out instead\",\n    )\n    def test_https_warnings(self, nosan_server):\n        \"\"\"warnings are emitted with requests.get\"\"\"\n        host, port, ca_bundle = nosan_server\n        if HAS_MODERN_SSL or HAS_PYOPENSSL:\n            warnings_expected = (\"SubjectAltNameWarning\",)\n        else:\n            warnings_expected = (\n                \"SNIMissingWarning\",\n                \"InsecurePlatformWarning\",\n                \"SubjectAltNameWarning\",\n            )\n\n        with pytest.warns() as warning_records:\n            warnings.simplefilter(\"always\")\n            requests.get(f\"https://localhost:{port}/\", verify=ca_bundle)\n\n        warning_records = [\n            item\n            for item in warning_records\n            if item.category.__name__ != \"ResourceWarning\"\n        ]\n\n        warnings_category = tuple(item.category.__name__ for item in warning_records)\n        assert warnings_category == warnings_expected\n\n    def test_certificate_failure(self, httpbin_secure):\n        \"\"\"\n        When underlying SSL problems occur, an SSLError is raised.\n        \"\"\"\n        with pytest.raises(RequestsSSLError):\n            # Our local httpbin does not have a trusted CA, so this call will\n            # fail if we use our default trust bundle.\n            requests.get(httpbin_secure(\"status\", \"200\"))\n\n    def test_urlencoded_get_query_multivalued_param(self, httpbin):\n        r = requests.get(httpbin(\"get\"), params={\"test\": [\"foo\", \"baz\"]})\n        assert r.status_code == 200\n        assert r.url == httpbin(\"get?test=foo&test=baz\")\n\n    def test_form_encoded_post_query_multivalued_element(self, httpbin):\n        r = requests.Request(\n            method=\"POST\", url=httpbin(\"post\"), data=dict(test=[\"foo\", \"baz\"])\n        )\n        prep = r.prepare()\n        assert prep.body == \"test=foo&test=baz\"\n\n    def test_different_encodings_dont_break_post(self, httpbin):\n        with open(__file__, \"rb\") as f:\n            r = requests.post(\n                httpbin(\"post\"),\n                data={\"stuff\": json.dumps({\"a\": 123})},\n                params={\"blah\": \"asdf1234\"},\n                files={\"file\": (\"test_requests.py\", f)},\n            )\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        \"data\",\n        (\n            {\"stuff\": \"ëlïxr\"},\n            {\"stuff\": \"ëlïxr\".encode()},\n            {\"stuff\": \"elixr\"},\n            {\"stuff\": b\"elixr\"},\n        ),\n    )\n    def test_unicode_multipart_post(self, httpbin, data):\n        with open(__file__, \"rb\") as f:\n            r = requests.post(\n                httpbin(\"post\"),\n                data=data,\n                files={\"file\": (\"test_requests.py\", f)},\n            )\n        assert r.status_code == 200\n\n    def test_unicode_multipart_post_fieldnames(self, httpbin):\n        filename = os.path.splitext(__file__)[0] + \".py\"\n        with open(filename, \"rb\") as f:\n            r = requests.Request(\n                method=\"POST\",\n                url=httpbin(\"post\"),\n                data={b\"stuff\": \"elixr\"},\n                files={\"file\": (\"test_requests.py\", f)},\n            )\n            prep = r.prepare()\n\n        assert b'name=\"stuff\"' in prep.body\n        assert b\"name=\\\"b'stuff'\\\"\" not in prep.body\n\n    def test_unicode_method_name(self, httpbin):\n        with open(__file__, \"rb\") as f:\n            files = {\"file\": f}\n            r = requests.request(\n                method=\"POST\",\n                url=httpbin(\"post\"),\n                files=files,\n            )\n        assert r.status_code == 200\n\n    def test_unicode_method_name_with_request_object(self, httpbin):\n        s = requests.Session()\n        with open(__file__, \"rb\") as f:\n            files = {\"file\": f}\n            req = requests.Request(\"POST\", httpbin(\"post\"), files=files)\n            prep = s.prepare_request(req)\n        assert isinstance(prep.method, builtin_str)\n        assert prep.method == \"POST\"\n\n        resp = s.send(prep)\n        assert resp.status_code == 200\n\n    def test_non_prepared_request_error(self):\n        s = requests.Session()\n        req = requests.Request(\"POST\", \"/\")\n\n        with pytest.raises(ValueError) as e:\n            s.send(req)\n        assert str(e.value) == \"You can only send PreparedRequests.\"\n\n    def test_custom_content_type(self, httpbin):\n        with open(__file__, \"rb\") as f1:\n            with open(__file__, \"rb\") as f2:\n                data = {\"stuff\": json.dumps({\"a\": 123})}\n                files = {\n                    \"file1\": (\"test_requests.py\", f1),\n                    \"file2\": (\"test_requests\", f2, \"text/py-content-type\"),\n                }\n                r = requests.post(httpbin(\"post\"), data=data, files=files)\n        assert r.status_code == 200\n        assert b\"text/py-content-type\" in r.request.body\n\n    def test_hook_receives_request_arguments(self, httpbin):\n        def hook(resp, **kwargs):\n            assert resp is not None\n            assert kwargs != {}\n\n        s = requests.Session()\n        r = requests.Request(\"GET\", httpbin(), hooks={\"response\": hook})\n        prep = s.prepare_request(r)\n        s.send(prep)\n\n    def test_session_hooks_are_used_with_no_request_hooks(self, httpbin):\n        def hook(*args, **kwargs):\n            pass\n\n        s = requests.Session()\n        s.hooks[\"response\"].append(hook)\n        r = requests.Request(\"GET\", httpbin())\n        prep = s.prepare_request(r)\n        assert prep.hooks[\"response\"] != []\n        assert prep.hooks[\"response\"] == [hook]\n\n    def test_session_hooks_are_overridden_by_request_hooks(self, httpbin):\n        def hook1(*args, **kwargs):\n            pass\n\n        def hook2(*args, **kwargs):\n            pass\n\n        assert hook1 is not hook2\n        s = requests.Session()\n        s.hooks[\"response\"].append(hook2)\n        r = requests.Request(\"GET\", httpbin(), hooks={\"response\": [hook1]})\n        prep = s.prepare_request(r)\n        assert prep.hooks[\"response\"] == [hook1]\n\n    def test_prepared_request_hook(self, httpbin):\n        def hook(resp, **kwargs):\n            resp.hook_working = True\n            return resp\n\n        req = requests.Request(\"GET\", httpbin(), hooks={\"response\": hook})\n        prep = req.prepare()\n\n        s = requests.Session()\n        s.proxies = getproxies()\n        resp = s.send(prep)\n\n        assert hasattr(resp, \"hook_working\")\n\n    def test_prepared_from_session(self, httpbin):\n        class DummyAuth(requests.auth.AuthBase):\n            def __call__(self, r):\n                r.headers[\"Dummy-Auth-Test\"] = \"dummy-auth-test-ok\"\n                return r\n\n        req = requests.Request(\"GET\", httpbin(\"headers\"))\n        assert not req.auth\n\n        s = requests.Session()\n        s.auth = DummyAuth()\n\n        prep = s.prepare_request(req)\n        resp = s.send(prep)\n\n        assert resp.json()[\"headers\"][\"Dummy-Auth-Test\"] == \"dummy-auth-test-ok\"\n\n    def test_prepare_request_with_bytestring_url(self):\n        req = requests.Request(\"GET\", b\"https://httpbin.org/\")\n        s = requests.Session()\n        prep = s.prepare_request(req)\n        assert prep.url == \"https://httpbin.org/\"\n\n    def test_request_with_bytestring_host(self, httpbin):\n        s = requests.Session()\n        resp = s.request(\n            \"GET\",\n            httpbin(\"cookies/set?cookie=value\"),\n            allow_redirects=False,\n            headers={\"Host\": b\"httpbin.org\"},\n        )\n        assert resp.cookies.get(\"cookie\") == \"value\"\n\n    def test_links(self):\n        r = requests.Response()\n        r.headers = {\n            \"cache-control\": \"public, max-age=60, s-maxage=60\",\n            \"connection\": \"keep-alive\",\n            \"content-encoding\": \"gzip\",\n            \"content-type\": \"application/json; charset=utf-8\",\n            \"date\": \"Sat, 26 Jan 2013 16:47:56 GMT\",\n            \"etag\": '\"6ff6a73c0e446c1f61614769e3ceb778\"',\n            \"last-modified\": \"Sat, 26 Jan 2013 16:22:39 GMT\",\n            \"link\": (\n                \"<https://api.github.com/users/kennethreitz/repos?\"\n                'page=2&per_page=10>; rel=\"next\", <https://api.github.'\n                \"com/users/kennethreitz/repos?page=7&per_page=10>; \"\n                ' rel=\"last\"'\n            ),\n            \"server\": \"GitHub.com\",\n            \"status\": \"200 OK\",\n            \"vary\": \"Accept\",\n            \"x-content-type-options\": \"nosniff\",\n            \"x-github-media-type\": \"github.beta\",\n            \"x-ratelimit-limit\": \"60\",\n            \"x-ratelimit-remaining\": \"57\",\n        }\n        assert r.links[\"next\"][\"rel\"] == \"next\"\n\n    def test_cookie_parameters(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n        secure = True\n        domain = \"test.com\"\n        rest = {\"HttpOnly\": True}\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value, secure=secure, domain=domain, rest=rest)\n\n        assert len(jar) == 1\n        assert \"some_cookie\" in jar\n\n        cookie = list(jar)[0]\n        assert cookie.secure == secure\n        assert cookie.domain == domain\n        assert cookie._rest[\"HttpOnly\"] == rest[\"HttpOnly\"]\n\n    def test_cookie_as_dict_keeps_len(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n\n        key1 = \"some_cookie1\"\n        value1 = \"some_value1\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value)\n        jar.set(key1, value1)\n\n        d1 = dict(jar)\n        d2 = dict(jar.iteritems())\n        d3 = dict(jar.items())\n\n        assert len(jar) == 2\n        assert len(d1) == 2\n        assert len(d2) == 2\n        assert len(d3) == 2\n\n    def test_cookie_as_dict_keeps_items(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n\n        key1 = \"some_cookie1\"\n        value1 = \"some_value1\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value)\n        jar.set(key1, value1)\n\n        d1 = dict(jar)\n        d2 = dict(jar.iteritems())\n        d3 = dict(jar.items())\n\n        assert d1[\"some_cookie\"] == \"some_value\"\n        assert d2[\"some_cookie\"] == \"some_value\"\n        assert d3[\"some_cookie1\"] == \"some_value1\"\n\n    def test_cookie_as_dict_keys(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n\n        key1 = \"some_cookie1\"\n        value1 = \"some_value1\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value)\n        jar.set(key1, value1)\n\n        keys = jar.keys()\n        assert keys == list(keys)\n        # make sure one can use keys multiple times\n        assert list(keys) == list(keys)\n\n    def test_cookie_as_dict_values(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n\n        key1 = \"some_cookie1\"\n        value1 = \"some_value1\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value)\n        jar.set(key1, value1)\n\n        values = jar.values()\n        assert values == list(values)\n        # make sure one can use values multiple times\n        assert list(values) == list(values)\n\n    def test_cookie_as_dict_items(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n\n        key1 = \"some_cookie1\"\n        value1 = \"some_value1\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value)\n        jar.set(key1, value1)\n\n        items = jar.items()\n        assert items == list(items)\n        # make sure one can use items multiple times\n        assert list(items) == list(items)\n\n    def test_cookie_duplicate_names_different_domains(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n        domain1 = \"test1.com\"\n        domain2 = \"test2.com\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value, domain=domain1)\n        jar.set(key, value, domain=domain2)\n        assert key in jar\n        items = jar.items()\n        assert len(items) == 2\n\n        # Verify that CookieConflictError is raised if domain is not specified\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n        # Verify that CookieConflictError is not raised if domain is specified\n        cookie = jar.get(key, domain=domain1)\n        assert cookie == value\n\n    def test_cookie_duplicate_names_raises_cookie_conflict_error(self):\n        key = \"some_cookie\"\n        value = \"some_value\"\n        path = \"some_path\"\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set(key, value, path=path)\n        jar.set(key, value)\n        with pytest.raises(requests.cookies.CookieConflictError):\n            jar.get(key)\n\n    def test_cookie_policy_copy(self):\n        class MyCookiePolicy(cookielib.DefaultCookiePolicy):\n            pass\n\n        jar = requests.cookies.RequestsCookieJar()\n        jar.set_policy(MyCookiePolicy())\n        assert isinstance(jar.copy().get_policy(), MyCookiePolicy)\n\n    def test_time_elapsed_blank(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n        td = r.elapsed\n        total_seconds = (\n            td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6\n        ) / 10**6\n        assert total_seconds > 0.0\n\n    def test_empty_response_has_content_none(self):\n        r = requests.Response()\n        assert r.content is None\n\n    def test_response_is_iterable(self):\n        r = requests.Response()\n        io = StringIO.StringIO(\"abc\")\n        read_ = io.read\n\n        def read_mock(amt, decode_content=None):\n            return read_(amt)\n\n        setattr(io, \"read\", read_mock)\n        r.raw = io\n        assert next(iter(r))\n        io.close()\n\n    def test_response_decode_unicode(self):\n        \"\"\"When called with decode_unicode, Response.iter_content should always\n        return unicode.\n        \"\"\"\n        r = requests.Response()\n        r._content_consumed = True\n        r._content = b\"the content\"\n        r.encoding = \"ascii\"\n\n        chunks = r.iter_content(decode_unicode=True)\n        assert all(isinstance(chunk, str) for chunk in chunks)\n\n        # also for streaming\n        r = requests.Response()\n        r.raw = io.BytesIO(b\"the content\")\n        r.encoding = \"ascii\"\n        chunks = r.iter_content(decode_unicode=True)\n        assert all(isinstance(chunk, str) for chunk in chunks)\n\n    def test_response_reason_unicode(self):\n        # check for unicode HTTP status\n        r = requests.Response()\n        r.url = \"unicode URL\"\n        r.reason = \"Komponenttia ei löydy\".encode()\n        r.status_code = 404\n        r.encoding = None\n        assert not r.ok  # old behaviour - crashes here\n\n    def test_response_reason_unicode_fallback(self):\n        # check raise_status falls back to ISO-8859-1\n        r = requests.Response()\n        r.url = \"some url\"\n        reason = \"Komponenttia ei löydy\"\n        r.reason = reason.encode(\"latin-1\")\n        r.status_code = 500\n        r.encoding = None\n        with pytest.raises(requests.exceptions.HTTPError) as e:\n            r.raise_for_status()\n        assert reason in e.value.args[0]\n\n    def test_response_chunk_size_type(self):\n        \"\"\"Ensure that chunk_size is passed as None or an integer, otherwise\n        raise a TypeError.\n        \"\"\"\n        r = requests.Response()\n        r.raw = io.BytesIO(b\"the content\")\n        chunks = r.iter_content(1)\n        assert all(len(chunk) == 1 for chunk in chunks)\n\n        r = requests.Response()\n        r.raw = io.BytesIO(b\"the content\")\n        chunks = r.iter_content(None)\n        assert list(chunks) == [b\"the content\"]\n\n        r = requests.Response()\n        r.raw = io.BytesIO(b\"the content\")\n        with pytest.raises(TypeError):\n            chunks = r.iter_content(\"1024\")\n\n    @pytest.mark.parametrize(\n        \"exception, args, expected\",\n        (\n            (urllib3.exceptions.ProtocolError, tuple(), ChunkedEncodingError),\n            (urllib3.exceptions.DecodeError, tuple(), ContentDecodingError),\n            (urllib3.exceptions.ReadTimeoutError, (None, \"\", \"\"), ConnectionError),\n            (urllib3.exceptions.SSLError, tuple(), RequestsSSLError),\n        ),\n    )\n    def test_iter_content_wraps_exceptions(self, httpbin, exception, args, expected):\n        r = requests.Response()\n        r.raw = mock.Mock()\n        # ReadTimeoutError can't be initialized by mock\n        # so we'll manually create the instance with args\n        r.raw.stream.side_effect = exception(*args)\n\n        with pytest.raises(expected):\n            next(r.iter_content(1024))\n\n    def test_request_and_response_are_pickleable(self, httpbin):\n        r = requests.get(httpbin(\"get\"))\n\n        # verify we can pickle the original request\n        assert pickle.loads(pickle.dumps(r.request))\n\n        # verify we can pickle the response and that we have access to\n        # the original request.\n        pr = pickle.loads(pickle.dumps(r))\n        assert r.request.url == pr.request.url\n        assert r.request.headers == pr.request.headers\n\n    def test_prepared_request_is_pickleable(self, httpbin):\n        p = requests.Request(\"GET\", httpbin(\"get\")).prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n        assert r.url == p.url\n        assert r.headers == p.headers\n        assert r.body == p.body\n\n        # Verify unpickled PreparedRequest sends properly\n        s = requests.Session()\n        resp = s.send(r)\n        assert resp.status_code == 200\n\n    def test_prepared_request_with_file_is_pickleable(self, httpbin):\n        with open(__file__, \"rb\") as f:\n            r = requests.Request(\"POST\", httpbin(\"post\"), files={\"file\": f})\n            p = r.prepare()\n\n        # Verify PreparedRequest can be pickled and unpickled\n        r = pickle.loads(pickle.dumps(p))\n        assert r.url == p.url\n        assert r.headers == p.headers\n        assert r.body == p.body\n\n        # Verify unpickled PreparedRequest sends properly\n        s = requests.Session()\n        resp = s.send(r)\n        assert resp.status_code == 200\n\n    def test_prepared_request_with_hook_is_pickleable(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"), hooks=default_hooks())\n        p = r.prepare()\n\n        # Verify PreparedRequest can be pickled\n        r = pickle.loads(pickle.dumps(p))\n        assert r.url == p.url\n        assert r.headers == p.headers\n        assert r.body == p.body\n        assert r.hooks == p.hooks\n\n        # Verify unpickled PreparedRequest sends properly\n        s = requests.Session()\n        resp = s.send(r)\n        assert resp.status_code == 200\n\n    def test_cannot_send_unprepared_requests(self, httpbin):\n        r = requests.Request(url=httpbin())\n        with pytest.raises(ValueError):\n            requests.Session().send(r)\n\n    def test_http_error(self):\n        error = requests.exceptions.HTTPError()\n        assert not error.response\n        response = requests.Response()\n        error = requests.exceptions.HTTPError(response=response)\n        assert error.response == response\n        error = requests.exceptions.HTTPError(\"message\", response=response)\n        assert str(error) == \"message\"\n        assert error.response == response\n\n    def test_session_pickling(self, httpbin):\n        r = requests.Request(\"GET\", httpbin(\"get\"))\n        s = requests.Session()\n\n        s = pickle.loads(pickle.dumps(s))\n        s.proxies = getproxies()\n\n        r = s.send(r.prepare())\n        assert r.status_code == 200\n\n    def test_fixes_1329(self, httpbin):\n        \"\"\"Ensure that header updates are done case-insensitively.\"\"\"\n        s = requests.Session()\n        s.headers.update({\"ACCEPT\": \"BOGUS\"})\n        s.headers.update({\"accept\": \"application/json\"})\n        r = s.get(httpbin(\"get\"))\n        headers = r.request.headers\n        assert headers[\"accept\"] == \"application/json\"\n        assert headers[\"Accept\"] == \"application/json\"\n        assert headers[\"ACCEPT\"] == \"application/json\"\n\n    def test_uppercase_scheme_redirect(self, httpbin):\n        parts = urlparse(httpbin(\"html\"))\n        url = \"HTTP://\" + parts.netloc + parts.path\n        r = requests.get(httpbin(\"redirect-to\"), params={\"url\": url})\n        assert r.status_code == 200\n        assert r.url.lower() == url.lower()\n\n    def test_transport_adapter_ordering(self):\n        s = requests.Session()\n        order = [\"https://\", \"http://\"]\n        assert order == list(s.adapters)\n        s.mount(\"http://git\", HTTPAdapter())\n        s.mount(\"http://github\", HTTPAdapter())\n        s.mount(\"http://github.com\", HTTPAdapter())\n        s.mount(\"http://github.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://github.com\",\n            \"http://github\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s.mount(\"http://gittip\", HTTPAdapter())\n        s.mount(\"http://gittip.com\", HTTPAdapter())\n        s.mount(\"http://gittip.com/about/\", HTTPAdapter())\n        order = [\n            \"http://github.com/about/\",\n            \"http://gittip.com/about/\",\n            \"http://github.com\",\n            \"http://gittip.com\",\n            \"http://github\",\n            \"http://gittip\",\n            \"http://git\",\n            \"https://\",\n            \"http://\",\n        ]\n        assert order == list(s.adapters)\n        s2 = requests.Session()\n        s2.adapters = {\"http://\": HTTPAdapter()}\n        s2.mount(\"https://\", HTTPAdapter())\n        assert \"http://\" in s2.adapters\n        assert \"https://\" in s2.adapters\n\n    def test_session_get_adapter_prefix_matching(self):\n        prefix = \"https://example.com\"\n        more_specific_prefix = prefix + \"/some/path\"\n\n        url_matching_only_prefix = prefix + \"/another/path\"\n        url_matching_more_specific_prefix = more_specific_prefix + \"/longer/path\"\n        url_not_matching_prefix = \"https://another.example.com/\"\n\n        s = requests.Session()\n        prefix_adapter = HTTPAdapter()\n        more_specific_prefix_adapter = HTTPAdapter()\n        s.mount(prefix, prefix_adapter)\n        s.mount(more_specific_prefix, more_specific_prefix_adapter)\n\n        assert s.get_adapter(url_matching_only_prefix) is prefix_adapter\n        assert (\n            s.get_adapter(url_matching_more_specific_prefix)\n            is more_specific_prefix_adapter\n        )\n        assert s.get_adapter(url_not_matching_prefix) not in (\n            prefix_adapter,\n            more_specific_prefix_adapter,\n        )\n\n    def test_session_get_adapter_prefix_matching_mixed_case(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix = mixed_case_prefix + \"/full_url\"\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix) is my_adapter\n\n    def test_session_get_adapter_prefix_matching_is_case_insensitive(self):\n        mixed_case_prefix = \"hTtPs://eXamPle.CoM/MixEd_CAse_PREfix\"\n        url_matching_prefix_with_different_case = (\n            \"HtTpS://exaMPLe.cOm/MiXeD_caSE_preFIX/another_url\"\n        )\n\n        s = requests.Session()\n        my_adapter = HTTPAdapter()\n        s.mount(mixed_case_prefix, my_adapter)\n\n        assert s.get_adapter(url_matching_prefix_with_different_case) is my_adapter\n\n    def test_header_remove_is_case_insensitive(self, httpbin):\n        # From issue #1321\n        s = requests.Session()\n        s.headers[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"get\"), headers={\"FOO\": None})\n        assert \"foo\" not in r.request.headers\n\n    def test_params_are_merged_case_sensitive(self, httpbin):\n        s = requests.Session()\n        s.params[\"foo\"] = \"bar\"\n        r = s.get(httpbin(\"get\"), params={\"FOO\": \"bar\"})\n        assert r.json()[\"args\"] == {\"foo\": \"bar\", \"FOO\": \"bar\"}\n\n    def test_long_authinfo_in_url(self):\n        url = \"http://{}:{}@{}:9000/path?query#frag\".format(\n            \"E8A3BE87-9E3F-4620-8858-95478E385B5B\",\n            \"EA770032-DA4D-4D84-8CE9-29C6D910BF1E\",\n            \"exactly-------------sixty-----------three------------characters\",\n        )\n        r = requests.Request(\"GET\", url).prepare()\n        assert r.url == url\n\n    def test_header_keys_are_native(self, httpbin):\n        headers = {\"unicode\": \"blah\", b\"byte\": \"blah\"}\n        r = requests.Request(\"GET\", httpbin(\"get\"), headers=headers)\n        p = r.prepare()\n\n        # This is testing that they are builtin strings. A bit weird, but there\n        # we go.\n        assert \"unicode\" in p.headers.keys()\n        assert \"byte\" in p.headers.keys()\n\n    def test_header_validation(self, httpbin):\n        \"\"\"Ensure prepare_headers regex isn't flagging valid header contents.\"\"\"\n        valid_headers = {\n            \"foo\": \"bar baz qux\",\n            \"bar\": b\"fbbq\",\n            \"baz\": \"\",\n            \"qux\": \"1\",\n        }\n        r = requests.get(httpbin(\"get\"), headers=valid_headers)\n        for key in valid_headers.keys():\n            assert valid_headers[key] == r.request.headers[key]\n\n    @pytest.mark.parametrize(\n        \"invalid_header, key\",\n        (\n            ({\"foo\": 3}, \"foo\"),\n            ({\"bar\": {\"foo\": \"bar\"}}, \"bar\"),\n            ({\"baz\": [\"foo\", \"bar\"]}, \"baz\"),\n        ),\n    )\n    def test_header_value_not_str(self, httpbin, invalid_header, key):\n        \"\"\"Ensure the header value is of type string or bytes as\n        per discussion in GH issue #3386\n        \"\"\"\n        with pytest.raises(InvalidHeader) as excinfo:\n            requests.get(httpbin(\"get\"), headers=invalid_header)\n        assert key in str(excinfo.value)\n\n    @pytest.mark.parametrize(\n        \"invalid_header\",\n        (\n            {\"foo\": \"bar\\r\\nbaz: qux\"},\n            {\"foo\": \"bar\\n\\rbaz: qux\"},\n            {\"foo\": \"bar\\nbaz: qux\"},\n            {\"foo\": \"bar\\rbaz: qux\"},\n            {\"fo\\ro\": \"bar\"},\n            {\"fo\\r\\no\": \"bar\"},\n            {\"fo\\n\\ro\": \"bar\"},\n            {\"fo\\no\": \"bar\"},\n        ),\n    )\n    def test_header_no_return_chars(self, httpbin, invalid_header):\n        \"\"\"Ensure that a header containing return character sequences raise an\n        exception. Otherwise, multiple headers are created from single string.\n        \"\"\"\n        with pytest.raises(InvalidHeader):\n            requests.get(httpbin(\"get\"), headers=invalid_header)\n\n    @pytest.mark.parametrize(\n        \"invalid_header\",\n        (\n            {\" foo\": \"bar\"},\n            {\"\\tfoo\": \"bar\"},\n            {\"    foo\": \"bar\"},\n            {\"foo\": \" bar\"},\n            {\"foo\": \"    bar\"},\n            {\"foo\": \"\\tbar\"},\n            {\" \": \"bar\"},\n        ),\n    )\n    def test_header_no_leading_space(self, httpbin, invalid_header):\n        \"\"\"Ensure headers containing leading whitespace raise\n        InvalidHeader Error before sending.\n        \"\"\"\n        with pytest.raises(InvalidHeader):\n            requests.get(httpbin(\"get\"), headers=invalid_header)\n\n    def test_header_with_subclass_types(self, httpbin):\n        \"\"\"If the subclasses does not behave *exactly* like\n        the base bytes/str classes, this is not supported.\n        This test is for backwards compatibility.\n        \"\"\"\n\n        class MyString(str):\n            pass\n\n        class MyBytes(bytes):\n            pass\n\n        r_str = requests.get(httpbin(\"get\"), headers={MyString(\"x-custom\"): \"myheader\"})\n        assert r_str.request.headers[\"x-custom\"] == \"myheader\"\n\n        r_bytes = requests.get(\n            httpbin(\"get\"), headers={MyBytes(b\"x-custom\"): b\"myheader\"}\n        )\n        assert r_bytes.request.headers[\"x-custom\"] == b\"myheader\"\n\n        r_mixed = requests.get(\n            httpbin(\"get\"), headers={MyString(\"x-custom\"): MyBytes(b\"myheader\")}\n        )\n        assert r_mixed.request.headers[\"x-custom\"] == b\"myheader\"\n\n    @pytest.mark.parametrize(\"files\", (\"foo\", b\"foo\", bytearray(b\"foo\")))\n    def test_can_send_objects_with_files(self, httpbin, files):\n        data = {\"a\": \"this is a string\"}\n        files = {\"b\": files}\n        r = requests.Request(\"POST\", httpbin(\"post\"), data=data, files=files)\n        p = r.prepare()\n        assert \"multipart/form-data\" in p.headers[\"Content-Type\"]\n\n    def test_can_send_file_object_with_non_string_filename(self, httpbin):\n        f = io.BytesIO()\n        f.name = 2\n        r = requests.Request(\"POST\", httpbin(\"post\"), files={\"f\": f})\n        p = r.prepare()\n\n        assert \"multipart/form-data\" in p.headers[\"Content-Type\"]\n\n    def test_autoset_header_values_are_native(self, httpbin):\n        data = \"this is a string\"\n        length = \"16\"\n        req = requests.Request(\"POST\", httpbin(\"post\"), data=data)\n        p = req.prepare()\n\n        assert p.headers[\"Content-Length\"] == length\n\n    def test_nonhttp_schemes_dont_check_URLs(self):\n        test_urls = (\n            \"data:image/gif;base64,R0lGODlhAQABAHAAACH5BAUAAAAALAAAAAABAAEAAAICRAEAOw==\",\n            \"file:///etc/passwd\",\n            \"magnet:?xt=urn:btih:be08f00302bc2d1d3cfa3af02024fa647a271431\",\n        )\n        for test_url in test_urls:\n            req = requests.Request(\"GET\", test_url)\n            preq = req.prepare()\n            assert test_url == preq.url\n\n    def test_auth_is_stripped_on_http_downgrade(\n        self, httpbin, httpbin_secure, httpbin_ca_bundle\n    ):\n        r = requests.get(\n            httpbin_secure(\"redirect-to\"),\n            params={\"url\": httpbin(\"get\")},\n            auth=(\"user\", \"pass\"),\n            verify=httpbin_ca_bundle,\n        )\n        assert r.history[0].request.headers[\"Authorization\"]\n        assert \"Authorization\" not in r.request.headers\n\n    def test_auth_is_retained_for_redirect_on_host(self, httpbin):\n        r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))\n        h1 = r.history[0].request.headers[\"Authorization\"]\n        h2 = r.request.headers[\"Authorization\"]\n\n        assert h1 == h2\n\n    def test_should_strip_auth_host_change(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\n            \"http://example.com/foo\", \"http://another.example.com/\"\n        )\n\n    def test_should_strip_auth_http_downgrade(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\"https://example.com/foo\", \"http://example.com/bar\")\n\n    def test_should_strip_auth_https_upgrade(self):\n        s = requests.Session()\n        assert not s.should_strip_auth(\n            \"http://example.com/foo\", \"https://example.com/bar\"\n        )\n        assert not s.should_strip_auth(\n            \"http://example.com:80/foo\", \"https://example.com/bar\"\n        )\n        assert not s.should_strip_auth(\n            \"http://example.com/foo\", \"https://example.com:443/bar\"\n        )\n        # Non-standard ports should trigger stripping\n        assert s.should_strip_auth(\n            \"http://example.com:8080/foo\", \"https://example.com/bar\"\n        )\n        assert s.should_strip_auth(\n            \"http://example.com/foo\", \"https://example.com:8443/bar\"\n        )\n\n    def test_should_strip_auth_port_change(self):\n        s = requests.Session()\n        assert s.should_strip_auth(\n            \"http://example.com:1234/foo\", \"https://example.com:4321/bar\"\n        )\n\n    @pytest.mark.parametrize(\n        \"old_uri, new_uri\",\n        (\n            (\"https://example.com:443/foo\", \"https://example.com/bar\"),\n            (\"http://example.com:80/foo\", \"http://example.com/bar\"),\n            (\"https://example.com/foo\", \"https://example.com:443/bar\"),\n            (\"http://example.com/foo\", \"http://example.com:80/bar\"),\n        ),\n    )\n    def test_should_strip_auth_default_port(self, old_uri, new_uri):\n        s = requests.Session()\n        assert not s.should_strip_auth(old_uri, new_uri)\n\n    def test_manual_redirect_with_partial_body_read(self, httpbin):\n        s = requests.Session()\n        r1 = s.get(httpbin(\"redirect/2\"), allow_redirects=False, stream=True)\n        assert r1.is_redirect\n        rg = s.resolve_redirects(r1, r1.request, stream=True)\n\n        # read only the first eight bytes of the response body,\n        # then follow the redirect\n        r1.iter_content(8)\n        r2 = next(rg)\n        assert r2.is_redirect\n\n        # read all of the response via iter_content,\n        # then follow the redirect\n        for _ in r2.iter_content():\n            pass\n        r3 = next(rg)\n        assert not r3.is_redirect\n\n    def test_prepare_body_position_non_stream(self):\n        data = b\"the data\"\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position is None\n\n    def test_rewind_body(self):\n        data = io.BytesIO(b\"the data\")\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position == 0\n        assert prep.body.read() == b\"the data\"\n\n        # the data has all been read\n        assert prep.body.read() == b\"\"\n\n        # rewind it back\n        requests.utils.rewind_body(prep)\n        assert prep.body.read() == b\"the data\"\n\n    def test_rewind_partially_read_body(self):\n        data = io.BytesIO(b\"the data\")\n        data.read(4)  # read some data\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position == 4\n        assert prep.body.read() == b\"data\"\n\n        # the data has all been read\n        assert prep.body.read() == b\"\"\n\n        # rewind it back\n        requests.utils.rewind_body(prep)\n        assert prep.body.read() == b\"data\"\n\n    def test_rewind_body_no_seek(self):\n        class BadFileObj:\n            def __init__(self, data):\n                self.data = data\n\n            def tell(self):\n                return 0\n\n            def __iter__(self):\n                return\n\n        data = BadFileObj(\"the data\")\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n            requests.utils.rewind_body(prep)\n\n        assert \"Unable to rewind request body\" in str(e)\n\n    def test_rewind_body_failed_seek(self):\n        class BadFileObj:\n            def __init__(self, data):\n                self.data = data\n\n            def tell(self):\n                return 0\n\n            def seek(self, pos, whence=0):\n                raise OSError()\n\n            def __iter__(self):\n                return\n\n        data = BadFileObj(\"the data\")\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position == 0\n\n        with pytest.raises(UnrewindableBodyError) as e:\n            requests.utils.rewind_body(prep)\n\n        assert \"error occurred when rewinding request body\" in str(e)\n\n    def test_rewind_body_failed_tell(self):\n        class BadFileObj:\n            def __init__(self, data):\n                self.data = data\n\n            def tell(self):\n                raise OSError()\n\n            def __iter__(self):\n                return\n\n        data = BadFileObj(\"the data\")\n        prep = requests.Request(\"GET\", \"http://example.com\", data=data).prepare()\n        assert prep._body_position is not None\n\n        with pytest.raises(UnrewindableBodyError) as e:\n            requests.utils.rewind_body(prep)\n\n        assert \"Unable to rewind request body\" in str(e)\n\n    def _patch_adapter_gzipped_redirect(self, session, url):\n        adapter = session.get_adapter(url=url)\n        org_build_response = adapter.build_response\n        self._patched_response = False\n\n        def build_response(*args, **kwargs):\n            resp = org_build_response(*args, **kwargs)\n            if not self._patched_response:\n                resp.raw.headers[\"content-encoding\"] = \"gzip\"\n                self._patched_response = True\n            return resp\n\n        adapter.build_response = build_response\n\n    def test_redirect_with_wrong_gzipped_header(self, httpbin):\n        s = requests.Session()\n        url = httpbin(\"redirect/1\")\n        self._patch_adapter_gzipped_redirect(s, url)\n        s.get(url)\n\n    @pytest.mark.parametrize(\n        \"username, password, auth_str\",\n        (\n            (\"test\", \"test\", \"Basic dGVzdDp0ZXN0\"),\n            (\n                \"имя\".encode(),\n                \"пароль\".encode(),\n                \"Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA==\",\n            ),\n        ),\n    )\n    def test_basic_auth_str_is_always_native(self, username, password, auth_str):\n        s = _basic_auth_str(username, password)\n        assert isinstance(s, builtin_str)\n        assert s == auth_str\n\n    def test_requests_history_is_saved(self, httpbin):\n        r = requests.get(httpbin(\"redirect/5\"))\n        total = r.history[-1].history\n        i = 0\n        for item in r.history:\n            assert item.history == total[0:i]\n            i += 1\n\n    def test_json_param_post_content_type_works(self, httpbin):\n        r = requests.post(httpbin(\"post\"), json={\"life\": 42})\n        assert r.status_code == 200\n        assert \"application/json\" in r.request.headers[\"Content-Type\"]\n        assert {\"life\": 42} == r.json()[\"json\"]\n\n    def test_json_param_post_should_not_override_data_param(self, httpbin):\n        r = requests.Request(\n            method=\"POST\",\n            url=httpbin(\"post\"),\n            data={\"stuff\": \"elixr\"},\n            json={\"music\": \"flute\"},\n        )\n        prep = r.prepare()\n        assert \"stuff=elixr\" == prep.body\n\n    def test_response_iter_lines(self, httpbin):\n        r = requests.get(httpbin(\"stream/4\"), stream=True)\n        assert r.status_code == 200\n\n        it = r.iter_lines()\n        next(it)\n        assert len(list(it)) == 3\n\n    def test_response_context_manager(self, httpbin):\n        with requests.get(httpbin(\"stream/4\"), stream=True) as response:\n            assert isinstance(response, requests.Response)\n\n        assert response.raw.closed\n\n    def test_unconsumed_session_response_closes_connection(self, httpbin):\n        s = requests.session()\n\n        with contextlib.closing(s.get(httpbin(\"stream/4\"), stream=True)) as response:\n            pass\n\n        assert response._content_consumed is False\n        assert response.raw.closed\n\n    @pytest.mark.xfail\n    def test_response_iter_lines_reentrant(self, httpbin):\n        \"\"\"Response.iter_lines() is not reentrant safe\"\"\"\n        r = requests.get(httpbin(\"stream/4\"), stream=True)\n        assert r.status_code == 200\n\n        next(r.iter_lines())\n        assert len(list(r.iter_lines())) == 3\n\n    def test_session_close_proxy_clear(self):\n        proxies = {\n            \"one\": mock.Mock(),\n            \"two\": mock.Mock(),\n        }\n        session = requests.Session()\n        with mock.patch.dict(session.adapters[\"http://\"].proxy_manager, proxies):\n            session.close()\n            proxies[\"one\"].clear.assert_called_once_with()\n            proxies[\"two\"].clear.assert_called_once_with()\n\n    def test_proxy_auth(self):\n        adapter = HTTPAdapter()\n        headers = adapter.proxy_headers(\"http://user:pass@httpbin.org\")\n        assert headers == {\"Proxy-Authorization\": \"Basic dXNlcjpwYXNz\"}\n\n    def test_proxy_auth_empty_pass(self):\n        adapter = HTTPAdapter()\n        headers = adapter.proxy_headers(\"http://user:@httpbin.org\")\n        assert headers == {\"Proxy-Authorization\": \"Basic dXNlcjo=\"}\n\n    def test_response_json_when_content_is_None(self, httpbin):\n        r = requests.get(httpbin(\"/status/204\"))\n        # Make sure r.content is None\n        r.status_code = 0\n        r._content = False\n        r._content_consumed = False\n\n        assert r.content is None\n        with pytest.raises(ValueError):\n            r.json()\n\n    def test_response_without_release_conn(self):\n        \"\"\"Test `close` call for non-urllib3-like raw objects.\n        Should work when `release_conn` attr doesn't exist on `response.raw`.\n        \"\"\"\n        resp = requests.Response()\n        resp.raw = StringIO.StringIO(\"test\")\n        assert not resp.raw.closed\n        resp.close()\n        assert resp.raw.closed\n\n    def test_empty_stream_with_auth_does_not_set_content_length_header(self, httpbin):\n        \"\"\"Ensure that a byte stream with size 0 will not set both a Content-Length\n        and Transfer-Encoding header.\n        \"\"\"\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"post\")\n        file_obj = io.BytesIO(b\"\")\n        r = requests.Request(\"POST\", url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert \"Transfer-Encoding\" in prepared_request.headers\n        assert \"Content-Length\" not in prepared_request.headers\n\n    def test_stream_with_auth_does_not_set_transfer_encoding_header(self, httpbin):\n        \"\"\"Ensure that a byte stream with size > 0 will not set both a Content-Length\n        and Transfer-Encoding header.\n        \"\"\"\n        auth = (\"user\", \"pass\")\n        url = httpbin(\"post\")\n        file_obj = io.BytesIO(b\"test data\")\n        r = requests.Request(\"POST\", url, auth=auth, data=file_obj)\n        prepared_request = r.prepare()\n        assert \"Transfer-Encoding\" not in prepared_request.headers\n        assert \"Content-Length\" in prepared_request.headers\n\n    def test_chunked_upload_does_not_set_content_length_header(self, httpbin):\n        \"\"\"Ensure that requests with a generator body stream using\n        Transfer-Encoding: chunked, not a Content-Length header.\n        \"\"\"\n        data = (i for i in [b\"a\", b\"b\", b\"c\"])\n        url = httpbin(\"post\")\n        r = requests.Request(\"POST\", url, data=data)\n        prepared_request = r.prepare()\n        assert \"Transfer-Encoding\" in prepared_request.headers\n        assert \"Content-Length\" not in prepared_request.headers\n\n    def test_custom_redirect_mixin(self, httpbin):\n        \"\"\"Tests a custom mixin to overwrite ``get_redirect_target``.\n\n        Ensures a subclassed ``requests.Session`` can handle a certain type of\n        malformed redirect responses.\n\n        1. original request receives a proper response: 302 redirect\n        2. following the redirect, a malformed response is given:\n            status code = HTTP 200\n            location = alternate url\n        3. the custom session catches the edge case and follows the redirect\n        \"\"\"\n        url_final = httpbin(\"html\")\n        querystring_malformed = urlencode({\"location\": url_final})\n        url_redirect_malformed = httpbin(\"response-headers?%s\" % querystring_malformed)\n        querystring_redirect = urlencode({\"url\": url_redirect_malformed})\n        url_redirect = httpbin(\"redirect-to?%s\" % querystring_redirect)\n        urls_test = [\n            url_redirect,\n            url_redirect_malformed,\n            url_final,\n        ]\n\n        class CustomRedirectSession(requests.Session):\n            def get_redirect_target(self, resp):\n                # default behavior\n                if resp.is_redirect:\n                    return resp.headers[\"location\"]\n                # edge case - check to see if 'location' is in headers anyways\n                location = resp.headers.get(\"location\")\n                if location and (location != resp.url):\n                    return location\n                return None\n\n        session = CustomRedirectSession()\n        r = session.get(urls_test[0])\n        assert len(r.history) == 2\n        assert r.status_code == 200\n        assert r.history[0].status_code == 302\n        assert r.history[0].is_redirect\n        assert r.history[1].status_code == 200\n        assert not r.history[1].is_redirect\n        assert r.url == urls_test[2]\n\n\nclass TestCaseInsensitiveDict:\n    @pytest.mark.parametrize(\n        \"cid\",\n        (\n            CaseInsensitiveDict({\"Foo\": \"foo\", \"BAr\": \"bar\"}),\n            CaseInsensitiveDict([(\"Foo\", \"foo\"), (\"BAr\", \"bar\")]),\n            CaseInsensitiveDict(FOO=\"foo\", BAr=\"bar\"),\n        ),\n    )\n    def test_init(self, cid):\n        assert len(cid) == 2\n        assert \"foo\" in cid\n        assert \"bar\" in cid\n\n    def test_docstring_example(self):\n        cid = CaseInsensitiveDict()\n        cid[\"Accept\"] = \"application/json\"\n        assert cid[\"aCCEPT\"] == \"application/json\"\n        assert list(cid) == [\"Accept\"]\n\n    def test_len(self):\n        cid = CaseInsensitiveDict({\"a\": \"a\", \"b\": \"b\"})\n        cid[\"A\"] = \"a\"\n        assert len(cid) == 2\n\n    def test_getitem(self):\n        cid = CaseInsensitiveDict({\"Spam\": \"blueval\"})\n        assert cid[\"spam\"] == \"blueval\"\n        assert cid[\"SPAM\"] == \"blueval\"\n\n    def test_fixes_649(self):\n        \"\"\"__setitem__ should behave case-insensitively.\"\"\"\n        cid = CaseInsensitiveDict()\n        cid[\"spam\"] = \"oneval\"\n        cid[\"Spam\"] = \"twoval\"\n        cid[\"sPAM\"] = \"redval\"\n        cid[\"SPAM\"] = \"blueval\"\n        assert cid[\"spam\"] == \"blueval\"\n        assert cid[\"SPAM\"] == \"blueval\"\n        assert list(cid.keys()) == [\"SPAM\"]\n\n    def test_delitem(self):\n        cid = CaseInsensitiveDict()\n        cid[\"Spam\"] = \"someval\"\n        del cid[\"sPam\"]\n        assert \"spam\" not in cid\n        assert len(cid) == 0\n\n    def test_contains(self):\n        cid = CaseInsensitiveDict()\n        cid[\"Spam\"] = \"someval\"\n        assert \"Spam\" in cid\n        assert \"spam\" in cid\n        assert \"SPAM\" in cid\n        assert \"sPam\" in cid\n        assert \"notspam\" not in cid\n\n    def test_get(self):\n        cid = CaseInsensitiveDict()\n        cid[\"spam\"] = \"oneval\"\n        cid[\"SPAM\"] = \"blueval\"\n        assert cid.get(\"spam\") == \"blueval\"\n        assert cid.get(\"SPAM\") == \"blueval\"\n        assert cid.get(\"sPam\") == \"blueval\"\n        assert cid.get(\"notspam\", \"default\") == \"default\"\n\n    def test_update(self):\n        cid = CaseInsensitiveDict()\n        cid[\"spam\"] = \"blueval\"\n        cid.update({\"sPam\": \"notblueval\"})\n        assert cid[\"spam\"] == \"notblueval\"\n        cid = CaseInsensitiveDict({\"Foo\": \"foo\", \"BAr\": \"bar\"})\n        cid.update({\"fOO\": \"anotherfoo\", \"bAR\": \"anotherbar\"})\n        assert len(cid) == 2\n        assert cid[\"foo\"] == \"anotherfoo\"\n        assert cid[\"bar\"] == \"anotherbar\"\n\n    def test_update_retains_unchanged(self):\n        cid = CaseInsensitiveDict({\"foo\": \"foo\", \"bar\": \"bar\"})\n        cid.update({\"foo\": \"newfoo\"})\n        assert cid[\"bar\"] == \"bar\"\n\n    def test_iter(self):\n        cid = CaseInsensitiveDict({\"Spam\": \"spam\", \"Eggs\": \"eggs\"})\n        keys = frozenset([\"Spam\", \"Eggs\"])\n        assert frozenset(iter(cid)) == keys\n\n    def test_equality(self):\n        cid = CaseInsensitiveDict({\"SPAM\": \"blueval\", \"Eggs\": \"redval\"})\n        othercid = CaseInsensitiveDict({\"spam\": \"blueval\", \"eggs\": \"redval\"})\n        assert cid == othercid\n        del othercid[\"spam\"]\n        assert cid != othercid\n        assert cid == {\"spam\": \"blueval\", \"eggs\": \"redval\"}\n        assert cid != object()\n\n    def test_setdefault(self):\n        cid = CaseInsensitiveDict({\"Spam\": \"blueval\"})\n        assert cid.setdefault(\"spam\", \"notblueval\") == \"blueval\"\n        assert cid.setdefault(\"notspam\", \"notblueval\") == \"notblueval\"\n\n    def test_lower_items(self):\n        cid = CaseInsensitiveDict(\n            {\n                \"Accept\": \"application/json\",\n                \"user-Agent\": \"requests\",\n            }\n        )\n        keyset = frozenset(lowerkey for lowerkey, v in cid.lower_items())\n        lowerkeyset = frozenset([\"accept\", \"user-agent\"])\n        assert keyset == lowerkeyset\n\n    def test_preserve_key_case(self):\n        cid = CaseInsensitiveDict(\n            {\n                \"Accept\": \"application/json\",\n                \"user-Agent\": \"requests\",\n            }\n        )\n        keyset = frozenset([\"Accept\", \"user-Agent\"])\n        assert frozenset(i[0] for i in cid.items()) == keyset\n        assert frozenset(cid.keys()) == keyset\n        assert frozenset(cid) == keyset\n\n    def test_preserve_last_key_case(self):\n        cid = CaseInsensitiveDict(\n            {\n                \"Accept\": \"application/json\",\n                \"user-Agent\": \"requests\",\n            }\n        )\n        cid.update({\"ACCEPT\": \"application/json\"})\n        cid[\"USER-AGENT\"] = \"requests\"\n        keyset = frozenset([\"ACCEPT\", \"USER-AGENT\"])\n        assert frozenset(i[0] for i in cid.items()) == keyset\n        assert frozenset(cid.keys()) == keyset\n        assert frozenset(cid) == keyset\n\n    def test_copy(self):\n        cid = CaseInsensitiveDict(\n            {\n                \"Accept\": \"application/json\",\n                \"user-Agent\": \"requests\",\n            }\n        )\n        cid_copy = cid.copy()\n        assert cid == cid_copy\n        cid[\"changed\"] = True\n        assert cid != cid_copy\n\n\nclass TestMorselToCookieExpires:\n    \"\"\"Tests for morsel_to_cookie when morsel contains expires.\"\"\"\n\n    def test_expires_valid_str(self):\n        \"\"\"Test case where we convert expires from string time.\"\"\"\n\n        morsel = Morsel()\n        morsel[\"expires\"] = \"Thu, 01-Jan-1970 00:00:01 GMT\"\n        cookie = morsel_to_cookie(morsel)\n        assert cookie.expires == 1\n\n    @pytest.mark.parametrize(\n        \"value, exception\",\n        (\n            (100, TypeError),\n            (\"woops\", ValueError),\n        ),\n    )\n    def test_expires_invalid_int(self, value, exception):\n        \"\"\"Test case where an invalid type is passed for expires.\"\"\"\n        morsel = Morsel()\n        morsel[\"expires\"] = value\n        with pytest.raises(exception):\n            morsel_to_cookie(morsel)\n\n    def test_expires_none(self):\n        \"\"\"Test case where expires is None.\"\"\"\n\n        morsel = Morsel()\n        morsel[\"expires\"] = None\n        cookie = morsel_to_cookie(morsel)\n        assert cookie.expires is None\n\n\nclass TestMorselToCookieMaxAge:\n\n    \"\"\"Tests for morsel_to_cookie when morsel contains max-age.\"\"\"\n\n    def test_max_age_valid_int(self):\n        \"\"\"Test case where a valid max age in seconds is passed.\"\"\"\n\n        morsel = Morsel()\n        morsel[\"max-age\"] = 60\n        cookie = morsel_to_cookie(morsel)\n        assert isinstance(cookie.expires, int)\n\n    def test_max_age_invalid_str(self):\n        \"\"\"Test case where a invalid max age is passed.\"\"\"\n\n        morsel = Morsel()\n        morsel[\"max-age\"] = \"woops\"\n        with pytest.raises(TypeError):\n            morsel_to_cookie(morsel)\n\n\nclass TestTimeout:\n    def test_stream_timeout(self, httpbin):\n        try:\n            requests.get(httpbin(\"delay/10\"), timeout=2.0)\n        except requests.exceptions.Timeout as e:\n            assert \"Read timed out\" in e.args[0].args[0]\n\n    @pytest.mark.parametrize(\n        \"timeout, error_text\",\n        (\n            ((3, 4, 5), \"(connect, read)\"),\n            (\"foo\", \"must be an int, float or None\"),\n        ),\n    )\n    def test_invalid_timeout(self, httpbin, timeout, error_text):\n        with pytest.raises(ValueError) as e:\n            requests.get(httpbin(\"get\"), timeout=timeout)\n        assert error_text in str(e)\n\n    @pytest.mark.parametrize(\"timeout\", (None, Urllib3Timeout(connect=None, read=None)))\n    def test_none_timeout(self, httpbin, timeout):\n        \"\"\"Check that you can set None as a valid timeout value.\n\n        To actually test this behavior, we'd want to check that setting the\n        timeout to None actually lets the request block past the system default\n        timeout. However, this would make the test suite unbearably slow.\n        Instead we verify that setting the timeout to None does not prevent the\n        request from succeeding.\n        \"\"\"\n        r = requests.get(httpbin(\"get\"), timeout=timeout)\n        assert r.status_code == 200\n\n    @pytest.mark.parametrize(\n        \"timeout\", ((None, 0.1), Urllib3Timeout(connect=None, read=0.1))\n    )\n    def test_read_timeout(self, httpbin, timeout):\n        try:\n            requests.get(httpbin(\"delay/10\"), timeout=timeout)\n            pytest.fail(\"The recv() request should time out.\")\n        except ReadTimeout:\n            pass\n\n    @pytest.mark.parametrize(\n        \"timeout\", ((0.1, None), Urllib3Timeout(connect=0.1, read=None))\n    )\n    def test_connect_timeout(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail(\"The connect() request should time out.\")\n        except ConnectTimeout as e:\n            assert isinstance(e, ConnectionError)\n            assert isinstance(e, Timeout)\n\n    @pytest.mark.parametrize(\n        \"timeout\", ((0.1, 0.1), Urllib3Timeout(connect=0.1, read=0.1))\n    )\n    def test_total_timeout_connect(self, timeout):\n        try:\n            requests.get(TARPIT, timeout=timeout)\n            pytest.fail(\"The connect() request should time out.\")\n        except ConnectTimeout:\n            pass\n\n    def test_encoded_methods(self, httpbin):\n        \"\"\"See: https://github.com/psf/requests/issues/2316\"\"\"\n        r = requests.request(b\"GET\", httpbin(\"get\"))\n        assert r.ok\n\n\nSendCall = collections.namedtuple(\"SendCall\", (\"args\", \"kwargs\"))\n\n\nclass RedirectSession(SessionRedirectMixin):\n    def __init__(self, order_of_redirects):\n        self.redirects = order_of_redirects\n        self.calls = []\n        self.max_redirects = 30\n        self.cookies = {}\n        self.trust_env = False\n\n    def send(self, *args, **kwargs):\n        self.calls.append(SendCall(args, kwargs))\n        return self.build_response()\n\n    def build_response(self):\n        request = self.calls[-1].args[0]\n        r = requests.Response()\n\n        try:\n            r.status_code = int(self.redirects.pop(0))\n        except IndexError:\n            r.status_code = 200\n\n        r.headers = CaseInsensitiveDict({\"Location\": \"/\"})\n        r.raw = self._build_raw()\n        r.request = request\n        return r\n\n    def _build_raw(self):\n        string = StringIO.StringIO(\"\")\n        setattr(string, \"release_conn\", lambda *args: args)\n        return string\n\n\ndef test_json_encodes_as_bytes():\n    # urllib3 expects bodies as bytes-like objects\n    body = {\"key\": \"value\"}\n    p = PreparedRequest()\n    p.prepare(method=\"GET\", url=\"https://www.example.com/\", json=body)\n    assert isinstance(p.body, bytes)\n\n\ndef test_requests_are_updated_each_time(httpbin):\n    session = RedirectSession([303, 307])\n    prep = requests.Request(\"POST\", httpbin(\"post\")).prepare()\n    r0 = session.send(prep)\n    assert r0.request.method == \"POST\"\n    assert session.calls[-1] == SendCall((r0.request,), {})\n    redirect_generator = session.resolve_redirects(r0, prep)\n    default_keyword_args = {\n        \"stream\": False,\n        \"verify\": True,\n        \"cert\": None,\n        \"timeout\": None,\n        \"allow_redirects\": False,\n        \"proxies\": {},\n    }\n    for response in redirect_generator:\n        assert response.request.method == \"GET\"\n        send_call = SendCall((response.request,), default_keyword_args)\n        assert session.calls[-1] == send_call\n\n\n@pytest.mark.parametrize(\n    \"var,url,proxy\",\n    [\n        (\"http_proxy\", \"http://example.com\", \"socks5://proxy.com:9876\"),\n        (\"https_proxy\", \"https://example.com\", \"socks5://proxy.com:9876\"),\n        (\"all_proxy\", \"http://example.com\", \"socks5://proxy.com:9876\"),\n        (\"all_proxy\", \"https://example.com\", \"socks5://proxy.com:9876\"),\n    ],\n)\ndef test_proxy_env_vars_override_default(var, url, proxy):\n    session = requests.Session()\n    prep = PreparedRequest()\n    prep.prepare(method=\"GET\", url=url)\n\n    kwargs = {var: proxy}\n    scheme = urlparse(url).scheme\n    with override_environ(**kwargs):\n        proxies = session.rebuild_proxies(prep, {})\n        assert scheme in proxies\n        assert proxies[scheme] == proxy\n\n\n@pytest.mark.parametrize(\n    \"data\",\n    (\n        ((\"a\", \"b\"), (\"c\", \"d\")),\n        ((\"c\", \"d\"), (\"a\", \"b\")),\n        ((\"a\", \"b\"), (\"c\", \"d\"), (\"e\", \"f\")),\n    ),\n)\ndef test_data_argument_accepts_tuples(data):\n    \"\"\"Ensure that the data argument will accept tuples of strings\n    and properly encode them.\n    \"\"\"\n    p = PreparedRequest()\n    p.prepare(\n        method=\"GET\", url=\"http://www.example.com\", data=data, hooks=default_hooks()\n    )\n    assert p.body == urlencode(data)\n\n\n@pytest.mark.parametrize(\n    \"kwargs\",\n    (\n        None,\n        {\n            \"method\": \"GET\",\n            \"url\": \"http://www.example.com\",\n            \"data\": \"foo=bar\",\n            \"hooks\": default_hooks(),\n        },\n        {\n            \"method\": \"GET\",\n            \"url\": \"http://www.example.com\",\n            \"data\": \"foo=bar\",\n            \"hooks\": default_hooks(),\n            \"cookies\": {\"foo\": \"bar\"},\n        },\n        {\"method\": \"GET\", \"url\": \"http://www.example.com/üniçø∂é\"},\n    ),\n)\ndef test_prepared_copy(kwargs):\n    p = PreparedRequest()\n    if kwargs:\n        p.prepare(**kwargs)\n    copy = p.copy()\n    for attr in (\"method\", \"url\", \"headers\", \"_cookies\", \"body\", \"hooks\"):\n        assert getattr(p, attr) == getattr(copy, attr)\n\n\ndef test_urllib3_retries(httpbin):\n    from urllib3.util import Retry\n\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(max_retries=Retry(total=2, status_forcelist=[500])))\n\n    with pytest.raises(RetryError):\n        s.get(httpbin(\"status/500\"))\n\n\ndef test_urllib3_pool_connection_closed(httpbin):\n    s = requests.Session()\n    s.mount(\"http://\", HTTPAdapter(pool_connections=0, pool_maxsize=0))\n\n    try:\n        s.get(httpbin(\"status/200\"))\n    except ConnectionError as e:\n        assert \"Pool is closed.\" in str(e)\n\n\nclass TestPreparingURLs:\n    @pytest.mark.parametrize(\n        \"url,expected\",\n        (\n            (\"http://google.com\", \"http://google.com/\"),\n            (\"http://ジェーピーニック.jp\", \"http://xn--hckqz9bzb1cyrb.jp/\"),\n            (\"http://xn--n3h.net/\", \"http://xn--n3h.net/\"),\n            (\"http://ジェーピーニック.jp\".encode(), \"http://xn--hckqz9bzb1cyrb.jp/\"),\n            (\"http://straße.de/straße\", \"http://xn--strae-oqa.de/stra%C3%9Fe\"),\n            (\n                \"http://straße.de/straße\".encode(),\n                \"http://xn--strae-oqa.de/stra%C3%9Fe\",\n            ),\n            (\n                \"http://Königsgäßchen.de/straße\",\n                \"http://xn--knigsgchen-b4a3dun.de/stra%C3%9Fe\",\n            ),\n            (\n                \"http://Königsgäßchen.de/straße\".encode(),\n                \"http://xn--knigsgchen-b4a3dun.de/stra%C3%9Fe\",\n            ),\n            (b\"http://xn--n3h.net/\", \"http://xn--n3h.net/\"),\n            (\n                b\"http://[1200:0000:ab00:1234:0000:2552:7777:1313]:12345/\",\n                \"http://[1200:0000:ab00:1234:0000:2552:7777:1313]:12345/\",\n            ),\n            (\n                \"http://[1200:0000:ab00:1234:0000:2552:7777:1313]:12345/\",\n                \"http://[1200:0000:ab00:1234:0000:2552:7777:1313]:12345/\",\n            ),\n        ),\n    )\n    def test_preparing_url(self, url, expected):\n        def normalize_percent_encode(x):\n            # Helper function that normalizes equivalent\n            # percent-encoded bytes before comparisons\n            for c in re.findall(r\"%[a-fA-F0-9]{2}\", x):\n                x = x.replace(c, c.upper())\n            return x\n\n        r = requests.Request(\"GET\", url=url)\n        p = r.prepare()\n        assert normalize_percent_encode(p.url) == expected\n\n    @pytest.mark.parametrize(\n        \"url\",\n        (\n            b\"http://*.google.com\",\n            b\"http://*\",\n            \"http://*.google.com\",\n            \"http://*\",\n            \"http://☃.net/\",\n        ),\n    )\n    def test_preparing_bad_url(self, url):\n        r = requests.Request(\"GET\", url=url)\n        with pytest.raises(requests.exceptions.InvalidURL):\n            r.prepare()\n\n    @pytest.mark.parametrize(\"url, exception\", ((\"http://:1\", InvalidURL),))\n    def test_redirecting_to_bad_url(self, httpbin, url, exception):\n        with pytest.raises(exception):\n            requests.get(httpbin(\"redirect-to\"), params={\"url\": url})\n\n    @pytest.mark.parametrize(\n        \"input, expected\",\n        (\n            (\n                b\"http+unix://%2Fvar%2Frun%2Fsocket/path%7E\",\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path~\",\n            ),\n            (\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path%7E\",\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path~\",\n            ),\n            (\n                b\"mailto:user@example.org\",\n                \"mailto:user@example.org\",\n            ),\n            (\n                \"mailto:user@example.org\",\n                \"mailto:user@example.org\",\n            ),\n            (\n                b\"data:SSDimaUgUHl0aG9uIQ==\",\n                \"data:SSDimaUgUHl0aG9uIQ==\",\n            ),\n        ),\n    )\n    def test_url_mutation(self, input, expected):\n        \"\"\"\n        This test validates that we correctly exclude some URLs from\n        preparation, and that we handle others. Specifically, it tests that\n        any URL whose scheme doesn't begin with \"http\" is left alone, and\n        those whose scheme *does* begin with \"http\" are mutated.\n        \"\"\"\n        r = requests.Request(\"GET\", url=input)\n        p = r.prepare()\n        assert p.url == expected\n\n    @pytest.mark.parametrize(\n        \"input, params, expected\",\n        (\n            (\n                b\"http+unix://%2Fvar%2Frun%2Fsocket/path\",\n                {\"key\": \"value\"},\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path?key=value\",\n            ),\n            (\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path\",\n                {\"key\": \"value\"},\n                \"http+unix://%2Fvar%2Frun%2Fsocket/path?key=value\",\n            ),\n            (\n                b\"mailto:user@example.org\",\n                {\"key\": \"value\"},\n                \"mailto:user@example.org\",\n            ),\n            (\n                \"mailto:user@example.org\",\n                {\"key\": \"value\"},\n                \"mailto:user@example.org\",\n            ),\n        ),\n    )\n    def test_parameters_for_nonstandard_schemes(self, input, params, expected):\n        \"\"\"\n        Setting parameters for nonstandard schemes is allowed if those schemes\n        begin with \"http\", and is forbidden otherwise.\n        \"\"\"\n        r = requests.Request(\"GET\", url=input, params=params)\n        p = r.prepare()\n        assert p.url == expected\n\n    def test_post_json_nan(self, httpbin):\n        data = {\"foo\": float(\"nan\")}\n        with pytest.raises(requests.exceptions.InvalidJSONError):\n            requests.post(httpbin(\"post\"), json=data)\n\n    def test_json_decode_compatibility(self, httpbin):\n        r = requests.get(httpbin(\"bytes/20\"))\n        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n            r.json()\n        assert isinstance(excinfo.value, RequestException)\n        assert isinstance(excinfo.value, JSONDecodeError)\n        assert r.text not in str(excinfo.value)\n\n    def test_json_decode_persists_doc_attr(self, httpbin):\n        r = requests.get(httpbin(\"bytes/20\"))\n        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n            r.json()\n        assert excinfo.value.doc == r.text\n\n    def test_status_code_425(self):\n        r1 = requests.codes.get(\"TOO_EARLY\")\n        r2 = requests.codes.get(\"too_early\")\n        r3 = requests.codes.get(\"UNORDERED\")\n        r4 = requests.codes.get(\"unordered\")\n        r5 = requests.codes.get(\"UNORDERED_COLLECTION\")\n        r6 = requests.codes.get(\"unordered_collection\")\n\n        assert r1 == 425\n        assert r2 == 425\n        assert r3 == 425\n        assert r4 == 425\n        assert r5 == 425\n        assert r6 == 425\n\n    def test_different_connection_pool_for_tls_settings_verify_True(self):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Cannot verify self-signed certificate\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url)\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n\n    def test_different_connection_pool_for_tls_settings_verify_bundle_expired_cert(\n        self,\n    ):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            # Has right trust bundle, but certificate expired\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, verify=\"tests/certs/expired/ca/ca.crt\")\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n\n    def test_different_connection_pool_for_tls_settings_verify_bundle_unexpired_cert(\n        self,\n    ):\n        def response_handler(sock):\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=3,\n            cert_chain=\"tests/certs/valid/server/server.pem\",\n            keyfile=\"tests/certs/valid/server/server.key\",\n        )\n\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False)\n            assert r1.status_code == 200\n\n            r2 = s.get(url, verify=\"tests/certs/valid/ca/ca.crt\")\n            assert r2.status_code == 200\n\n            close_server.set()\n        assert 2 == len(s.adapters[\"https://\"].poolmanager.pools)\n\n    def test_different_connection_pool_for_mtls_settings(self):\n        client_cert = None\n\n        def response_handler(sock):\n            nonlocal client_cert\n            client_cert = sock.getpeercert()\n            consume_socket_content(sock, timeout=0.5)\n            sock.send(\n                b\"HTTP/1.1 200 OK\\r\\n\"\n                b\"Content-Length: 18\\r\\n\\r\\n\"\n                b'\\xff\\xfe{\\x00\"\\x00K0\"\\x00=\\x00\"\\x00\\xab0\"\\x00\\r\\n'\n            )\n\n        s = requests.Session()\n        close_server = threading.Event()\n        server = TLSServer(\n            handler=response_handler,\n            wait_to_close_event=close_server,\n            requests_to_handle=2,\n            cert_chain=\"tests/certs/expired/server/server.pem\",\n            keyfile=\"tests/certs/expired/server/server.key\",\n            mutual_tls=True,\n            cacert=\"tests/certs/expired/ca/ca.crt\",\n        )\n\n        cert = (\n            \"tests/certs/mtls/client/client.pem\",\n            \"tests/certs/mtls/client/client.key\",\n        )\n        with server as (host, port):\n            url = f\"https://{host}:{port}\"\n            r1 = s.get(url, verify=False, cert=cert)\n            assert r1.status_code == 200\n            with pytest.raises(requests.exceptions.SSLError):\n                s.get(url, cert=cert)\n            close_server.set()\n\n        assert client_cert is not None\n\n\ndef test_content_length_for_bytes_data(httpbin):\n    data = \"This is a string containing multi-byte UTF-8 ☃️\"\n    encoded_data = data.encode(\"utf-8\")\n    length = str(len(encoded_data))\n    req = requests.Request(\"POST\", httpbin(\"post\"), data=encoded_data)\n    p = req.prepare()\n\n    assert p.headers[\"Content-Length\"] == length\n\n\n@pytest.mark.skipif(\n    is_urllib3_1,\n    reason=\"urllib3 2.x encodes all strings to utf-8, urllib3 1.x uses latin-1\",\n)\ndef test_content_length_for_string_data_counts_bytes(httpbin):\n    data = \"This is a string containing multi-byte UTF-8 ☃️\"\n    length = str(len(data.encode(\"utf-8\")))\n    req = requests.Request(\"POST\", httpbin(\"post\"), data=data)\n    p = req.prepare()\n\n    assert p.headers[\"Content-Length\"] == length\n\n\ndef test_json_decode_errors_are_serializable_deserializable():\n    json_decode_error = requests.exceptions.JSONDecodeError(\n        \"Extra data\",\n        '{\"responseCode\":[\"706\"],\"data\":null}{\"responseCode\":[\"706\"],\"data\":null}',\n        36,\n    )\n    deserialized_error = pickle.loads(pickle.dumps(json_decode_error))\n    assert repr(json_decode_error) == repr(deserialized_error)\n",
    "tests/test_structures.py": "import pytest\n\nfrom requests.structures import CaseInsensitiveDict, LookupDict\n\n\nclass TestCaseInsensitiveDict:\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        \"\"\"CaseInsensitiveDict instance with \"Accept\" header.\"\"\"\n        self.case_insensitive_dict = CaseInsensitiveDict()\n        self.case_insensitive_dict[\"Accept\"] = \"application/json\"\n\n    def test_list(self):\n        assert list(self.case_insensitive_dict) == [\"Accept\"]\n\n    possible_keys = pytest.mark.parametrize(\n        \"key\", (\"accept\", \"ACCEPT\", \"aCcEpT\", \"Accept\")\n    )\n\n    @possible_keys\n    def test_getitem(self, key):\n        assert self.case_insensitive_dict[key] == \"application/json\"\n\n    @possible_keys\n    def test_delitem(self, key):\n        del self.case_insensitive_dict[key]\n        assert key not in self.case_insensitive_dict\n\n    def test_lower_items(self):\n        assert list(self.case_insensitive_dict.lower_items()) == [\n            (\"accept\", \"application/json\")\n        ]\n\n    def test_repr(self):\n        assert repr(self.case_insensitive_dict) == \"{'Accept': 'application/json'}\"\n\n    def test_copy(self):\n        copy = self.case_insensitive_dict.copy()\n        assert copy is not self.case_insensitive_dict\n        assert copy == self.case_insensitive_dict\n\n    @pytest.mark.parametrize(\n        \"other, result\",\n        (\n            ({\"AccePT\": \"application/json\"}, True),\n            ({}, False),\n            (None, False),\n        ),\n    )\n    def test_instance_equality(self, other, result):\n        assert (self.case_insensitive_dict == other) is result\n\n\nclass TestLookupDict:\n    @pytest.fixture(autouse=True)\n    def setup(self):\n        \"\"\"LookupDict instance with \"bad_gateway\" attribute.\"\"\"\n        self.lookup_dict = LookupDict(\"test\")\n        self.lookup_dict.bad_gateway = 502\n\n    def test_repr(self):\n        assert repr(self.lookup_dict) == \"<lookup 'test'>\"\n\n    get_item_parameters = pytest.mark.parametrize(\n        \"key, value\",\n        (\n            (\"bad_gateway\", 502),\n            (\"not_a_key\", None),\n        ),\n    )\n\n    @get_item_parameters\n    def test_getitem(self, key, value):\n        assert self.lookup_dict[key] == value\n\n    @get_item_parameters\n    def test_get(self, key, value):\n        assert self.lookup_dict.get(key) == value\n"
  },
  "requirements": null
}