{
  "repo_name": "home-assistant/core",
  "repo_url": "https://github.com/home-assistant/core",
  "description": ":house_with_garden: Open source home automation that puts local control and privacy first.",
  "stars": 77180,
  "language": "Python",
  "created_at": "2013-09-17T07:29:48Z",
  "updated_at": "2025-03-19T06:53:33Z",
  "files": {
    "homeassistant/components/assist_satellite/connection_test.py": "\"\"\"Assist satellite connection test.\"\"\"\n\nimport logging\nfrom pathlib import Path\n\nfrom aiohttp import web\n\nfrom homeassistant.components.http import KEY_HASS, HomeAssistantView\n\nfrom .const import CONNECTION_TEST_DATA\n\n_LOGGER = logging.getLogger(__name__)\n\nCONNECTION_TEST_CONTENT_TYPE = \"audio/mpeg\"\nCONNECTION_TEST_FILENAME = \"connection_test.mp3\"\nCONNECTION_TEST_URL_BASE = \"/api/assist_satellite/connection_test\"\n\n\nclass ConnectionTestView(HomeAssistantView):\n    \"\"\"View to serve an audio sample for connection test.\"\"\"\n\n    requires_auth = False\n    url = f\"{CONNECTION_TEST_URL_BASE}/{{connection_id}}\"\n    name = \"api:assist_satellite_connection_test\"\n\n    async def get(self, request: web.Request, connection_id: str) -> web.Response:\n        \"\"\"Start a get request.\"\"\"\n        _LOGGER.debug(\"Request for connection test with id %s\", connection_id)\n\n        hass = request.app[KEY_HASS]\n        connection_test_data = hass.data[CONNECTION_TEST_DATA]\n\n        connection_test_event = connection_test_data.pop(connection_id, None)\n\n        if connection_test_event is None:\n            return web.Response(status=404)\n\n        connection_test_event.set()\n\n        audio_path = Path(__file__).parent / CONNECTION_TEST_FILENAME\n        audio_data = await hass.async_add_executor_job(audio_path.read_bytes)\n\n        return web.Response(body=audio_data, content_type=CONNECTION_TEST_CONTENT_TYPE)\n",
    "homeassistant/components/mqtt_statestream/__init__.py": "\"\"\"Publish simple item state changes via MQTT.\"\"\"\n\nimport json\nimport logging\n\nimport voluptuous as vol\n\nfrom homeassistant.components import mqtt\nfrom homeassistant.components.mqtt import valid_publish_topic\nfrom homeassistant.const import EVENT_HOMEASSISTANT_STOP, EVENT_STATE_CHANGED\nfrom homeassistant.core import Event, EventStateChangedData, HomeAssistant, callback\nfrom homeassistant.helpers import config_validation as cv\nfrom homeassistant.helpers.entityfilter import (\n    INCLUDE_EXCLUDE_BASE_FILTER_SCHEMA,\n    convert_include_exclude_filter,\n)\nfrom homeassistant.helpers.json import JSONEncoder\nfrom homeassistant.helpers.start import async_at_start\nfrom homeassistant.helpers.typing import ConfigType\n\nCONF_BASE_TOPIC = \"base_topic\"\nCONF_PUBLISH_ATTRIBUTES = \"publish_attributes\"\nCONF_PUBLISH_TIMESTAMPS = \"publish_timestamps\"\n\nDOMAIN = \"mqtt_statestream\"\n\nCONFIG_SCHEMA = vol.Schema(\n    {\n        DOMAIN: INCLUDE_EXCLUDE_BASE_FILTER_SCHEMA.extend(\n            {\n                vol.Required(CONF_BASE_TOPIC): valid_publish_topic,\n                vol.Optional(CONF_PUBLISH_ATTRIBUTES, default=False): cv.boolean,\n                vol.Optional(CONF_PUBLISH_TIMESTAMPS, default=False): cv.boolean,\n            }\n        ),\n    },\n    extra=vol.ALLOW_EXTRA,\n)\n\n_LOGGER = logging.getLogger(__name__)\n\n\nasync def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:\n    \"\"\"Set up the MQTT state feed.\"\"\"\n    # Make sure MQTT integration is enabled and the client is available\n    if not await mqtt.async_wait_for_mqtt_client(hass):\n        _LOGGER.error(\"MQTT integration is not available\")\n        return False\n\n    conf: ConfigType = config[DOMAIN]\n    publish_filter = convert_include_exclude_filter(conf)\n    base_topic: str = conf[CONF_BASE_TOPIC]\n    publish_attributes: bool = conf[CONF_PUBLISH_ATTRIBUTES]\n    publish_timestamps: bool = conf[CONF_PUBLISH_TIMESTAMPS]\n    if not base_topic.endswith(\"/\"):\n        base_topic = f\"{base_topic}/\"\n\n    async def _state_publisher(evt: Event[EventStateChangedData]) -> None:\n        entity_id = evt.data[\"entity_id\"]\n        new_state = evt.data[\"new_state\"]\n        assert new_state\n\n        payload = new_state.state\n\n        mybase = f\"{base_topic}{entity_id.replace('.', '/')}/\"\n        await mqtt.async_publish(hass, f\"{mybase}state\", payload, 1, True)\n\n        if publish_timestamps:\n            if new_state.last_updated:\n                await mqtt.async_publish(\n                    hass,\n                    f\"{mybase}last_updated\",\n                    new_state.last_updated.isoformat(),\n                    1,\n                    True,\n                )\n            if new_state.last_changed:\n                await mqtt.async_publish(\n                    hass,\n                    f\"{mybase}last_changed\",\n                    new_state.last_changed.isoformat(),\n                    1,\n                    True,\n                )\n\n        if publish_attributes:\n            for key, val in new_state.attributes.items():\n                encoded_val = json.dumps(val, cls=JSONEncoder)\n                await mqtt.async_publish(hass, mybase + key, encoded_val, 1, True)\n\n    @callback\n    def _ha_started(hass: HomeAssistant) -> None:\n        @callback\n        def _event_filter(event_data: EventStateChangedData) -> bool:\n            entity_id = event_data[\"entity_id\"]\n            new_state = event_data[\"new_state\"]\n            if new_state is None:\n                return False\n            if not publish_filter(entity_id):\n                return False\n            return True\n\n        callback_handler = hass.bus.async_listen(\n            EVENT_STATE_CHANGED, _state_publisher, _event_filter\n        )\n\n        @callback\n        def _ha_stopping(_: Event) -> None:\n            callback_handler()\n\n        hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, _ha_stopping)\n\n    async_at_start(hass, _ha_started)\n\n    return True\n",
    "homeassistant/components/speedtestdotnet/__init__.py": "\"\"\"Support for testing internet speed via Speedtest.net.\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import partial\n\nimport speedtest\n\nfrom homeassistant.config_entries import ConfigEntryState\nfrom homeassistant.const import Platform\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.exceptions import ConfigEntryNotReady\nfrom homeassistant.helpers.start import async_at_started\n\nfrom .coordinator import SpeedTestConfigEntry, SpeedTestDataCoordinator\n\nPLATFORMS = [Platform.SENSOR]\n\n\nasync def async_setup_entry(\n    hass: HomeAssistant, config_entry: SpeedTestConfigEntry\n) -> bool:\n    \"\"\"Set up the Speedtest.net component.\"\"\"\n    try:\n        api = await hass.async_add_executor_job(\n            partial(speedtest.Speedtest, secure=True)\n        )\n        coordinator = SpeedTestDataCoordinator(hass, config_entry, api)\n    except speedtest.SpeedtestException as err:\n        raise ConfigEntryNotReady from err\n\n    config_entry.runtime_data = coordinator\n\n    async def _async_finish_startup(hass: HomeAssistant) -> None:\n        \"\"\"Run this only when HA has finished its startup.\"\"\"\n        if config_entry.state is ConfigEntryState.LOADED:\n            await coordinator.async_refresh()\n        else:\n            await coordinator.async_config_entry_first_refresh()\n\n    # Don't start a speedtest during startup\n    async_at_started(hass, _async_finish_startup)\n\n    await hass.config_entries.async_forward_entry_setups(config_entry, PLATFORMS)\n    config_entry.async_on_unload(config_entry.add_update_listener(update_listener))\n\n    return True\n\n\nasync def async_unload_entry(\n    hass: HomeAssistant, config_entry: SpeedTestConfigEntry\n) -> bool:\n    \"\"\"Unload SpeedTest Entry from config_entry.\"\"\"\n    return await hass.config_entries.async_unload_platforms(config_entry, PLATFORMS)\n\n\nasync def update_listener(\n    hass: HomeAssistant, config_entry: SpeedTestConfigEntry\n) -> None:\n    \"\"\"Handle options update.\"\"\"\n    await hass.config_entries.async_reload(config_entry.entry_id)\n",
    "homeassistant/components/speedtestdotnet/config_flow.py": "\"\"\"Config flow for Speedtest.net.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport voluptuous as vol\n\nfrom homeassistant.config_entries import ConfigFlow, ConfigFlowResult, OptionsFlow\nfrom homeassistant.core import callback\n\nfrom .const import (\n    CONF_SERVER_ID,\n    CONF_SERVER_NAME,\n    DEFAULT_NAME,\n    DEFAULT_SERVER,\n    DOMAIN,\n)\nfrom .coordinator import SpeedTestConfigEntry\n\n\nclass SpeedTestFlowHandler(ConfigFlow, domain=DOMAIN):\n    \"\"\"Handle Speedtest.net config flow.\"\"\"\n\n    VERSION = 1\n\n    @staticmethod\n    @callback\n    def async_get_options_flow(\n        config_entry: SpeedTestConfigEntry,\n    ) -> SpeedTestOptionsFlowHandler:\n        \"\"\"Get the options flow for this handler.\"\"\"\n        return SpeedTestOptionsFlowHandler()\n\n    async def async_step_user(\n        self, user_input: dict[str, Any] | None = None\n    ) -> ConfigFlowResult:\n        \"\"\"Handle a flow initialized by the user.\"\"\"\n        if self._async_current_entries():\n            return self.async_abort(reason=\"single_instance_allowed\")\n\n        if user_input is None:\n            return self.async_show_form(step_id=\"user\")\n\n        return self.async_create_entry(title=DEFAULT_NAME, data=user_input)\n\n\nclass SpeedTestOptionsFlowHandler(OptionsFlow):\n    \"\"\"Handle SpeedTest options.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize options flow.\"\"\"\n        self._servers: dict = {}\n\n    async def async_step_init(\n        self, user_input: dict[str, Any] | None = None\n    ) -> ConfigFlowResult:\n        \"\"\"Manage the options.\"\"\"\n        errors: dict[str, str] = {}\n\n        if user_input is not None:\n            server_name = user_input[CONF_SERVER_NAME]\n            if server_name != \"*Auto Detect\":\n                server_id = self._servers[server_name][\"id\"]\n                user_input[CONF_SERVER_ID] = server_id\n            else:\n                user_input[CONF_SERVER_ID] = None\n\n            return self.async_create_entry(title=\"\", data=user_input)\n\n        self._servers = self.config_entry.runtime_data.servers\n\n        options = {\n            vol.Optional(\n                CONF_SERVER_NAME,\n                default=self.config_entry.options.get(CONF_SERVER_NAME, DEFAULT_SERVER),\n            ): vol.In(self._servers.keys()),\n        }\n\n        return self.async_show_form(\n            step_id=\"init\", data_schema=vol.Schema(options), errors=errors\n        )\n",
    "homeassistant/components/speedtestdotnet/const.py": "\"\"\"Constants used by Speedtest.net.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Final\n\nDOMAIN: Final = \"speedtestdotnet\"\n\nCONF_SERVER_NAME: Final = \"server_name\"\nCONF_SERVER_ID: Final = \"server_id\"\n\nATTR_BYTES_RECEIVED: Final = \"bytes_received\"\nATTR_BYTES_SENT: Final = \"bytes_sent\"\nATTR_SERVER_COUNTRY: Final = \"server_country\"\nATTR_SERVER_ID: Final = \"server_id\"\nATTR_SERVER_NAME: Final = \"server_name\"\n\n\nDEFAULT_NAME: Final = \"SpeedTest\"\nDEFAULT_SCAN_INTERVAL: Final = 60\nDEFAULT_SERVER: Final = \"*Auto Detect\"\n\nATTRIBUTION: Final = \"Data retrieved from Speedtest.net by Ookla\"\n",
    "homeassistant/components/speedtestdotnet/coordinator.py": "\"\"\"Coordinator for speedtestdotnet.\"\"\"\n\nfrom datetime import timedelta\nimport logging\nfrom typing import Any, cast\n\nimport speedtest\n\nfrom homeassistant.config_entries import ConfigEntry\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n\nfrom .const import CONF_SERVER_ID, DEFAULT_SCAN_INTERVAL, DEFAULT_SERVER, DOMAIN\n\n_LOGGER = logging.getLogger(__name__)\n\ntype SpeedTestConfigEntry = ConfigEntry[SpeedTestDataCoordinator]\n\n\nclass SpeedTestDataCoordinator(DataUpdateCoordinator[dict[str, Any]]):\n    \"\"\"Get the latest data from speedtest.net.\"\"\"\n\n    config_entry: SpeedTestConfigEntry\n\n    def __init__(\n        self,\n        hass: HomeAssistant,\n        config_entry: SpeedTestConfigEntry,\n        api: speedtest.Speedtest,\n    ) -> None:\n        \"\"\"Initialize the data object.\"\"\"\n        self.hass = hass\n        self.api = api\n        self.servers: dict[str, dict] = {DEFAULT_SERVER: {}}\n        super().__init__(\n            self.hass,\n            _LOGGER,\n            config_entry=config_entry,\n            name=DOMAIN,\n            update_interval=timedelta(minutes=DEFAULT_SCAN_INTERVAL),\n        )\n\n    def update_servers(self) -> None:\n        \"\"\"Update list of test servers.\"\"\"\n        test_servers = self.api.get_servers()\n        test_servers_list = [\n            server for servers in test_servers.values() for server in servers\n        ]\n        for server in sorted(\n            test_servers_list,\n            key=lambda server: (\n                server[\"country\"],\n                server[\"name\"],\n                server[\"sponsor\"],\n            ),\n        ):\n            self.servers[\n                f\"{server['country']} - {server['sponsor']} - {server['name']}\"\n            ] = server\n\n    def update_data(self) -> dict[str, Any]:\n        \"\"\"Get the latest data from speedtest.net.\"\"\"\n        self.update_servers()\n        self.api.closest.clear()\n        if self.config_entry.options.get(CONF_SERVER_ID):\n            server_id = self.config_entry.options.get(CONF_SERVER_ID)\n            self.api.get_servers(servers=[server_id])\n\n        best_server = self.api.get_best_server()\n        _LOGGER.debug(\n            \"Executing speedtest.net speed test with server_id: %s\",\n            best_server[\"id\"],\n        )\n        self.api.download()\n        self.api.upload()\n        return cast(dict[str, Any], self.api.results.dict())\n\n    async def _async_update_data(self) -> dict[str, Any]:\n        \"\"\"Update Speedtest data.\"\"\"\n        try:\n            return await self.hass.async_add_executor_job(self.update_data)\n        except speedtest.NoMatchedServers as err:\n            raise UpdateFailed(\"Selected server is not found.\") from err\n        except speedtest.SpeedtestException as err:\n            raise UpdateFailed(err) from err\n",
    "homeassistant/components/speedtestdotnet/sensor.py": "\"\"\"Support for Speedtest.net internet speed testing sensor.\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\nfrom typing import Any, cast\n\nfrom homeassistant.components.sensor import (\n    SensorDeviceClass,\n    SensorEntity,\n    SensorEntityDescription,\n    SensorStateClass,\n)\nfrom homeassistant.const import UnitOfDataRate, UnitOfTime\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.helpers.device_registry import DeviceEntryType, DeviceInfo\nfrom homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback\nfrom homeassistant.helpers.typing import StateType\nfrom homeassistant.helpers.update_coordinator import CoordinatorEntity\n\nfrom .const import (\n    ATTR_BYTES_RECEIVED,\n    ATTR_BYTES_SENT,\n    ATTR_SERVER_COUNTRY,\n    ATTR_SERVER_ID,\n    ATTR_SERVER_NAME,\n    ATTRIBUTION,\n    DEFAULT_NAME,\n    DOMAIN,\n)\nfrom .coordinator import SpeedTestConfigEntry, SpeedTestDataCoordinator\n\n\n@dataclass(frozen=True)\nclass SpeedtestSensorEntityDescription(SensorEntityDescription):\n    \"\"\"Class describing Speedtest sensor entities.\"\"\"\n\n    value: Callable = round\n\n\nSENSOR_TYPES: tuple[SpeedtestSensorEntityDescription, ...] = (\n    SpeedtestSensorEntityDescription(\n        key=\"ping\",\n        translation_key=\"ping\",\n        native_unit_of_measurement=UnitOfTime.MILLISECONDS,\n        state_class=SensorStateClass.MEASUREMENT,\n        device_class=SensorDeviceClass.DURATION,\n    ),\n    SpeedtestSensorEntityDescription(\n        key=\"download\",\n        translation_key=\"download\",\n        native_unit_of_measurement=UnitOfDataRate.MEGABITS_PER_SECOND,\n        state_class=SensorStateClass.MEASUREMENT,\n        device_class=SensorDeviceClass.DATA_RATE,\n        value=lambda value: round(value / 10**6, 2),\n    ),\n    SpeedtestSensorEntityDescription(\n        key=\"upload\",\n        translation_key=\"upload\",\n        native_unit_of_measurement=UnitOfDataRate.MEGABITS_PER_SECOND,\n        state_class=SensorStateClass.MEASUREMENT,\n        device_class=SensorDeviceClass.DATA_RATE,\n        value=lambda value: round(value / 10**6, 2),\n    ),\n)\n\n\nasync def async_setup_entry(\n    hass: HomeAssistant,\n    config_entry: SpeedTestConfigEntry,\n    async_add_entities: AddConfigEntryEntitiesCallback,\n) -> None:\n    \"\"\"Set up the Speedtestdotnet sensors.\"\"\"\n    speedtest_coordinator = config_entry.runtime_data\n    async_add_entities(\n        SpeedtestSensor(speedtest_coordinator, description)\n        for description in SENSOR_TYPES\n    )\n\n\nclass SpeedtestSensor(CoordinatorEntity[SpeedTestDataCoordinator], SensorEntity):\n    \"\"\"Implementation of a speedtest.net sensor.\"\"\"\n\n    entity_description: SpeedtestSensorEntityDescription\n    _attr_attribution = ATTRIBUTION\n    _attr_has_entity_name = True\n\n    def __init__(\n        self,\n        coordinator: SpeedTestDataCoordinator,\n        description: SpeedtestSensorEntityDescription,\n    ) -> None:\n        \"\"\"Initialize the sensor.\"\"\"\n        super().__init__(coordinator)\n        self.entity_description = description\n        self._attr_unique_id = description.key\n        self._state: StateType = None\n        self._attrs: dict[str, Any] = {}\n        self._attr_device_info = DeviceInfo(\n            identifiers={(DOMAIN, self.coordinator.config_entry.entry_id)},\n            name=DEFAULT_NAME,\n            entry_type=DeviceEntryType.SERVICE,\n            configuration_url=\"https://www.speedtest.net/\",\n        )\n\n    @property\n    def native_value(self) -> StateType:\n        \"\"\"Return native value for entity.\"\"\"\n        if self.coordinator.data:\n            state = self.coordinator.data[self.entity_description.key]\n            self._state = cast(StateType, self.entity_description.value(state))\n        return self._state\n\n    @property\n    def extra_state_attributes(self) -> dict[str, Any]:\n        \"\"\"Return the state attributes.\"\"\"\n        if self.coordinator.data:\n            self._attrs.update(\n                {\n                    ATTR_SERVER_NAME: self.coordinator.data[\"server\"][\"name\"],\n                    ATTR_SERVER_COUNTRY: self.coordinator.data[\"server\"][\"country\"],\n                    ATTR_SERVER_ID: self.coordinator.data[\"server\"][\"id\"],\n                }\n            )\n\n            if self.entity_description.key == \"download\":\n                self._attrs[ATTR_BYTES_RECEIVED] = self.coordinator.data[\n                    ATTR_BYTES_RECEIVED\n                ]\n            elif self.entity_description.key == \"upload\":\n                self._attrs[ATTR_BYTES_SENT] = self.coordinator.data[ATTR_BYTES_SENT]\n\n        return self._attrs\n",
    "script/hassfest/quality_scale_validation/test_before_setup.py": "\"\"\"Enforce that the integration raises correctly during initialisation.\n\nhttps://developers.home-assistant.io/docs/core/integration-quality-scale/rules/test-before-setup/\n\"\"\"\n\nimport ast\n\nfrom script.hassfest import ast_parse_module\nfrom script.hassfest.model import Config, Integration\n\n_VALID_EXCEPTIONS = {\n    \"ConfigEntryNotReady\",\n    \"ConfigEntryAuthFailed\",\n    \"ConfigEntryError\",\n}\n\n\ndef _get_exception_name(expression: ast.expr) -> str:\n    \"\"\"Get the name of the exception being raised.\"\"\"\n    if expression is None:\n        # Bare raise\n        return None\n\n    if isinstance(expression, ast.Name):\n        # Raise Exception\n        return expression.id\n\n    if isinstance(expression, ast.Call):\n        # Raise Exception()\n        return _get_exception_name(expression.func)\n\n    if isinstance(expression, ast.Attribute):\n        # Raise namespace.???\n        return _get_exception_name(expression.value)\n\n    raise AssertionError(\n        f\"Raise is neither Attribute nor Call nor Name: {type(expression)}\"\n    )\n\n\ndef _raises_exception(integration: Integration) -> bool:\n    \"\"\"Check that a valid exception is raised.\"\"\"\n    for module_file in integration.path.rglob(\"*.py\"):\n        module = ast_parse_module(module_file)\n        for node in ast.walk(module):\n            if (\n                isinstance(node, ast.Raise)\n                and _get_exception_name(node.exc) in _VALID_EXCEPTIONS\n            ):\n                return True\n\n    return False\n\n\ndef _calls_first_refresh(async_setup_entry_function: ast.AsyncFunctionDef) -> bool:\n    \"\"\"Check that a async_config_entry_first_refresh within `async_setup_entry`.\"\"\"\n    for node in ast.walk(async_setup_entry_function):\n        if (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Attribute)\n            and node.func.attr == \"async_config_entry_first_refresh\"\n        ):\n            return True\n\n    return False\n\n\ndef _get_setup_entry_function(module: ast.Module) -> ast.AsyncFunctionDef | None:\n    \"\"\"Get async_setup_entry function.\"\"\"\n    for item in module.body:\n        if isinstance(item, ast.AsyncFunctionDef) and item.name == \"async_setup_entry\":\n            return item\n    return None\n\n\ndef validate(\n    config: Config, integration: Integration, *, rules_done: set[str]\n) -> list[str] | None:\n    \"\"\"Validate correct use of ConfigEntry.runtime_data.\"\"\"\n    init_file = integration.path / \"__init__.py\"\n    init = ast_parse_module(init_file)\n\n    # Should not happen, but better to be safe\n    if not (async_setup_entry := _get_setup_entry_function(init)):\n        return [f\"Could not find `async_setup_entry` in {init_file}\"]\n\n    if not (_calls_first_refresh(async_setup_entry) or _raises_exception(integration)):\n        return [f\"Integration does not raise one of {_VALID_EXCEPTIONS}\"]\n    return None\n",
    "script/lint_and_test.py": "#!/usr/bin/env python3\n\"\"\"Quickly check if branch is up to PR standards.\n\nThis is NOT a full CI/linting replacement, only a quick check during development.\n\"\"\"\n\nimport asyncio\nfrom collections import namedtuple\nfrom contextlib import suppress\nimport itertools\nimport os\nfrom pathlib import Path\nimport re\nimport shlex\nimport sys\n\ntry:\n    from colorlog.escape_codes import escape_codes\nexcept ImportError:\n    escape_codes = None\n\n\nRE_ASCII = re.compile(r\"\\033\\[[^m]*m\")\nError = namedtuple(\"Error\", [\"file\", \"line\", \"col\", \"msg\", \"skip\"])  # noqa: PYI024\n\nPASS = \"green\"\nFAIL = \"bold_red\"\n\n\ndef printc(the_color, *args):\n    \"\"\"Color print helper.\"\"\"\n    msg = \" \".join(args)\n    if not escape_codes:\n        print(msg)\n        return\n    try:\n        print(escape_codes[the_color] + msg + escape_codes[\"reset\"])\n    except KeyError as err:\n        print(msg)\n        raise ValueError(f\"Invalid color {the_color}\") from err\n\n\ndef validate_requirements_ok():\n    \"\"\"Validate requirements, returns True of ok.\"\"\"\n    # pylint: disable-next=import-outside-toplevel\n    from gen_requirements_all import main as req_main\n\n    return req_main(True) == 0\n\n\nasync def read_stream(stream, display):\n    \"\"\"Read from stream line by line until EOF, display, and capture lines.\"\"\"\n    output = []\n    while True:\n        line = await stream.readline()\n        if not line:\n            break\n        output.append(line)\n        display(line.decode())  # assume it doesn't block\n    return b\"\".join(output)\n\n\nasync def async_exec(*args, display=False):\n    \"\"\"Execute, return code & log.\"\"\"\n    argsp = []\n    for arg in args:\n        if Path(arg).is_file():\n            argsp.append(f\"\\\\\\n  {shlex.quote(arg)}\")\n        else:\n            argsp.append(shlex.quote(arg))\n    printc(\"cyan\", *argsp)\n    try:\n        kwargs = {\n            \"stdout\": asyncio.subprocess.PIPE,\n            \"stderr\": asyncio.subprocess.STDOUT,\n        }\n        if display:\n            kwargs[\"stderr\"] = asyncio.subprocess.PIPE\n        proc = await asyncio.create_subprocess_exec(*args, **kwargs)\n    except FileNotFoundError:\n        printc(FAIL, f\"Could not execute {args[0]}. Did you install test requirements?\")\n        raise\n\n    if not display:\n        # Reading stdout into log\n        stdout, _ = await proc.communicate()\n    else:\n        # read child's stdout/stderr concurrently (capture and display)\n        stdout, _ = await asyncio.gather(\n            read_stream(proc.stdout, sys.stdout.write),\n            read_stream(proc.stderr, sys.stderr.write),\n        )\n    exit_code = await proc.wait()\n    stdout = stdout.decode(\"utf-8\")\n    return exit_code, stdout\n\n\nasync def git():\n    \"\"\"Exec git.\"\"\"\n    if len(sys.argv) > 2 and sys.argv[1] == \"--\":\n        return sys.argv[2:]\n    _, log = await async_exec(\"git\", \"merge-base\", \"upstream/dev\", \"HEAD\")\n    merge_base = log.splitlines()[0]\n    _, log = await async_exec(\"git\", \"diff\", merge_base, \"--name-only\")\n    return log.splitlines()\n\n\nasync def pylint(files):\n    \"\"\"Exec pylint.\"\"\"\n    _, log = await async_exec(\"pylint\", \"-f\", \"parseable\", \"--persistent=n\", *files)\n    res = []\n    for line in log.splitlines():\n        line = line.split(\":\")\n        if len(line) < 3:\n            continue\n        _fn = line[0].replace(\"\\\\\", \"/\")\n        res.append(Error(_fn, line[1], \"\", line[2].strip(), _fn.startswith(\"tests/\")))\n    return res\n\n\nasync def ruff(files):\n    \"\"\"Exec ruff.\"\"\"\n    _, log = await async_exec(\"pre-commit\", \"run\", \"ruff\", \"--files\", *files)\n    res = []\n    for line in log.splitlines():\n        line = line.split(\":\")\n        if len(line) < 4:\n            continue\n        _fn = line[0].replace(\"\\\\\", \"/\")\n        res.append(Error(_fn, line[1], line[2], line[3].strip(), False))\n    return res\n\n\nasync def lint(files):\n    \"\"\"Perform lint.\"\"\"\n    files = [file for file in files if Path(file).is_file()]\n    res = sorted(\n        itertools.chain(\n            *await asyncio.gather(\n                pylint(files),\n                ruff(files),\n            )\n        ),\n        key=lambda item: item.file,\n    )\n    if res:\n        print(\"Lint errors:\")\n    else:\n        printc(PASS, \"Lint passed\")\n\n    lint_ok = True\n    for err in res:\n        err_msg = f\"{err.file} {err.line}:{err.col} {err.msg}\"\n\n        # tests/* does not have to pass lint\n        if err.skip:\n            print(err_msg)\n        else:\n            printc(FAIL, err_msg)\n            lint_ok = False\n\n    return lint_ok\n\n\nasync def main():\n    \"\"\"Run the main loop.\"\"\"\n    # Ensure we are in the homeassistant root\n    os.chdir(Path(__file__).parent.parent)\n\n    files = await git()\n    if not files:\n        print(\n            \"No changed files found. Please ensure you have added your \"\n            \"changes with git add & git commit\"\n        )\n        return\n\n    pyfiles = [file for file in files if file.endswith(\".py\")]\n\n    print(\"=============================\")\n    printc(\"bold\", \"CHANGED FILES:\\n\", \"\\n \".join(pyfiles))\n    print(\"=============================\")\n\n    skip_lint = len(sys.argv) > 1 and sys.argv[1] == \"--skiplint\"\n    if skip_lint:\n        printc(FAIL, \"LINT DISABLED\")\n    elif not await lint(pyfiles):\n        printc(FAIL, \"Please fix your lint issues before continuing\")\n        return\n\n    test_files = set()\n    gen_req = False\n    for fname in pyfiles:\n        if fname.startswith(\"homeassistant/components/\"):\n            gen_req = True  # requirements script for components\n        # Find test files...\n        if fname.startswith(\"tests/\"):\n            if \"/test_\" in fname and Path(fname).is_file():\n                # All test helpers should be excluded\n                test_files.add(fname)\n        else:\n            parts = fname.split(\"/\")\n            parts[0] = \"tests\"\n            if parts[-1] == \"__init__.py\":\n                parts[-1] = \"test_init.py\"\n            elif parts[-1] == \"__main__.py\":\n                parts[-1] = \"test_main.py\"\n            else:\n                parts[-1] = f\"test_{parts[-1]}\"\n            fname = \"/\".join(parts)\n            if Path(fname).is_file():\n                test_files.add(fname)\n\n    if gen_req:\n        print(\"=============================\")\n        if validate_requirements_ok():\n            printc(PASS, \"script/gen_requirements.py passed\")\n        else:\n            printc(FAIL, \"Please run script/gen_requirements.py\")\n            return\n\n    print(\"=============================\")\n    if not test_files:\n        print(\"No test files identified\")\n        return\n\n    code, _ = await async_exec(\n        \"python3\",\n        \"-b\",\n        \"-m\",\n        \"pytest\",\n        \"-vv\",\n        \"--force-sugar\",\n        \"--\",\n        *test_files,\n        display=True,\n    )\n    print(\"=============================\")\n\n    if code == 0:\n        printc(PASS, \"Yay! This will most likely pass CI\")\n    else:\n        printc(FAIL, \"Tests not passing\")\n\n    if skip_lint:\n        printc(FAIL, \"LINT DISABLED\")\n\n\nif __name__ == \"__main__\":\n    with suppress(FileNotFoundError, KeyboardInterrupt):\n        asyncio.run(main())\n",
    "script/scaffold/templates/backup/tests/test_backup.py": "\"\"\"Test the NEW_NAME backup platform.\"\"\"\n\nfrom homeassistant.components.NEW_DOMAIN.backup import (\n    async_post_backup,\n    async_pre_backup,\n)\nfrom homeassistant.core import HomeAssistant\n\n\nasync def test_async_post_backup(hass: HomeAssistant) -> None:\n    \"\"\"Verify async_post_backup.\"\"\"\n    # TODO: verify that the async_post_backup function executes as expected\n    assert await async_post_backup(hass)\n\n\nasync def test_async_pre_backup(hass: HomeAssistant) -> None:\n    \"\"\"Verify async_pre_backup.\"\"\"\n    # TODO: verify that the async_pre_backup function executes as expected\n    assert await async_pre_backup(hass)\n"
  },
  "requirements": "# Automatically generated by gen_requirements_all.py, do not edit\n\n-c homeassistant/package_constraints.txt\n\n# Home Assistant Core\naiodns==3.2.0\naiohasupervisor==0.3.0\naiohttp==3.11.14\naiohttp_cors==0.7.0\naiohttp-fast-zlib==0.2.3\naiohttp-asyncmdnsresolver==0.1.1\naiozoneinfo==0.2.3\nannotatedyaml==0.2.0\nastral==2.2\nasync-interrupt==1.2.2\nattrs==25.1.0\natomicwrites-homeassistant==1.4.1\naudioop-lts==0.2.1\nawesomeversion==24.6.0\nbcrypt==4.2.0\ncertifi>=2021.5.30\nciso8601==2.3.2\ncronsim==2.6\nfnv-hash-fast==1.4.0\nhass-nabucasa==0.94.0\nhttpx==0.28.1\nhome-assistant-bluetooth==1.13.1\nifaddr==0.2.0\nJinja2==3.1.6\nlru-dict==1.3.0\nPyJWT==2.10.1\ncryptography==44.0.1\nPillow==11.1.0\npropcache==0.3.0\npyOpenSSL==25.0.0\norjson==3.10.15\npackaging>=23.1\npsutil-home-assistant==0.0.1\npython-slugify==8.0.4\nPyYAML==6.0.2\nrequests==2.32.3\nsecuretar==2025.2.1\nSQLAlchemy==2.0.39\nstandard-aifc==3.13.0\nstandard-telnetlib==3.13.0\ntyping-extensions>=4.12.2,<5.0\nulid-transform==1.4.0\nurllib3>=1.26.5,<2\nuv==0.6.1\nvoluptuous==0.15.2\nvoluptuous-serialize==2.6.0\nvoluptuous-openapi==0.0.6\nyarl==1.18.3\nwebrtc-models==0.3.0\nzeroconf==0.146.0\n"
}