{
  "repo_name": "3b1b/manim",
  "repo_url": "https://github.com/3b1b/manim",
  "description": "Animation engine for explanatory math videos",
  "stars": 76190,
  "language": "Python",
  "created_at": "2015-03-22T18:50:58Z",
  "updated_at": "2025-03-19T07:00:40Z",
  "files": {
    "docs/example.py": "from manimlib import *\n\nclass SquareToCircle(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        # Try typing the following lines\n        # self.play(circle.animate.stretch(4, dim=0))\n        # self.play(Rotate(circle, TAU / 4))\n        # self.play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n        # circle.insert_n_curves(10)\n        # self.play(circle.animate.apply_complex_function(lambda z: z**2))\n\nclass SquareToCircleEmbed(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n\n        self.add(circle)\n        self.wait()\n        self.play(circle.animate.stretch(4, dim=0))\n        self.wait(1.5)\n        self.play(Rotate(circle, TAU / 4))\n        self.wait(1.5)\n        self.play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))\n        self.wait(1.5)\n        circle.insert_n_curves(10)\n        self.play(circle.animate.apply_complex_function(lambda z: z**2))\n        self.wait(2)\n",
    "docs/source/conf.py": "import os\nimport sys\nsys.path.insert(0, os.path.abspath(\".\"))\nsys.path.insert(0, os.path.abspath('../../'))\n\n\nproject = 'manim'\ncopyright = '- This document has been placed in the public domain.'\nauthor = 'TonyCrane'\n\nrelease = ''\n\nextensions = [\n    'sphinx.ext.todo',\n    'sphinx.ext.githubpages',\n    'sphinx.ext.mathjax',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.autodoc', \n    'sphinx.ext.coverage',\n    'sphinx.ext.napoleon',\n    'sphinx_copybutton',\n    'manim_example_ext'\n]\n\nautoclass_content = 'both'\nmathjax_path = \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"\n\ntemplates_path = ['_templates']\nsource_suffix = '.rst'\nmaster_doc = 'index'\npygments_style = 'default'\n\nhtml_static_path = [\"_static\"]\nhtml_css_files = [\n    \"https://cdn.jsdelivr.net/gh/manim-kindergarten/CDN@master/manimgl_assets/custom.css\", \n    \"https://cdn.jsdelivr.net/gh/manim-kindergarten/CDN@master/manimgl_assets/colors.css\"\n]\nhtml_theme = 'furo'  # pip install furo==2020.10.5b9\nhtml_favicon = '_static/icon.png'\nhtml_logo = '../../logo/transparent_graph.png'\nhtml_theme_options = {\n    \"sidebar_hide_name\": True,\n}\n",
    "docs/source/manim_example_ext.py": "from docutils import nodes\nfrom docutils.parsers.rst import directives, Directive\n\nimport jinja2\nimport os\n\n\nclass skip_manim_node(nodes.Admonition, nodes.Element):\n    pass\n\n\ndef visit(self, node, name=\"\"):\n    self.visit_admonition(node, name)\n\n\ndef depart(self, node):\n    self.depart_admonition(node)\n\n\nclass ManimExampleDirective(Directive):\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    option_spec = {\n        \"hide_code\": bool,\n        \"media\": str,\n    }\n    final_argument_whitespace = True\n\n    def run(self):\n        hide_code = \"hide_code\" in self.options\n        scene_name = self.arguments[0]\n        media_file_name = self.options[\"media\"]\n\n        source_block = [\n            \".. code-block:: python\",\n            \"\",\n            *[\"    \" + line for line in self.content],\n        ]\n        source_block = \"\\n\".join(source_block)\n\n        state_machine = self.state_machine\n        document = state_machine.document\n\n        if any(media_file_name.endswith(ext) for ext in [\".png\", \".jpg\", \".gif\"]):\n            is_video = False\n        else:\n            is_video = True\n\n        rendered_template = jinja2.Template(TEMPLATE).render(\n            scene_name=scene_name,\n            scene_name_lowercase=scene_name.lower(),\n            hide_code=hide_code,\n            is_video=is_video,\n            media_file_name=media_file_name,\n            source_block=source_block,\n        )\n        state_machine.insert_input(\n            rendered_template.split(\"\\n\"), source=document.attributes[\"source\"]\n        )\n\n        return []\n\n\ndef setup(app):\n    app.add_node(skip_manim_node, html=(visit, depart))\n\n    setup.app = app\n    setup.config = app.config\n    setup.confdir = app.confdir\n\n    app.add_directive(\"manim-example\", ManimExampleDirective)\n\n    metadata = {\"parallel_read_safe\": False, \"parallel_write_safe\": True}\n    return metadata\n\n\nTEMPLATE = r\"\"\"\n{% if not hide_code %}\n\n.. raw:: html\n\n    <div class=\"manim-example\">\n\n{% endif %}\n\n{% if is_video %}\n.. raw:: html\n\n    <video id=\"{{ scene_name_lowercase }}\" class=\"manim-video\" controls loop autoplay src=\"{{ media_file_name }}\"></video>\n{% else %}\n.. image:: {{ media_file_name }}\n    :align: center\n    :name: {{ scene_name_lowercase }}\n{% endif %}\n\n{% if not hide_code %}\n.. raw:: html\n\n    <h5 class=\"example-header\">{{ scene_name }}<a class=\"headerlink\" href=\"#{{ scene_name_lowercase }}\">Â¶</a></h5>\n\n{{ source_block }}\n{% endif %}\n\n.. raw:: html\n\n    </div>\n\"\"\"",
    "example_scenes.py": "from manimlib import *\nimport numpy as np\n\n# To watch one of these scenes, run the following:\n# manimgl example_scenes.py OpeningManimExample\n# Use -s to skip to the end and just save the final frame\n# Use -w to write the animation to a file\n# Use -o to write it to a file and open it once done\n# Use -n <number> to skip ahead to the n'th animation of a scene.\n\n\nclass OpeningManimExample(Scene):\n    def construct(self):\n        intro_words = Text(\"\"\"\n            The original motivation for manim was to\n            better illustrate mathematical functions\n            as transformations.\n        \"\"\")\n        intro_words.to_edge(UP)\n\n        self.play(Write(intro_words))\n        self.wait(2)\n\n        # Linear transform\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(\n            Text(\"This is what the matrix\"),\n            IntegerMatrix(matrix),\n            Text(\"looks like\")\n        )\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_backstroke(width=5)\n\n        self.play(\n            ShowCreation(grid),\n            FadeTransform(intro_words, linear_transform_words)\n        )\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n\n        # Complex map\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText(\"\"\"\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\n        \"\"\")\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_backstroke(width=5)\n\n        self.play(\n            FadeOut(grid),\n            Write(c_grid, run_time=3),\n            FadeIn(moving_c_grid),\n            FadeTransform(linear_transform_words, complex_map_words),\n        )\n        self.wait()\n        self.play(\n            moving_c_grid.animate.apply_complex_function(lambda z: z**2),\n            run_time=6,\n        )\n        self.wait(2)\n\n\nclass AnimatingMethods(Scene):\n    def construct(self):\n        grid = Tex(R\"\\pi\").get_grid(10, 10, height=4)\n        self.add(grid)\n\n        # You can animate the application of mobject methods with the\n        # \".animate\" syntax:\n        self.play(grid.animate.shift(LEFT))\n\n        # Both of those will interpolate between the mobject's initial\n        # state and whatever happens when you apply that method.\n        # For this example, calling grid.shift(LEFT) would shift the\n        # grid one unit to the left, but both of the previous calls to\n        # \"self.play\" animate that motion.\n\n        # The same applies for any method, including those setting colors.\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n\n        # The method Mobject.apply_complex_function lets you apply arbitrary\n        # complex functions, treating the points defining the mobject as\n        # complex numbers.\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n\n        # Even more generally, you could apply Mobject.apply_function,\n        # which takes in functions form R^3 to R^3\n        self.play(\n            grid.animate.apply_function(\n                lambda p: [\n                    p[0] + 0.5 * math.sin(p[1]),\n                    p[1] + 0.5 * math.sin(p[0]),\n                    p[2]\n                ]\n            ),\n            run_time=5,\n        )\n        self.wait()\n\n\nclass TextExample(Scene):\n    def construct(self):\n        # To run this scene properly, you should have \"Consolas\" font in your computer\n        # for full usage, you can see https://github.com/3b1b/manim/pull/680\n        text = Text(\"Here is a text\", font=\"Consolas\", font_size=90)\n        difference = Text(\n            \"\"\"\n            The most important difference between Text and TexText is that\\n\n            you can change the font more easily, but can't use the LaTeX grammar\n            \"\"\",\n            font=\"Arial\", font_size=24,\n            # t2c is a dict that you can choose color for different text\n            t2c={\"Text\": BLUE, \"TexText\": BLUE, \"LaTeX\": ORANGE}\n        )\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n\n        fonts = Text(\n            \"And you can also set the font according to different words\",\n            font=\"Arial\",\n            t2f={\"font\": \"Consolas\", \"words\": \"Consolas\"},\n            t2c={\"font\": BLUE, \"words\": GREEN}\n        )\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text(\n            \"And the same as slant and weight\",\n            font=\"Consolas\",\n            t2s={\"slant\": ITALIC},\n            t2w={\"weight\": BOLD},\n            t2c={\"slant\": ORANGE, \"weight\": RED}\n        )\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()\n\n\nclass TexTransformExample(Scene):\n    def construct(self):\n        # Tex to color map\n        t2c = {\n            \"A\": BLUE,\n            \"B\": TEAL,\n            \"C\": GREEN,\n        }\n        # Configuration to pass along to each Tex mobject\n        kw = dict(font_size=72, t2c=t2c)\n        lines = VGroup(\n            Tex(\"A^2 + B^2 = C^2\", **kw),\n            Tex(\"A^2 = C^2 - B^2\", **kw),\n            Tex(\"A^2 = (C + B)(C - B)\", **kw),\n            Tex(R\"A = \\sqrt{(C + B)(C - B)}\", **kw),\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n\n        self.add(lines[0])\n        # The animation TransformMatchingStrings will line up parts\n        # of the source and target which have matching substring strings.\n        # Here, giving it a little path_arc makes each part rotate into\n        # their final positions, which feels appropriate for the idea of\n        # rearranging an equation\n        self.play(\n            TransformMatchingStrings(\n                lines[0].copy(), lines[1],\n                # matched_keys specifies which substring should\n                # line up. If it's not specified, the animation\n                # will align the longest matching substrings.\n                # In this case, the substring \"^2 = C^2\" would\n                # trip it up\n                matched_keys=[\"A^2\", \"B^2\", \"C^2\"],\n                # When you want a substring from the source\n                # to go to a non-equal substring from the target,\n                # use the key map.\n                key_map={\"+\": \"-\"},\n                path_arc=90 * DEG,\n            ),\n        )\n        self.wait()\n        self.play(TransformMatchingStrings(\n            lines[1].copy(), lines[2],\n            matched_keys=[\"A^2\"]\n        ))\n        self.wait()\n        self.play(\n            TransformMatchingStrings(\n                lines[2].copy(), lines[3],\n                key_map={\"2\": R\"\\sqrt\"},\n                path_arc=-30 * DEG,\n            ),\n        )\n        self.wait(2)\n        self.play(LaggedStartMap(FadeOut, lines, shift=2 * RIGHT))\n\n        # TransformMatchingShapes will try to line up all pieces of a\n        # source mobject with those of a target, regardless of the\n        # what Mobject type they are.\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n        saved_source = source.copy()\n\n        self.play(Write(source))\n        self.wait()\n        kw = dict(run_time=3, path_arc=PI / 2)\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, saved_source, **kw))\n        self.wait()\n\n\nclass TexIndexing(Scene):\n    def construct(self):\n        # You can index into Tex mobject (or other StringMobjects) by substrings\n        equation = Tex(R\"e^{\\pi i} = -1\", font_size=144)\n\n        self.add(equation)\n        self.play(FlashAround(equation[\"e\"]))\n        self.wait()\n        self.play(Indicate(equation[R\"\\pi\"]))\n        self.wait()\n        self.play(TransformFromCopy(\n            equation[R\"e^{\\pi i}\"].copy().set_opacity(0.5),\n            equation[\"-1\"],\n            path_arc=-PI / 2,\n            run_time=3\n        ))\n        self.play(FadeOut(equation))\n\n        # Or regular expressions\n        equation = Tex(\"A^2 + B^2 = C^2\", font_size=144)\n\n        self.play(Write(equation))\n        for part in equation[re.compile(r\"\\w\\^2\")]:\n            self.play(FlashAround(part))\n        self.wait()\n        self.play(FadeOut(equation))\n        \n        # Indexing by substrings like this may not work when\n        # the order in which Latex draws symbols does not match\n        # the order in which they show up in the string.\n        # For example, here the infinity is drawn before the sigma\n        # so we don't get the desired behavior.\n        equation = Tex(R\"\\sum_{n = 1}^\\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6}\", font_size=72)\n        self.play(FadeIn(equation))\n        self.play(equation[R\"\\infty\"].animate.set_color(RED))  # Doesn't hit the infinity\n        self.wait()\n        self.play(FadeOut(equation))\n\n        # However you can always fix this by explicitly passing in\n        # a string you might want to isolate later. Also, using\n        # \\over instead of \\frac helps to avoid the issue for fractions\n        equation = Tex(\n            R\"\\sum_{n = 1}^\\infty {1 \\over n^2} = {\\pi^2 \\over 6}\",\n            # Explicitly mark \"\\infty\" as a substring you might want to access\n            isolate=[R\"\\infty\"],\n            font_size=72\n        )\n        self.play(FadeIn(equation))\n        self.play(equation[R\"\\infty\"].animate.set_color(RED))  # Got it!\n        self.wait()\n        self.play(FadeOut(equation))\n\n\nclass UpdatersExample(Scene):\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n\n        # On all frames, the constructor Brace(square, UP) will\n        # be called, and the mobject brace will set its data to match\n        # that of the newly constructed object\n        brace = always_redraw(Brace, square, UP)\n\n        label = TexText(\"Width = 0.00\")\n        number = label.make_number_changeable(\"0.00\")\n\n        # This ensures that the method deicmal.next_to(square)\n        # is called on every frame\n        label.always.next_to(brace, UP)\n        # You could also write the following equivalent line\n        # label.add_updater(lambda m: m.next_to(brace, UP))\n\n        # If the argument itself might change, you can use f_always,\n        # for which the arguments following the initial Mobject method\n        # should be functions returning arguments to that method.\n        # The following line ensures thst decimal.set_value(square.get_y())\n        # is called every frame\n        number.f_always.set_value(square.get_width)\n        # You could also write the following equivalent line\n        # number.add_updater(lambda m: m.set_value(square.get_width()))\n\n        self.add(square, brace, label)\n\n        # Notice that the brace and label track with the square\n        self.play(\n            square.animate.scale(2),\n            rate_func=there_and_back,\n            run_time=2,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(5, stretch=True),\n            run_time=3,\n        )\n        self.wait()\n        self.play(\n            square.animate.set_width(2),\n            run_time=3\n        )\n        self.wait()\n\n        # In general, you can alway call Mobject.add_updater, and pass in\n        # a function that you want to be called on every frame.  The function\n        # should take in either one argument, the mobject, or two arguments,\n        # the mobject and the amount of time since the last frame.\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(\n            lambda m: m.set_width(w0 * math.sin(self.time - now) + w0)\n        )\n        self.wait(4 * PI)\n\n\nclass CoordinateSystemExample(Scene):\n    def construct(self):\n        axes = Axes(\n            # x-axis ranges from -1 to 10, with a default step size of 1\n            x_range=(-1, 10),\n            # y-axis ranges from -2 to 2 with a step size of 0.5\n            y_range=(-2, 2, 0.5),\n            # The axes will be stretched so as to match the specified\n            # height and width\n            height=6,\n            width=10,\n            # Axes is made of two NumberLine mobjects.  You can specify\n            # their configuration with axis_config\n            axis_config=dict(\n                stroke_color=GREY_A,\n                stroke_width=2,\n                numbers_to_exclude=[0],\n            ),\n            # Alternatively, you can specify configuration for just one\n            # of them, like this.\n            y_axis_config=dict(\n                big_tick_numbers=[-2, 2],\n            )\n        )\n        # Keyword arguments of add_coordinate_labels can be used to\n        # configure the DecimalNumber mobjects which it creates and\n        # adds to the axes\n        axes.add_coordinate_labels(\n            font_size=20,\n            num_decimal_places=1,\n        )\n        self.add(axes)\n\n        # Axes descends from the CoordinateSystem class, meaning\n        # you can call call axes.coords_to_point, abbreviated to\n        # axes.c2p, to associate a set of coordinates with a point,\n        # like so:\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n\n        # Similarly, you can call axes.point_to_coords, or axes.p2c\n        # print(axes.p2c(dot.get_center()))\n\n        # We can draw lines from the axes to better mark the coordinates\n        # of a given point.\n        # Here, the always_redraw command means that on each new frame\n        # the lines will be redrawn\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n\n        self.play(\n            ShowCreation(h_line),\n            ShowCreation(v_line),\n        )\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n\n        # If we tie the dot to a particular set of coordinates, notice\n        # that as we move the axes around it respects the coordinate\n        # system defined by them.\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(\n            axes.animate.scale(0.75).to_corner(UL),\n            run_time=2,\n        )\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))\n\n        # Other coordinate systems you can play around with include\n        # ThreeDAxes, NumberPlane, and ComplexPlane.\n\n\nclass GraphExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8), height=6)\n        axes.add_coordinate_labels()\n\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n\n        # Axes.get_graph will return the graph of a function\n        sin_graph = axes.get_graph(\n            lambda x: 2 * math.sin(x),\n            color=BLUE,\n        )\n        # By default, it draws it so as to somewhat smoothly interpolate\n        # between sampled points (x, f(x)).  If the graph is meant to have\n        # a corner, though, you can set use_smoothing to False\n        relu_graph = axes.get_graph(\n            lambda x: max(x, 0),\n            use_smoothing=False,\n            color=YELLOW,\n        )\n        # For discontinuous functions, you can specify the point of\n        # discontinuity so that it does not try to draw over the gap.\n        step_graph = axes.get_graph(\n            lambda x: 2.0 if x > 3 else 1.0,\n            discontinuities=[3],\n            color=GREEN,\n        )\n\n        # Axes.get_graph_label takes in either a string or a mobject.\n        # If it's a string, it treats it as a LaTeX expression.  By default\n        # it places the label next to the graph near the right side, and\n        # has it match the color of the graph\n        sin_label = axes.get_graph_label(sin_graph, \"\\\\sin(x)\")\n        relu_label = axes.get_graph_label(relu_graph, Text(\"ReLU\"))\n        step_label = axes.get_graph_label(step_graph, Text(\"Step\"), x=4)\n\n        self.play(\n            ShowCreation(sin_graph),\n            FadeIn(sin_label, RIGHT),\n        )\n        self.wait(2)\n        self.play(\n            ReplacementTransform(sin_graph, relu_graph),\n            FadeTransform(sin_label, relu_label),\n        )\n        self.wait()\n        self.play(\n            ReplacementTransform(relu_graph, step_graph),\n            FadeTransform(relu_label, step_label),\n        )\n        self.wait()\n\n        parabola = axes.get_graph(lambda x: 0.25 * x**2)\n        parabola.set_stroke(BLUE)\n        self.play(\n            FadeOut(step_graph),\n            FadeOut(step_label),\n            ShowCreation(parabola)\n        )\n        self.wait()\n\n        # You can use axes.input_to_graph_point, abbreviated\n        # to axes.i2gp, to find a particular point on a graph\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n\n        # A value tracker lets us animate a parameter, usually\n        # with the intent of having other mobjects update based\n        # on the parameter\n        x_tracker = ValueTracker(2)\n        dot.add_updater(lambda d: d.move_to(axes.i2gp(x_tracker.get_value(), parabola)))\n\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()\n\n\nclass TexAndNumbersExample(Scene):\n    def construct(self):\n        axes = Axes((-3, 3), (-3, 3), unit_size=1)\n        axes.to_edge(DOWN)\n        axes.add_coordinate_labels(font_size=16)\n        circle = Circle(radius=2)\n        circle.set_stroke(YELLOW, 3)\n        circle.move_to(axes.get_origin())\n        self.add(axes, circle)\n\n        # When numbers show up in tex, they can be readily\n        # replaced with DecimalMobjects so that methods like\n        # get_value and set_value can be called on them, and\n        # animations like ChangeDecimalToValue can be called\n        # on them.\n        tex = Tex(\"x^2 + y^2 = 4.00\")\n        tex.next_to(axes, UP, buff=0.5)\n        value = tex.make_number_changeable(\"4.00\")\n\n\n        # This will tie the right hand side of our equation to\n        # the square of the radius of the circle\n        value.add_updater(lambda v: v.set_value(circle.get_radius()**2))\n        self.add(tex)\n\n        text = Text(\"\"\"\n            You can manipulate numbers\n            in Tex mobjects\n        \"\"\", font_size=30)\n        text.next_to(tex, RIGHT, buff=1.5)\n        arrow = Arrow(text, tex)\n        self.add(text, arrow)\n\n        self.play(\n            circle.animate.set_height(2.0),\n            run_time=4,\n            rate_func=there_and_back,\n        )\n\n        # By default, tex.make_number_changeable replaces the first occurance\n        # of the number,but by passing replace_all=True it replaces all and\n        # returns a group of the results\n        exponents = tex.make_number_changeable(\"2\", replace_all=True)\n        self.play(\n            LaggedStartMap(\n                FlashAround, exponents,\n                lag_ratio=0.2, buff=0.1, color=RED\n            ),\n            exponents.animate.set_color(RED)\n        )\n\n        def func(x, y):\n            # Switch from manim coords to axes coords\n            xa, ya = axes.point_to_coords(np.array([x, y, 0]))\n            return xa**4 + ya**4 - 4\n\n        new_curve = ImplicitFunction(func)\n        new_curve.match_style(circle)\n        circle.rotate(angle_of_vector(new_curve.get_start()))  # Align\n        value.clear_updaters()\n\n        self.play(\n            *(ChangeDecimalToValue(exp, 4) for exp in exponents),\n            ReplacementTransform(circle.copy(), new_curve),\n            circle.animate.set_stroke(width=1, opacity=0.5),\n        )\n\n\nclass SurfaceExample(ThreeDScene):\n    def construct(self):\n        surface_text = Text(\"For 3d scenes, try using surfaces\")\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        # You can texture a surface with up to two images, which will\n        # be interpreted as the side towards the light, and away from\n        # the light.  These can be either urls, or paths to a local file\n        # in whatever you've set as the image directory in\n        # the custom_config.yml file\n\n        # day_texture = \"EarthTextureMap\"\n        # night_texture = \"NightEarthTextureMap\"\n        day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n        night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n\n        surfaces = [\n            TexturedSurface(surface, day_texture, night_texture)\n            for surface in [sphere, torus1, torus2]\n        ]\n\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n\n        surface = surfaces[0]\n\n        self.play(\n            FadeIn(surface),\n            ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),\n        )\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n\n        self.play(\n            Transform(surface, surfaces[1]),\n            run_time=3\n        )\n\n        self.play(\n            Transform(surface, surfaces[2]),\n            # Move camera frame during the transition\n            self.frame.animate.increment_phi(-10 * DEG),\n            self.frame.animate.increment_theta(-20 * DEG),\n            run_time=3\n        )\n        # Add ambient rotation\n        self.frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n\n        # Play around with where the light is\n        light_text = Text(\"You can move around the light source\")\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        light_dot = GlowDot(color=WHITE, radius=0.5)\n        light_dot.always.move_to(light)\n        self.add(light, light_dot)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n\n        drag_text = Text(\"Try moving the mouse while pressing d or f\")\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()\n\n\nclass InteractiveDevelopment(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n\n        self.play(ShowCreation(square))\n        self.wait()\n\n        # This opens an iPython terminal where you can keep writing\n        # lines as if they were part of this construct method.\n        # In particular, 'square', 'circle' and 'self' will all be\n        # part of the local namespace in that terminal.\n        self.embed()\n\n        # Try copying and pasting some of the lines below into\n        # the interactive shell\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEG))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n\n        text = Text(\"\"\"\n            In general, using the interactive shell\n            is very helpful when developing new scenes\n        \"\"\")\n        self.play(Write(text))\n\n        # In the interactive shell, you can just type\n        # play, add, remove, clear, wait, save_state and restore,\n        # instead of self.play, self.add, self.remove, etc.\n\n        # To interact with the window, type touch().  You can then\n        # scroll in the window, or zoom by holding down 'z' while scrolling,\n        # and change camera perspective by holding down 'd' while moving\n        # the mouse.  Press 'r' to reset to the standard camera position.\n        # Press 'q' to stop interacting with the window and go back to\n        # typing new commands into the shell.\n\n        # In principle you can customize a scene to be responsive to\n        # mouse and keyboard interactions\n        always(circle.move_to, self.mouse_point)\n\n\nclass ControlsExample(Scene):\n    drag_to_pan = False\n\n    def setup(self):\n        self.textbox = Textbox()\n        self.checkbox = Checkbox()\n        self.color_picker = ColorSliders()\n        self.panel = ControlPanel(\n            Text(\"Text\", font_size=24), self.textbox, Line(),\n            Text(\"Show/Hide Text\", font_size=24), self.checkbox, Line(),\n            Text(\"Color of Text\", font_size=24), self.color_picker\n        )\n        self.add(self.panel)\n\n    def construct(self):\n        text = Text(\"text\", font_size=96)\n\n        def text_updater(old_text):\n            assert(isinstance(old_text, Text))\n            new_text = Text(self.textbox.get_value(), font_size=old_text.font_size)\n            # new_text.align_data_and_family(old_text)\n            new_text.move_to(old_text)\n            if self.checkbox.get_value():\n                new_text.set_fill(\n                    color=self.color_picker.get_picked_color(),\n                    opacity=self.color_picker.get_picked_opacity()\n                )\n            else:\n                new_text.set_opacity(0)\n            old_text.become(new_text)\n\n        text.add_updater(text_updater)\n\n        self.add(MotionMobject(text))\n\n        self.textbox.set_value(\"Manim\")\n        # self.wait(60)\n        # self.embed()\n\n\n# See https://github.com/3b1b/videos for many, many more\n",
    "logo/logo.py": "from manimlib.imports import *\n\nNEW_BLUE = \"#68a8e1\"\n\nclass Thumbnail(GraphScene):\n    CONFIG = {\n        \"y_max\": 8,\n        \"y_axis_height\": 5,\n    }\n\n    def construct(self):\n        self.show_function_graph()\n\n    def show_function_graph(self):\n        self.setup_axes(animate=False)\n        def func(x):\n            return 0.1 * (x + 3-5) * (x - 3-5) * (x-5) + 5\n\n        def rect(x):\n            return 2.775*(x-1.5)+3.862\n        recta = self.get_graph(rect,x_min=-1,x_max=5)\n        graph = self.get_graph(func,x_min=0.2,x_max=9)\n        graph.set_color(NEW_BLUE)\n        input_tracker_p1 = ValueTracker(1.5)\n        input_tracker_p2 = ValueTracker(3.5)\n\n        def get_x_value(input_tracker):\n            return input_tracker.get_value()\n\n        def get_y_value(input_tracker):\n            return graph.underlying_function(get_x_value(input_tracker))\n\n        def get_x_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), 0)\n\n        def get_y_point(input_tracker):\n            return self.coords_to_point(0, get_y_value(input_tracker))\n\n        def get_graph_point(input_tracker):\n            return self.coords_to_point(get_x_value(input_tracker), get_y_value(input_tracker))\n\n        def get_v_line(input_tracker):\n            return DashedLine(get_x_point(input_tracker), get_graph_point(input_tracker), stroke_width=2)\n\n        def get_h_line(input_tracker):\n            return DashedLine(get_graph_point(input_tracker), get_y_point(input_tracker), stroke_width=2)\n        # \n        input_triangle_p1 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p1 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p1, output_triangle_p1:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        # \n        input_triangle_p2 = RegularPolygon(n=3, start_angle=TAU / 4)\n        output_triangle_p2 = RegularPolygon(n=3, start_angle=0)\n        for triangle in input_triangle_p2, output_triangle_p2:\n            triangle.set_fill(WHITE, 1)\n            triangle.set_stroke(width=0)\n            triangle.scale(0.1)\n        \n        # \n        x_label_p1 = Tex(\"a\")\n        output_label_p1 = Tex(\"f(a)\")\n        x_label_p2 = Tex(\"b\")\n        output_label_p2 = Tex(\"f(b)\")\n        v_line_p1 = get_v_line(input_tracker_p1)\n        v_line_p2 = get_v_line(input_tracker_p2)\n        h_line_p1 = get_h_line(input_tracker_p1)\n        h_line_p2 = get_h_line(input_tracker_p2)\n        graph_dot_p1 = Dot(color=WHITE)\n        graph_dot_p2 = Dot(color=WHITE)\n\n        # reposition mobjects\n        x_label_p1.next_to(v_line_p1, DOWN)\n        x_label_p2.next_to(v_line_p2, DOWN)\n        output_label_p1.next_to(h_line_p1, LEFT)\n        output_label_p2.next_to(h_line_p2, LEFT)\n        input_triangle_p1.next_to(v_line_p1, DOWN, buff=0)\n        input_triangle_p2.next_to(v_line_p2, DOWN, buff=0)\n        output_triangle_p1.next_to(h_line_p1, LEFT, buff=0)\n        output_triangle_p2.next_to(h_line_p2, LEFT, buff=0)\n        graph_dot_p1.move_to(get_graph_point(input_tracker_p1))\n        graph_dot_p2.move_to(get_graph_point(input_tracker_p2))\n\n\n        #\n        self.play(\n            ShowCreation(graph),\n        )\n        # Animacion del punto a\n        self.add_foreground_mobject(graph_dot_p1)\n        self.add_foreground_mobject(graph_dot_p2)\n        self.play(\n            DrawBorderThenFill(input_triangle_p1),\n            Write(x_label_p1),\n            ShowCreation(v_line_p1),\n            GrowFromCenter(graph_dot_p1),\n            ShowCreation(h_line_p1),\n            Write(output_label_p1),\n            DrawBorderThenFill(output_triangle_p1),\n            DrawBorderThenFill(input_triangle_p2),\n            Write(x_label_p2),\n            ShowCreation(v_line_p2),\n            GrowFromCenter(graph_dot_p2),\n            ShowCreation(h_line_p2),\n            Write(output_label_p2),\n            DrawBorderThenFill(output_triangle_p2),\n            run_time=0.5\n        )\n        self.add(\n            input_triangle_p2,\n            x_label_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n            output_label_p2,\n        )\n        ###################\n        pendiente_recta = self.get_secant_slope_group(\n            1.9, recta, dx = 1.4,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = PURPLE,\n            df_line_color= ORANGE,\n            )\n        grupo_secante = self.get_secant_slope_group(\n            1.5, graph, dx = 2,\n            df_label = None,\n            dx_label = None,\n            dx_line_color = \"#942357\",\n            df_line_color= \"#3f7d5c\",\n            secant_line_color = RED,\n        )\n\n\n        self.add(\n            input_triangle_p2,\n            graph_dot_p2,\n            v_line_p2,\n            h_line_p2,\n            output_triangle_p2,\n        )\n        self.play(FadeIn(grupo_secante))\n\n        kwargs = {\n            \"x_min\" : 4,\n            \"x_max\" : 9,\n            \"fill_opacity\" : 0.75,\n            \"stroke_width\" : 0.25,\n        }\n        self.graph=graph\n        iteraciones=6\n\n\n        self.rect_list = self.get_riemann_rectangles_list(\n            graph, iteraciones,start_color=PURPLE,end_color=ORANGE, **kwargs\n        )\n        flat_rects = self.get_riemann_rectangles(\n            self.get_graph(lambda x : 0), dx = 0.5,start_color=invert_color(PURPLE),end_color=invert_color(ORANGE),**kwargs\n        )\n        rects = self.rect_list[0]\n        self.transform_between_riemann_rects(\n            flat_rects, rects, \n            replace_mobject_with_target_in_scene = True,\n            run_time=0.9\n        )\n\n        # adding manim\n        picture = Group(*self.mobjects)\n        picture.scale(0.6).to_edge(LEFT, buff=SMALL_BUFF)\n        manim = TexText(\"Manim\").set_height(1.5) \\\n                                    .next_to(picture, RIGHT) \\\n                                    .shift(DOWN * 0.7)\n        self.add(manim)\n",
    "manimlib/__init__.py": "import pkg_resources\n\n__version__ = pkg_resources.get_distribution(\"manimgl\").version\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from manimlib.typing import *\n\nfrom manimlib.constants import *\n\nfrom manimlib.window import *\n\nfrom manimlib.animation.animation import *\nfrom manimlib.animation.composition import *\nfrom manimlib.animation.creation import *\nfrom manimlib.animation.fading import *\nfrom manimlib.animation.growing import *\nfrom manimlib.animation.indication import *\nfrom manimlib.animation.movement import *\nfrom manimlib.animation.numbers import *\nfrom manimlib.animation.rotation import *\nfrom manimlib.animation.specialized import *\nfrom manimlib.animation.transform import *\nfrom manimlib.animation.transform_matching_parts import *\nfrom manimlib.animation.update import *\n\nfrom manimlib.camera.camera import *\n\nfrom manimlib.mobject.boolean_ops import *\nfrom manimlib.mobject.changing import *\nfrom manimlib.mobject.coordinate_systems import *\nfrom manimlib.mobject.frame import *\nfrom manimlib.mobject.functions import *\nfrom manimlib.mobject.geometry import *\nfrom manimlib.mobject.interactive import *\nfrom manimlib.mobject.matrix import *\nfrom manimlib.mobject.mobject import *\nfrom manimlib.mobject.mobject_update_utils import *\nfrom manimlib.mobject.number_line import *\nfrom manimlib.mobject.numbers import *\nfrom manimlib.mobject.probability import *\nfrom manimlib.mobject.shape_matchers import *\nfrom manimlib.mobject.svg.brace import *\nfrom manimlib.mobject.svg.drawings import *\nfrom manimlib.mobject.svg.string_mobject import *\nfrom manimlib.mobject.svg.svg_mobject import *\nfrom manimlib.mobject.svg.special_tex import *\nfrom manimlib.mobject.svg.tex_mobject import *\nfrom manimlib.mobject.svg.text_mobject import *\nfrom manimlib.mobject.three_dimensions import *\nfrom manimlib.mobject.types.dot_cloud import *\nfrom manimlib.mobject.types.image_mobject import *\nfrom manimlib.mobject.types.point_cloud_mobject import *\nfrom manimlib.mobject.types.surface import *\nfrom manimlib.mobject.types.vectorized_mobject import *\nfrom manimlib.mobject.value_tracker import *\nfrom manimlib.mobject.vector_field import *\n\nfrom manimlib.scene.interactive_scene import *\nfrom manimlib.scene.scene import *\n\nfrom manimlib.utils.bezier import *\nfrom manimlib.utils.cache import *\nfrom manimlib.utils.color import *\nfrom manimlib.utils.dict_ops import *\nfrom manimlib.utils.debug import *\nfrom manimlib.utils.directories import *\nfrom manimlib.utils.file_ops import *\nfrom manimlib.utils.images import *\nfrom manimlib.utils.iterables import *\nfrom manimlib.utils.paths import *\nfrom manimlib.utils.rate_functions import *\nfrom manimlib.utils.simple_functions import *\nfrom manimlib.utils.shaders import *\nfrom manimlib.utils.sounds import *\nfrom manimlib.utils.space_ops import *\nfrom manimlib.utils.tex import *\n",
    "manimlib/__main__.py": "#!/usr/bin/env python\nfrom addict import Dict\n\nfrom manimlib import __version__\nfrom manimlib.config import manim_config\nfrom manimlib.config import parse_cli\nimport manimlib.extract_scene\nfrom manimlib.utils.cache import clear_cache\nfrom manimlib.window import Window\n\n\nfrom IPython.terminal.embed import KillEmbedded\n\n\nfrom typing import TYPE_CHECKING\nif TYPE_CHECKING:\n    from argparse import Namespace\n\n\ndef run_scenes():\n    \"\"\"\n    Runs the scenes in a loop and detects when a scene reload is requested.\n    \"\"\"\n    # Create a new dict to be able to upate without\n    # altering global configuration\n    scene_config = Dict(manim_config.scene)\n    run_config = manim_config.run\n\n    if run_config.show_in_window:\n        # Create a reusable window\n        window = Window(**manim_config.window)\n        scene_config.update(window=window)\n\n    while True:\n        try:\n            # Blocking call since a scene may init an IPython shell()\n            scenes = manimlib.extract_scene.main(scene_config, run_config)\n            for scene in scenes:\n                scene.run()\n            return\n        except KillEmbedded:\n            # Requested via the `exit_raise` IPython runline magic\n            # by means of the reload_scene() command\n            pass\n        except KeyboardInterrupt:\n            break\n\n\ndef main():\n    \"\"\"\n    Main entry point for ManimGL.\n    \"\"\"\n    print(f\"ManimGL \\033[32mv{__version__}\\033[0m\")\n\n    args = parse_cli()\n    if args.version and args.file is None:\n        return\n    if args.clear_cache:\n        clear_cache()\n\n    run_scenes()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "manimlib/animation/animation.py": "from __future__ import annotations\n\nfrom copy import deepcopy\n\nfrom manimlib.mobject.mobject import _AnimationBuilder\nfrom manimlib.mobject.mobject import Mobject\nfrom manimlib.utils.iterables import remove_list_redundancies\nfrom manimlib.utils.rate_functions import smooth\nfrom manimlib.utils.simple_functions import clip\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Callable\n\n    from manimlib.scene.scene import Scene\n\n\nDEFAULT_ANIMATION_RUN_TIME = 1.0\nDEFAULT_ANIMATION_LAG_RATIO = 0\n\n\nclass Animation(object):\n    def __init__(\n        self,\n        mobject: Mobject,\n        run_time: float = DEFAULT_ANIMATION_RUN_TIME,\n        # Tuple of times, between which the animation will run\n        time_span: tuple[float, float] | None = None,\n        # If 0, the animation is applied to all submobjects at the same time\n        # If 1, it is applied to each successively.\n        # If 0 < lag_ratio < 1, its applied to each with lagged start times\n        lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,\n        rate_func: Callable[[float], float] = smooth,\n        name: str = \"\",\n        # Does this animation add or remove a mobject form the screen\n        remover: bool = False,\n        # What to enter into the update function upon completion\n        final_alpha_value: float = 1.0,\n        # If set to True, the mobject itself will have its internal updaters called,\n        # but the start or target mobjects would not be suspended. To completely suspend\n        # updating, call mobject.suspend_updating() before the animation\n        suspend_mobject_updating: bool = False,\n    ):\n        self.mobject = mobject\n        self.run_time = run_time\n        self.time_span = time_span\n        self.rate_func = rate_func\n        self.name = name or self.__class__.__name__ + str(self.mobject)\n        self.remover = remover\n        self.final_alpha_value = final_alpha_value\n        self.lag_ratio = lag_ratio\n        self.suspend_mobject_updating = suspend_mobject_updating\n\n        assert isinstance(mobject, Mobject)\n\n    def __str__(self) -> str:\n        return self.name\n\n    def begin(self) -> None:\n        # This is called right as an animation is being\n        # played.  As much initialization as possible,\n        # especially any mobject copying, should live in\n        # this method\n        if self.time_span is not None:\n            start, end = self.time_span\n            self.run_time = max(end, self.run_time)\n        self.mobject.set_animating_status(True)\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            self.mobject_was_updating = not self.mobject.updating_suspended\n            self.mobject.suspend_updating()\n        self.families = list(self.get_all_families_zipped())\n        self.interpolate(0)\n\n    def finish(self) -> None:\n        self.interpolate(self.final_alpha_value)\n        self.mobject.set_animating_status(False)\n        if self.suspend_mobject_updating and self.mobject_was_updating:\n            self.mobject.resume_updating()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        if self.is_remover():\n            scene.remove(self.mobject)\n\n    def create_starting_mobject(self) -> Mobject:\n        # Keep track of where the mobject starts\n        return self.mobject.copy()\n\n    def get_all_mobjects(self) -> tuple[Mobject, Mobject]:\n        \"\"\"\n        Ordering must match the ording of arguments to interpolate_submobject\n        \"\"\"\n        return self.mobject, self.starting_mobject\n\n    def get_all_families_zipped(self) -> zip[tuple[Mobject]]:\n        return zip(*[\n            mob.get_family()\n            for mob in self.get_all_mobjects()\n        ])\n\n    def update_mobjects(self, dt: float) -> None:\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)\n\n    def get_all_mobjects_to_update(self) -> list[Mobject]:\n        # The surrounding scene typically handles\n        # updating of self.mobject.\n        items = list(filter(\n            lambda m: m is not self.mobject,\n            self.get_all_mobjects()\n        ))\n        items = remove_list_redundancies(items)\n        return items\n\n    def copy(self):\n        return deepcopy(self)\n\n    def update_rate_info(\n        self,\n        run_time: float | None = None,\n        rate_func: Callable[[float], float] | None = None,\n        lag_ratio: float | None = None,\n    ):\n        self.run_time = run_time or self.run_time\n        self.rate_func = rate_func or self.rate_func\n        self.lag_ratio = lag_ratio or self.lag_ratio\n        return self\n\n    # Methods for interpolation, the mean of an Animation\n    def interpolate(self, alpha: float) -> None:\n        self.interpolate_mobject(alpha)\n\n    def update(self, alpha: float) -> None:\n        \"\"\"\n        This method shouldn't exist, but it's here to\n        keep many old scenes from breaking\n        \"\"\"\n        self.interpolate(alpha)\n\n    def time_spanned_alpha(self, alpha: float) -> float:\n        if self.time_span is not None:\n            start, end = self.time_span\n            return clip(alpha * self.run_time - start, 0, end - start) / (end - start)\n        return alpha\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        for i, mobs in enumerate(self.families):\n            sub_alpha = self.get_sub_alpha(self.time_spanned_alpha(alpha), i, len(self.families))\n            self.interpolate_submobject(*mobs, sub_alpha)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float\n    ):\n        # Typically ipmlemented by subclass\n        pass\n\n    def get_sub_alpha(\n        self,\n        alpha: float,\n        index: int,\n        num_submobjects: int\n    ) -> float:\n        # TODO, make this more understanable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        raw_sub_alpha = clip((value - lower), 0, 1)\n        return self.rate_func(raw_sub_alpha)\n\n    # Getters and setters\n    def set_run_time(self, run_time: float):\n        self.run_time = run_time\n        return self\n\n    def get_run_time(self) -> float:\n        if self.time_span:\n            return max(self.run_time, self.time_span[1])\n        return self.run_time\n\n    def set_rate_func(self, rate_func: Callable[[float], float]):\n        self.rate_func = rate_func\n        return self\n\n    def get_rate_func(self) -> Callable[[float], float]:\n        return self.rate_func\n\n    def set_name(self, name: str):\n        self.name = name\n        return self\n\n    def is_remover(self) -> bool:\n        return self.remover\n\n\ndef prepare_animation(anim: Animation | _AnimationBuilder):\n    if isinstance(anim, _AnimationBuilder):\n        return anim.build()\n\n    if isinstance(anim, Animation):\n        return anim\n\n    raise TypeError(f\"Object {anim} cannot be converted to an animation\")\n",
    "manimlib/animation/composition.py": "from __future__ import annotations\n\nfrom manimlib.animation.animation import Animation\nfrom manimlib.animation.animation import prepare_animation\nfrom manimlib.mobject.mobject import _AnimationBuilder\nfrom manimlib.mobject.mobject import Group\nfrom manimlib.mobject.types.vectorized_mobject import VGroup\nfrom manimlib.mobject.types.vectorized_mobject import VMobject\nfrom manimlib.utils.bezier import integer_interpolate\nfrom manimlib.utils.bezier import interpolate\nfrom manimlib.utils.iterables import remove_list_redundancies\nfrom manimlib.utils.simple_functions import clip\n\nfrom typing import TYPE_CHECKING, Union, Iterable\nAnimationType = Union[Animation, _AnimationBuilder]\n\nif TYPE_CHECKING:\n    from typing import Callable, Optional\n\n    from manimlib.mobject.mobject import Mobject\n    from manimlib.scene.scene import Scene\n\n\nDEFAULT_LAGGED_START_LAG_RATIO = 0.05\n\n\nclass AnimationGroup(Animation):\n    def __init__(\n        self,\n        *args: AnimationType | Iterable[AnimationType],\n        run_time: float = -1,  # If negative, default to sum of inputed animation runtimes\n        lag_ratio: float = 0.0,\n        group: Optional[Mobject] = None,\n        group_type: Optional[type] = None,\n        **kwargs\n    ):\n        animations = args[0] if isinstance(args[0], Iterable) else args\n        self.animations = [prepare_animation(anim) for anim in animations]\n        self.build_animations_with_timings(lag_ratio)\n        self.max_end_time = max((awt[2] for awt in self.anims_with_timings), default=0)\n        self.run_time = self.max_end_time if run_time < 0 else run_time\n        self.lag_ratio = lag_ratio\n        mobs = remove_list_redundancies([a.mobject for a in self.animations])\n        if group is not None:\n            self.group = group\n        if group_type is not None:\n            self.group = group_type(*mobs)\n        elif all(isinstance(anim.mobject, VMobject) for anim in animations):\n            self.group = VGroup(*mobs)\n        else:\n            self.group = Group(*mobs)\n\n        super().__init__(\n            self.group,\n            run_time=self.run_time,\n            lag_ratio=lag_ratio,\n            **kwargs\n        )\n\n    def get_all_mobjects(self) -> Mobject:\n        return self.group\n\n    def begin(self) -> None:\n        self.group.set_animating_status(True)\n        for anim in self.animations:\n            anim.begin()\n        # self.init_run_time()\n\n    def finish(self) -> None:\n        self.group.set_animating_status(False)\n        for anim in self.animations:\n            anim.finish()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        for anim in self.animations:\n            anim.clean_up_from_scene(scene)\n\n    def update_mobjects(self, dt: float) -> None:\n        for anim in self.animations:\n            anim.update_mobjects(dt)\n\n    def calculate_max_end_time(self) -> None:\n        self.max_end_time = max(\n            (awt[2] for awt in self.anims_with_timings),\n            default=0,\n        )\n        if self.run_time < 0:\n            self.run_time = self.max_end_time\n\n    def build_animations_with_timings(self, lag_ratio: float) -> None:\n        \"\"\"\n        Creates a list of triplets of the form\n        (anim, start_time, end_time)\n        \"\"\"\n        self.anims_with_timings = []\n        curr_time = 0\n        for anim in self.animations:\n            start_time = curr_time\n            end_time = start_time + anim.get_run_time()\n            self.anims_with_timings.append(\n                (anim, start_time, end_time)\n            )\n            # Start time of next animation is based on the lag_ratio\n            curr_time = interpolate(\n                start_time, end_time, lag_ratio\n            )\n\n    def interpolate(self, alpha: float) -> None:\n        # Note, if the run_time of AnimationGroup has been\n        # set to something other than its default, these\n        # times might not correspond to actual times,\n        # e.g. of the surrounding scene.  Instead they'd\n        # be a rescaled version.  But that's okay!\n        time = alpha * self.max_end_time\n        for anim, start_time, end_time in self.anims_with_timings:\n            anim_time = end_time - start_time\n            if anim_time == 0:\n                sub_alpha = 0\n            else:\n                sub_alpha = clip((time - start_time) / anim_time, 0, 1)\n            anim.interpolate(sub_alpha)\n\n\nclass Succession(AnimationGroup):\n    def __init__(\n        self,\n        *animations: Animation,\n        lag_ratio: float = 1.0,\n        **kwargs\n    ):\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)\n\n    def begin(self) -> None:\n        assert len(self.animations) > 0\n        self.active_animation = self.animations[0]\n        self.active_animation.begin()\n\n    def finish(self) -> None:\n        self.active_animation.finish()\n\n    def update_mobjects(self, dt: float) -> None:\n        self.active_animation.update_mobjects(dt)\n\n    def interpolate(self, alpha: float) -> None:\n        index, subalpha = integer_interpolate(\n            0, len(self.animations), alpha\n        )\n        animation = self.animations[index]\n        if animation is not self.active_animation:\n            self.active_animation.finish()\n            animation.begin()\n            self.active_animation = animation\n        animation.interpolate(subalpha)\n\n\nclass LaggedStart(AnimationGroup):\n    def __init__(\n        self,\n        *animations,\n        lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,\n        **kwargs\n    ):\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)\n\n\nclass LaggedStartMap(LaggedStart):\n    def __init__(\n        self,\n        anim_func: Callable[[Mobject], Animation],\n        group: Mobject,\n        run_time: float = 2.0,\n        lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,\n        **kwargs\n    ):\n        anim_kwargs = dict(kwargs)\n        anim_kwargs.pop(\"lag_ratio\", None)\n        super().__init__(\n            *(anim_func(submob, **anim_kwargs) for submob in group),\n            run_time=run_time,\n            lag_ratio=lag_ratio,\n            group=group\n        )\n"
  },
  "requirements": "addict\nappdirs\ncolour\ndiskcache\nipython>=8.18.0\nisosurfaces\nfontTools\nmanimpango>=0.6.0\nmapbox-earcut\nmatplotlib\nmoderngl\nmoderngl_window\nnumpy\nPillow\npydub\npygments\nPyOpenGL\npyperclip\npyyaml\nrich\nscipy\nscreeninfo\nskia-pathops\nsvgelements>=1.8.1\nsympy\ntqdm\ntyping-extensions; python_version < \"3.11\"\nvalidators\n"
}