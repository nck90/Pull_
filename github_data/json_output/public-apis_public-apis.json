{
  "repo_name": "public-apis/public-apis",
  "repo_url": "https://github.com/public-apis/public-apis",
  "description": "A collective list of free APIs",
  "stars": 333184,
  "language": "Python",
  "created_at": "2016-03-20T23:49:42Z",
  "updated_at": "2025-03-19T07:05:05Z",
  "files": {
    "scripts/tests/__init__.py": "# -*- coding: utf-8 -*-\n",
    "scripts/tests/test_validate_format.py": "# -*- coding: utf-8 -*-\n\nimport unittest\n\nfrom validate.format import error_message\nfrom validate.format import get_categories_content\nfrom validate.format import check_alphabetical_order\nfrom validate.format import check_title\nfrom validate.format import check_description, max_description_length\nfrom validate.format import check_auth, auth_keys\nfrom validate.format import check_https, https_keys\nfrom validate.format import check_cors, cors_keys\nfrom validate.format import check_entry\nfrom validate.format import check_file_format, min_entries_per_category, num_segments\n\n\nclass TestValidadeFormat(unittest.TestCase):\n    \n    def test_error_message_return_and_return_type(self):\n        line_num_unity = 1\n        line_num_ten = 10\n        line_num_hundred = 100\n        line_num_thousand = 1000\n\n        msg = 'This is a unit test'\n\n        err_msg_unity = error_message(line_num_unity, msg)\n        err_msg_ten = error_message(line_num_ten, msg)\n        err_msg_hundred = error_message(line_num_hundred, msg)\n        err_msg_thousand = error_message(line_num_thousand, msg)\n\n        self.assertIsInstance(err_msg_unity, str)\n        self.assertIsInstance(err_msg_ten, str)\n        self.assertIsInstance(err_msg_hundred, str)\n        self.assertIsInstance(err_msg_thousand, str)\n\n        self.assertEqual(err_msg_unity, '(L002) This is a unit test')\n        self.assertEqual(err_msg_ten, '(L011) This is a unit test')\n        self.assertEqual(err_msg_hundred, '(L101) This is a unit test')\n        self.assertEqual(err_msg_thousand, '(L1001) This is a unit test')\n\n    def test_if_get_categories_content_return_correct_data_of_categories(self):\n        fake_contents = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        result = get_categories_content(fake_contents)\n        self.assertIsInstance(result, tuple)\n\n        categories, category_line_num = result\n        self.assertIsInstance(categories, dict)\n        self.assertIsInstance(category_line_num, dict)\n\n        expected_result = ({'A': ['AA', 'AB'], 'B': ['BA', 'BB']}, {'A': 0, 'B': 6})\n\n        for res, ex_res in zip(result, expected_result):\n\n            with self.subTest():\n                self.assertEqual(res, ex_res)\n\n    def test_if_check_alphabetical_order_return_correct_msg_error(self):\n        correct_lines = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        incorrect_lines = [\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n\n        err_msgs_1 = check_alphabetical_order(correct_lines)\n        err_msgs_2 = check_alphabetical_order(incorrect_lines)\n\n        self.assertIsInstance(err_msgs_1, list)\n        self.assertIsInstance(err_msgs_2, list)\n\n        self.assertEqual(len(err_msgs_1), 0)\n        self.assertEqual(len(err_msgs_2), 2)\n\n        expected_err_msgs = [\n            '(L001) A category is not alphabetical order',\n            '(L007) B category is not alphabetical order'\n        ]\n\n        for err_msg, ex_err_msg in zip(err_msgs_2, expected_err_msgs):\n\n            with self.subTest():\n                self.assertEqual(err_msg, ex_err_msg)\n    \n    def test_check_title_with_correct_title(self):\n        raw_title = '[A](https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\n\n    def test_check_title_with_markdown_syntax_incorrect(self):\n        raw_title = '[A(https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n        expected_err_msg = '(L001) Title syntax should be \"[TITLE](LINK)\"'\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_title_with_api_at_the_end_of_the_title(self):\n        raw_title = '[A API](https://www.ex.com)'\n\n        err_msgs = check_title(0, raw_title)\n        \n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n        expected_err_msg = '(L001) Title should not end with \"... API\". Every entry is an API here!'\n\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_description_with_correct_description(self):\n        desc = 'This is a fake description'\n\n        err_msgs = check_description(0, desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\n    \n    def test_check_description_with_first_char_is_not_capitalized(self):\n        desc = 'this is a fake description'\n\n        err_msgs = check_description(0, desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        \n        err_msg = err_msgs[0]\n        expected_err_msg = '(L001) first character of description is not capitalized'\n\n        self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msg, expected_err_msg)\n    \n    def test_check_description_with_punctuation_in_the_end(self):\n        base_desc = 'This is a fake description'\n        punctuation = r\"\"\"!\"#$%&'*+,-./:;<=>?@[\\]^_`{|}~\"\"\"\n        desc_with_punc = [base_desc + punc for punc in punctuation]\n        \n        for desc in desc_with_punc:\n\n            with self.subTest():\n                err_msgs = check_description(0, desc)\n\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n        \n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) description should not end with {desc[-1]}'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_description_that_exceeds_the_character_limit(self):\n        long_desc = 'Desc' * max_description_length\n        long_desc_length = len(long_desc)\n\n        err_msgs = check_description(0, long_desc)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n\n        err_msg = err_msgs[0]\n        expected_err_msg = f'(L001) description should not exceed {max_description_length} characters (currently {long_desc_length})'\n\n        self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_auth_with_valid_auth(self):\n        auth_valid = [f'`{auth}`' for auth in auth_keys if auth != 'No']\n        auth_valid.append('No')\n\n        for auth in auth_valid:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\n\n    def test_check_auth_without_backtick(self):\n        auth_without_backtick = [auth for auth in auth_keys if auth != 'No']\n\n        for auth in auth_without_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = '(L001) auth value is not enclosed with `backticks`'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_auth_with_invalid_auth(self):\n        auth_invalid_without_backtick = ['Yes', 'yes', 'no', 'random', 'Unknown']\n        auth_invalid_with_backtick = ['`Yes`', '`yes`', '`no`', '`random`', '`Unknown`']\n\n        for auth in auth_invalid_without_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 2)\n\n                err_msg_1 = err_msgs[0]\n                err_msg_2 = err_msgs[1]\n\n                expected_err_msg_1 = f'(L001) auth value is not enclosed with `backticks`'\n                expected_err_msg_2 = f'(L001) {auth} is not a valid Auth option'\n\n                self.assertIsInstance(err_msg_1, str)\n                self.assertIsInstance(err_msg_2, str)\n                self.assertEqual(err_msg_1, expected_err_msg_1)\n                self.assertEqual(err_msg_2, expected_err_msg_2)\n\n        for auth in auth_invalid_with_backtick:\n            with self.subTest():\n                err_msgs = check_auth(0, auth)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {auth} is not a valid Auth option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_https_with_valid_https(self):\n        for https in https_keys:\n            with self.subTest():\n                err_msgs = check_https(0, https)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\n\n    def test_check_https_with_invalid_https(self):\n        invalid_https_keys = ['yes', 'no', 'Unknown', 'https', 'http']\n\n        for https in invalid_https_keys:\n            with self.subTest():\n                err_msgs = check_https(0, https)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {https} is not a valid HTTPS option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_cors_with_valid_cors(self):\n        for cors in cors_keys:\n            with self.subTest():\n                err_msgs = check_cors(0, cors)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 0)\n                self.assertEqual(err_msgs, [])\n\n    def test_check_cors_with_invalid_cors(self):\n        invalid_cors_keys = ['yes', 'no', 'unknown', 'cors']\n\n        for cors in invalid_cors_keys:\n            with self.subTest():\n                err_msgs = check_cors(0, cors)\n                self.assertIsInstance(err_msgs, list)\n                self.assertEqual(len(err_msgs), 1)\n\n                err_msg = err_msgs[0]\n                expected_err_msg = f'(L001) {cors} is not a valid CORS option'\n\n                self.assertIsInstance(err_msg, str)\n                self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_entry_with_correct_segments(self):\n        correct_segments = ['[A](https://www.ex.com)', 'Desc', '`apiKey`', 'Yes', 'Yes']\n\n        err_msgs = check_entry(0, correct_segments)\n        \n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\n\n    def test_check_entry_with_incorrect_segments(self):\n        incorrect_segments = ['[A API](https://www.ex.com)', 'desc.', 'yes', 'yes', 'yes']\n\n        err_msgs = check_entry(0, incorrect_segments)\n        expected_err_msgs = [\n            '(L001) Title should not end with \"... API\". Every entry is an API here!',\n            '(L001) first character of description is not capitalized',\n            '(L001) description should not end with .',\n            '(L001) auth value is not enclosed with `backticks`',\n            '(L001) yes is not a valid Auth option',\n            '(L001) yes is not a valid HTTPS option',\n            '(L001) yes is not a valid CORS option'\n        ]\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 7)\n        for err_msg in err_msgs:\n            with self.subTest():\n                self.assertIsInstance(err_msg, str)\n        self.assertEqual(err_msgs, expected_err_msgs)\n\n    def test_check_file_format_with_correct_format(self):\n        correct_format = [\n            '## Index',\n            '* [A](#a)',\n            '* [B](#b)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        err_msgs = check_file_format(lines=correct_format)\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 0)\n        self.assertEqual(err_msgs, [])\n\n    def test_check_file_format_with_category_header_not_added_to_index(self):\n        incorrect_format = [\n            '## Index',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = '(L003) category header (A) not added to Index section'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_file_format_with_category_without_min_entries(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '* [B](#b)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '',\n            '### B',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [BA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [BC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |'\n        ]\n\n        category_with_err = 'A'\n        num_in_category = 1\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L005) {category_with_err} category does not have the minimum {min_entries_per_category} entries (only has {num_in_category})'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_file_format_entry_without_all_necessary_columns(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AB](https://www.ex.com) | Desc | `apiKey` |',  # missing https and cors\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        current_segments_num = 3\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L008) entry does not have all the required columns (have {current_segments_num}, need {num_segments})'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\n\n    def test_check_file_format_without_1_space_between_the_segments(self):\n        incorrect_format = [\n            '## Index',\n            '* [A](#a)',\n            '',\n            '### A',\n            'API | Description | Auth | HTTPS | CORS |',\n            '|---|---|---|---|---|',\n            '| [AA](https://www.ex.com) | Desc |`apiKey`| Yes | Yes |',  # space between segment of auth column missing\n            '| [AB](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n            '| [AC](https://www.ex.com) | Desc | `apiKey` | Yes | Yes |',\n        ]\n\n        err_msgs = check_file_format(lines=incorrect_format)\n        expected_err_msg = f'(L007) each segment must start and end with exactly 1 space'\n\n        self.assertIsInstance(err_msgs, list)\n        self.assertEqual(len(err_msgs), 1)\n        err_msg = err_msgs[0]\n        self.assertEqual(err_msg, expected_err_msg)\n",
    "scripts/tests/test_validate_links.py": "# -*- coding: utf-8 -*-\n\nimport unittest\n\nfrom validate.links import find_links_in_text\nfrom validate.links import check_duplicate_links\nfrom validate.links import fake_user_agent\nfrom validate.links import get_host_from_link\nfrom validate.links import has_cloudflare_protection\n\n\nclass FakeResponse():\n    def __init__(self, code: int, headers: dict, text: str) -> None:\n        self.status_code = code\n        self.headers = headers\n        self.text = text\n\n\nclass TestValidateLinks(unittest.TestCase):\n\n    def setUp(self):\n        self.duplicate_links = [\n            'https://www.example.com',\n            'https://www.example.com',\n            'https://www.example.com',\n            'https://www.anotherexample.com',\n        ]\n        self.no_duplicate_links = [\n            'https://www.firstexample.com',\n            'https://www.secondexample.com',\n            'https://www.anotherexample.com',\n        ]\n\n        self.code_200 = 200\n        self.code_403 = 403\n        self.code_503 = 503\n\n        self.cloudflare_headers = {'Server': 'cloudflare'}\n        self.no_cloudflare_headers = {'Server': 'google'}\n\n        self.text_with_cloudflare_flags = '403 Forbidden Cloudflare We are checking your browser...'\n        self.text_without_cloudflare_flags = 'Lorem Ipsum'\n\n    def test_find_link_in_text(self):\n        text = \"\"\"\n            # this is valid\n\n            http://example.com?param1=1&param2=2#anchor\n            https://www.example.com?param1=1&param2=2#anchor\n            https://www.example.com.br\n            https://www.example.com.gov.br\n            [Example](https://www.example.com?param1=1&param2=2#anchor)\n            lorem ipsum https://www.example.com?param1=1&param2=2#anchor\n            https://www.example.com?param1=1&param2=2#anchor lorem ipsum\n\n            # this not is valid\n\n            example.com\n            https:example.com\n            https:/example.com\n            https//example.com\n            https//.com\n        \"\"\"\n\n        links = find_links_in_text(text)\n\n        self.assertIsInstance(links, list)\n        self.assertEqual(len(links), 7)\n\n        for link in links:\n            with self.subTest():\n                self.assertIsInstance(link, str)\n\n    def test_find_link_in_text_with_invalid_argument(self):\n        with self.assertRaises(TypeError):\n            find_links_in_text()\n            find_links_in_text(1)\n            find_links_in_text(True)\n\n    def test_if_check_duplicate_links_has_the_correct_return(self):\n        result_1 = check_duplicate_links(self.duplicate_links)\n        result_2 = check_duplicate_links(self.no_duplicate_links)\n\n        self.assertIsInstance(result_1, tuple)\n        self.assertIsInstance(result_2, tuple)\n\n        has_duplicate_links, links = result_1\n        no_duplicate_links, no_links = result_2\n\n        self.assertTrue(has_duplicate_links)\n        self.assertFalse(no_duplicate_links)\n\n        self.assertIsInstance(links, list)\n        self.assertIsInstance(no_links, list)\n\n        self.assertEqual(len(links), 2)\n        self.assertEqual(len(no_links), 0)\n\n    def test_if_fake_user_agent_has_a_str_as_return(self):\n        user_agent = fake_user_agent()\n        self.assertIsInstance(user_agent, str)\n\n    def test_get_host_from_link(self):\n        links = [\n            'example.com',\n            'https://example.com',\n            'https://www.example.com',\n            'https://www.example.com.br',\n            'https://www.example.com/route',\n            'https://www.example.com?p=1&q=2',\n            'https://www.example.com#anchor'\n        ]\n\n        for link in links:\n            host = get_host_from_link(link)\n\n            with self.subTest():\n                self.assertIsInstance(host, str)\n\n                self.assertNotIn('://', host)\n                self.assertNotIn('/', host)\n                self.assertNotIn('?', host)\n                self.assertNotIn('#', host)\n\n        with self.assertRaises(TypeError):\n            get_host_from_link()\n\n    def test_has_cloudflare_protection_with_code_403_and_503_in_response(self):\n        resp_with_cloudflare_protection_code_403 = FakeResponse(\n            code=self.code_403,\n            headers=self.cloudflare_headers,\n            text=self.text_with_cloudflare_flags\n        )\n\n        resp_with_cloudflare_protection_code_503 = FakeResponse(\n            code=self.code_503,\n            headers=self.cloudflare_headers,\n            text=self.text_with_cloudflare_flags\n        )\n\n        result1 = has_cloudflare_protection(resp_with_cloudflare_protection_code_403)\n        result2 = has_cloudflare_protection(resp_with_cloudflare_protection_code_503)\n\n        self.assertTrue(result1)\n        self.assertTrue(result2)\n\n    def test_has_cloudflare_protection_when_there_is_no_protection(self):\n        resp_without_cloudflare_protection1 = FakeResponse(\n            code=self.code_200,\n            headers=self.no_cloudflare_headers,\n            text=self.text_without_cloudflare_flags\n        )\n\n        resp_without_cloudflare_protection2 = FakeResponse(\n            code=self.code_403,\n            headers=self.no_cloudflare_headers,\n            text=self.text_without_cloudflare_flags\n        )\n\n        resp_without_cloudflare_protection3 = FakeResponse(\n            code=self.code_503,\n            headers=self.no_cloudflare_headers,\n            text=self.text_without_cloudflare_flags\n        )\n\n        result1 = has_cloudflare_protection(resp_without_cloudflare_protection1)\n        result2 = has_cloudflare_protection(resp_without_cloudflare_protection2)\n        result3 = has_cloudflare_protection(resp_without_cloudflare_protection3)\n\n        self.assertFalse(result1)\n        self.assertFalse(result2)\n        self.assertFalse(result3)\n",
    "scripts/validate/__init__.py": "# -*- coding: utf-8 -*-\n\nfrom validate import format\nfrom validate import links\n",
    "scripts/validate/format.py": "# -*- coding: utf-8 -*-\n\nimport re\nimport sys\nfrom string import punctuation\nfrom typing import List, Tuple, Dict\n\n# Temporary replacement\n# The descriptions that contain () at the end must adapt to the new policy later\npunctuation = punctuation.replace('()', '')\n\nanchor = '###'\nauth_keys = ['apiKey', 'OAuth', 'X-Mashape-Key', 'User-Agent', 'No']\nhttps_keys = ['Yes', 'No']\ncors_keys = ['Yes', 'No', 'Unknown']\n\nindex_title = 0\nindex_desc = 1\nindex_auth = 2\nindex_https = 3\nindex_cors = 4\n\nnum_segments = 5\nmin_entries_per_category = 3\nmax_description_length = 100\n\nanchor_re = re.compile(anchor + '\\s(.+)')\ncategory_title_in_index_re = re.compile('\\*\\s\\[(.*)\\]')\nlink_re = re.compile('\\[(.+)\\]\\((http.*)\\)')\n\n# Type aliases\nAPIList = List[str]\nCategories = Dict[str, APIList]\nCategoriesLineNumber = Dict[str, int]\n\n\ndef error_message(line_number: int, message: str) -> str:\n    line = line_number + 1\n    return f'(L{line:03d}) {message}'\n\n\ndef get_categories_content(contents: List[str]) -> Tuple[Categories, CategoriesLineNumber]:\n\n    categories = {}\n    category_line_num = {}\n\n    for line_num, line_content in enumerate(contents):\n\n        if line_content.startswith(anchor):\n            category = line_content.split(anchor)[1].strip()\n            categories[category] = []\n            category_line_num[category] = line_num\n            continue\n\n        if not line_content.startswith('|') or line_content.startswith('|---'):\n            continue\n\n        raw_title = [\n            raw_content.strip() for raw_content in line_content.split('|')[1:-1]\n        ][0]\n\n        title_match = link_re.match(raw_title)\n        if title_match:\n                title = title_match.group(1).upper()\n                categories[category].append(title)\n\n    return (categories, category_line_num)\n\n\ndef check_alphabetical_order(lines: List[str]) -> List[str]:\n\n    err_msgs = []\n\n    categories, category_line_num = get_categories_content(contents=lines)\n\n    for category, api_list in categories.items():\n        if sorted(api_list) != api_list:\n            err_msg = error_message(\n                category_line_num[category], \n                f'{category} category is not alphabetical order'\n            )\n            err_msgs.append(err_msg)\n    \n    return err_msgs\n\n\ndef check_title(line_num: int, raw_title: str) -> List[str]:\n\n    err_msgs = []\n\n    title_match = link_re.match(raw_title)\n\n    # url should be wrapped in \"[TITLE](LINK)\" Markdown syntax\n    if not title_match:\n        err_msg = error_message(line_num, 'Title syntax should be \"[TITLE](LINK)\"')\n        err_msgs.append(err_msg)\n    else:\n        # do not allow \"... API\" in the entry title\n        title = title_match.group(1)\n        if title.upper().endswith(' API'):\n            err_msg = error_message(line_num, 'Title should not end with \"... API\". Every entry is an API here!')\n            err_msgs.append(err_msg)\n\n    return err_msgs\n\n\ndef check_description(line_num: int, description: str) -> List[str]:\n\n    err_msgs = []\n\n    first_char = description[0]\n    if first_char.upper() != first_char:\n        err_msg = error_message(line_num, 'first character of description is not capitalized')\n        err_msgs.append(err_msg)\n\n    last_char = description[-1]\n    if last_char in punctuation:\n        err_msg = error_message(line_num, f'description should not end with {last_char}')\n        err_msgs.append(err_msg)\n\n    desc_length = len(description)\n    if desc_length > max_description_length:\n        err_msg = error_message(line_num, f'description should not exceed {max_description_length} characters (currently {desc_length})')\n        err_msgs.append(err_msg)\n    \n    return err_msgs\n\n\ndef check_auth(line_num: int, auth: str) -> List[str]:\n\n    err_msgs = []\n\n    backtick = '`'\n    if auth != 'No' and (not auth.startswith(backtick) or not auth.endswith(backtick)):\n        err_msg = error_message(line_num, 'auth value is not enclosed with `backticks`')\n        err_msgs.append(err_msg)\n\n    if auth.replace(backtick, '') not in auth_keys:\n        err_msg = error_message(line_num, f'{auth} is not a valid Auth option')\n        err_msgs.append(err_msg)\n    \n    return err_msgs\n\n\ndef check_https(line_num: int, https: str) -> List[str]:\n\n    err_msgs = []\n\n    if https not in https_keys:\n        err_msg = error_message(line_num, f'{https} is not a valid HTTPS option')\n        err_msgs.append(err_msg)\n\n    return err_msgs\n\n\ndef check_cors(line_num: int, cors: str) -> List[str]:\n\n    err_msgs = []\n\n    if cors not in cors_keys:\n        err_msg = error_message(line_num, f'{cors} is not a valid CORS option')\n        err_msgs.append(err_msg)\n    \n    return err_msgs\n\n\ndef check_entry(line_num: int, segments: List[str]) -> List[str]:\n\n    raw_title = segments[index_title]\n    description = segments[index_desc]\n    auth = segments[index_auth]\n    https = segments[index_https]\n    cors = segments[index_cors]\n\n    title_err_msgs = check_title(line_num, raw_title)\n    desc_err_msgs = check_description(line_num, description)\n    auth_err_msgs = check_auth(line_num, auth)\n    https_err_msgs = check_https(line_num, https)\n    cors_err_msgs = check_cors(line_num, cors)\n\n    err_msgs = [\n        *title_err_msgs,\n        *desc_err_msgs,\n        *auth_err_msgs,\n        *https_err_msgs,\n        *cors_err_msgs\n    ]\n\n    return err_msgs\n\n\ndef check_file_format(lines: List[str]) -> List[str]:\n\n    err_msgs = []\n    category_title_in_index = []\n\n    alphabetical_err_msgs = check_alphabetical_order(lines)\n    err_msgs.extend(alphabetical_err_msgs)\n\n    num_in_category = min_entries_per_category + 1\n    category = ''\n    category_line = 0\n\n    for line_num, line_content in enumerate(lines):\n\n        category_title_match = category_title_in_index_re.match(line_content)\n        if category_title_match:\n            category_title_in_index.append(category_title_match.group(1))\n\n        # check each category for the minimum number of entries\n        if line_content.startswith(anchor):\n            category_match = anchor_re.match(line_content)\n            if category_match:\n                if category_match.group(1) not in category_title_in_index:\n                    err_msg = error_message(line_num, f'category header ({category_match.group(1)}) not added to Index section')\n                    err_msgs.append(err_msg)\n            else:\n                err_msg = error_message(line_num, 'category header is not formatted correctly')\n                err_msgs.append(err_msg)\n\n            if num_in_category < min_entries_per_category:\n                err_msg = error_message(category_line, f'{category} category does not have the minimum {min_entries_per_category} entries (only has {num_in_category})')\n                err_msgs.append(err_msg)\n\n            category = line_content.split(' ')[1]\n            category_line = line_num\n            num_in_category = 0\n            continue\n\n        # skips lines that we do not care about\n        if not line_content.startswith('|') or line_content.startswith('|---'):\n            continue\n\n        num_in_category += 1\n        segments = line_content.split('|')[1:-1]\n        if len(segments) < num_segments:\n            err_msg = error_message(line_num, f'entry does not have all the required columns (have {len(segments)}, need {num_segments})')\n            err_msgs.append(err_msg)\n            continue\n    \n        for segment in segments:\n            # every line segment should start and end with exactly 1 space\n            if len(segment) - len(segment.lstrip()) != 1 or len(segment) - len(segment.rstrip()) != 1:\n                err_msg = error_message(line_num, 'each segment must start and end with exactly 1 space')\n                err_msgs.append(err_msg)\n        \n        segments = [segment.strip() for segment in segments]\n        entry_err_msgs = check_entry(line_num, segments)\n        err_msgs.extend(entry_err_msgs)\n    \n    return err_msgs\n\n\ndef main(filename: str) -> None:\n\n    with open(filename, mode='r', encoding='utf-8') as file:\n        lines = list(line.rstrip() for line in file)\n\n    file_format_err_msgs = check_file_format(lines)\n\n    if file_format_err_msgs:\n        for err_msg in file_format_err_msgs:\n            print(err_msg)\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n\n    num_args = len(sys.argv)\n\n    if num_args < 2:\n        print('No .md file passed (file should contain Markdown table syntax)')\n        sys.exit(1)\n\n    filename = sys.argv[1]\n\n    main(filename)\n",
    "scripts/validate/links.py": "# -*- coding: utf-8 -*-\n\nimport re\nimport sys\nimport random\nfrom typing import List, Tuple\n\nimport requests\nfrom requests.models import Response\n\n\ndef find_links_in_text(text: str) -> List[str]:\n    \"\"\"Find links in a text and return a list of URLs.\"\"\"\n\n    link_pattern = re.compile(r'((?:https?://|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:\\'\\\".,<>?«»“”‘’]))')\n\n    raw_links = re.findall(link_pattern, text)\n\n    links = [\n        str(raw_link[0]) for raw_link in raw_links\n    ]\n\n    return links\n\n\ndef find_links_in_file(filename: str) -> List[str]:\n    \"\"\"Find links in a file and return a list of URLs from text file.\"\"\"\n\n    with open(filename, mode='r', encoding='utf-8') as file:\n        readme = file.read()\n        index_section = readme.find('## Index')\n        if index_section == -1:\n            index_section = 0\n        content = readme[index_section:]\n\n    links = find_links_in_text(content)\n\n    return links\n\n\ndef check_duplicate_links(links: List[str]) -> Tuple[bool, List]:\n    \"\"\"Check for duplicated links.\n\n    Returns a tuple with True or False and duplicate list.\n    \"\"\"\n\n    seen = {}\n    duplicates = []\n    has_duplicate = False\n\n    for link in links:\n        link = link.rstrip('/')\n        if link not in seen:\n            seen[link] = 1\n        else:\n            if seen[link] == 1:\n                duplicates.append(link)\n\n    if duplicates:\n        has_duplicate = True\n\n    return (has_duplicate, duplicates)\n\n\ndef fake_user_agent() -> str:\n    \"\"\"Faking user agent as some hosting services block not-whitelisted UA.\"\"\"\n\n    user_agents = [\n        'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1467.0 Safari/537.36',\n        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko)',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36',\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36',\n    ]\n\n    return random.choice(user_agents)\n\n\ndef get_host_from_link(link: str) -> str:\n\n    host = link.split('://', 1)[1] if '://' in link else link\n\n    # Remove routes, arguments and anchors\n    if '/' in host:\n        host = host.split('/', 1)[0]\n\n    elif '?' in host:\n        host = host.split('?', 1)[0]\n\n    elif '#' in host:\n        host = host.split('#', 1)[0]\n\n    return host\n\n\ndef has_cloudflare_protection(resp: Response) -> bool:\n    \"\"\"Checks if there is any cloudflare protection in the response.\n\n    Cloudflare implements multiple network protections on a given link,\n    this script tries to detect if any of them exist in the response from request.\n\n    Common protections have the following HTTP code as a response:\n        - 403: When host header is missing or incorrect (and more)\n        - 503: When DDOS protection exists\n\n    See more about it at:\n        - https://support.cloudflare.com/hc/en-us/articles/115003014512-4xx-Client-Error\n        - https://support.cloudflare.com/hc/en-us/articles/115003011431-Troubleshooting-Cloudflare-5XX-errors\n        - https://www.cloudflare.com/ddos/\n        - https://superuser.com/a/888526\n\n    Discussions in issues and pull requests:\n        - https://github.com/public-apis/public-apis/pull/2409\n        - https://github.com/public-apis/public-apis/issues/2960 \n    \"\"\"\n\n    code = resp.status_code\n    server = resp.headers.get('Server') or resp.headers.get('server')\n    cloudflare_flags = [\n        '403 Forbidden',\n        'cloudflare',\n        'Cloudflare',\n        'Security check',\n        'Please Wait... | Cloudflare',\n        'We are checking your browser...',\n        'Please stand by, while we are checking your browser...',\n        'Checking your browser before accessing',\n        'This process is automatic.',\n        'Your browser will redirect to your requested content shortly.',\n        'Please allow up to 5 seconds',\n        'DDoS protection by',\n        'Ray ID:',\n        'Cloudflare Ray ID:',\n        '_cf_chl',\n        '_cf_chl_opt',\n        '__cf_chl_rt_tk',\n        'cf-spinner-please-wait',\n        'cf-spinner-redirecting'\n    ]\n\n    if code in [403, 503] and server == 'cloudflare':\n        html = resp.text\n\n        flags_found = [flag in html for flag in cloudflare_flags]\n        any_flag_found = any(flags_found)\n\n        if any_flag_found:\n            return True\n\n    return False\n\n\ndef check_if_link_is_working(link: str) -> Tuple[bool, str]:\n    \"\"\"Checks if a link is working.\n\n    If an error is identified when the request for the link occurs,\n    the return will be a tuple with the first value True and the second\n    value a string containing the error message.\n\n    If no errors are identified, the return will be a tuple with the\n    first value False and the second an empty string.\n    \"\"\"\n\n    has_error = False\n    error_message = ''\n\n    try:\n        resp = requests.get(link, timeout=25, headers={\n            'User-Agent': fake_user_agent(),\n            'host': get_host_from_link(link)\n        })\n\n        code = resp.status_code\n\n        if code >= 400 and not has_cloudflare_protection(resp):\n            has_error = True\n            error_message = f'ERR:CLT: {code} : {link}'\n\n    except requests.exceptions.SSLError as error:\n        has_error = True\n        error_message = f'ERR:SSL: {error} : {link}'\n\n    except requests.exceptions.ConnectionError as error:\n        has_error = True\n        error_message = f'ERR:CNT: {error} : {link}'\n\n    except (TimeoutError, requests.exceptions.ConnectTimeout):\n        has_error = True\n        error_message = f'ERR:TMO: {link}'\n\n    except requests.exceptions.TooManyRedirects as error:\n        has_error = True\n        error_message = f'ERR:TMR: {error} : {link}'\n\n    except (Exception, requests.exceptions.RequestException) as error:\n        has_error = True\n        error_message = f'ERR:UKN: {error} : {link}'\n\n    return (has_error, error_message)\n\n\ndef check_if_list_of_links_are_working(list_of_links: List[str]) -> List[str]:\n    error_messages = []\n    for link in list_of_links:\n        has_error, error_message = check_if_link_is_working(link)\n\n        if has_error:\n            error_messages.append(error_message)\n\n    return error_messages\n\n\ndef start_duplicate_links_checker(links: List[str]) -> None:\n\n    print('Checking for duplicate links...')\n\n    has_duplicate_link, duplicates_links = check_duplicate_links(links)\n\n    if has_duplicate_link:\n        print(f'Found duplicate links:')\n\n        for duplicate_link in duplicates_links:\n            print(duplicate_link)\n\n        sys.exit(1)\n    else:\n        print('No duplicate links.')\n\n\ndef start_links_working_checker(links: List[str]) -> None:\n\n    print(f'Checking if {len(links)} links are working...')\n\n    errors = check_if_list_of_links_are_working(links)\n    if errors:\n\n        num_errors = len(errors)\n        print(f'Apparently {num_errors} links are not working properly. See in:')\n\n        for error_message in errors:\n            print(error_message)\n\n        sys.exit(1)\n\n\ndef main(filename: str, only_duplicate_links_checker: bool) -> None:\n\n    links = find_links_in_file(filename)\n\n    start_duplicate_links_checker(links)\n\n    if not only_duplicate_links_checker:\n        start_links_working_checker(links)\n\n\nif __name__ == '__main__':\n    num_args = len(sys.argv)\n    only_duplicate_links_checker = False\n\n    if num_args < 2:\n        print('No .md file passed')\n        sys.exit(1)\n    elif num_args == 3:\n        third_arg = sys.argv[2].lower()\n\n        if third_arg == '-odlc' or third_arg == '--only_duplicate_links_checker':\n            only_duplicate_links_checker = True\n        else:\n            print(f'Third invalid argument. Usage: python {__file__} [-odlc | --only_duplicate_links_checker]')\n            sys.exit(1)\n\n    filename = sys.argv[1]\n\n    main(filename, only_duplicate_links_checker)\n"
  },
  "requirements": null
}